<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>All Posts - My New Hugo Site</title><link>http://example.org/posts/</link><description>All Posts | My New Hugo Site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 18 Jul 2023 22:13:04 +0800</lastBuildDate><atom:link href="http://example.org/posts/" rel="self" type="application/rss+xml"/><item><title>First_post</title><link>http://example.org/posts/first_post/</link><pubDate>Tue, 18 Jul 2023 22:13:04 +0800</pubDate><author>Author</author><guid>http://example.org/posts/first_post/</guid><description>successful 6666666</description></item><item><title>前端框架</title><link>http://example.org/posts/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</link><pubDate>Thu, 11 May 2023 15:15:44 +0000</pubDate><author>Author</author><guid>http://example.org/posts/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/</guid><description><![CDATA[nvm管理node.js 环境： centos 7.9 nvm 安装 新创建一个名为myapp的桥接网卡
cd /root wget https://github.com/nvm-sh/nvm/archive/refs/tags/v0.39.3.tar.gz mkdir -p /root/.nvm tar -zxvf nvm-0.39.3.tar.gz -C /root/.nvm 配置环境
vim ~/.bashrc 在~/.bashrc的末尾，添加如下语句：
export NVM_DIR=&#34;$HOME/.nvm/nvm-0.39.3&#34; [ -s &#34;$NVM_DIR/nvm.sh&#34; ] &amp;&amp; \. &#34;$NVM_DIR/nvm.sh&#34; # This loads nvm [ -s &#34;$NVM_DIR/bash_completion&#34; ] &amp;&amp; \. &#34;$NVM_DIR/bash_completion&#34; # This loads nvm bash_completion 启用环境
source ~/.bashrc 安装node.js，测试
nvm install 8.16.0 切换版本
nvm use 8.16.0 查看已安装的版本
nvm ls ]]></description></item><item><title>docker创建专有网卡</title><link>http://example.org/posts/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/</link><pubDate>Wed, 22 Feb 2023 09:18:44 +0000</pubDate><author>Author</author><guid>http://example.org/posts/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/</guid><description>docker创建专有网卡 需求： tomcat容器需要通过jdbc模块连接数据库mysql，配置文件如果指定IP地址，mysql容器一旦损坏，IP地址就会更改，需要将mysql容器的IP固定。这样就不用每次更改tomcat配置文件了。
专有网卡创建 新创建一个名为myapp的桥接网卡
docker network create myapp 使用--network-alias参数给网卡起别名，启动MySQL容器。
docker run -d \ --network myapp --network-alias mysql1 \ --name=mysql57-test \ -p 33306:3306 \ -v /tmpdisk/test2:/var/lib/mysql \ -v /etc/localtime:/etc/localtime:ro \ -e MYSQL_ROOT_PASSWORD=123456 \ -e MYSQL_DATABASE=todos \ mysql:5.7 注意：这里创建的mysql容器使用myapp 网卡，分配的IP自动和mysql1 网卡别名绑定，后面创建的容器只要使用同一个网卡创建的，都可以和mysql容器互通。
如何证明呢？
使用nicolaka/netshoot镜像创建一个测试容器
docker run -it --name test --network myapp nicolaka/netshoot 可以直接和mysql容器通信
62337a7ad7f1# ping mysql1 PING mysql1 (172.20.0.5) 56(84) bytes of data. 64 bytes from mysql57-test.myapp (172.20.0.5): icmp_seq=1 ttl=64 time=0.042 ms 64 bytes from mysql57-test.</description></item><item><title>docker使用tab自动补全命令</title><link>http://example.org/posts/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/</link><pubDate>Tue, 21 Feb 2023 10:38:44 +0000</pubDate><author>Author</author><guid>http://example.org/posts/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/</guid><description><![CDATA[docker使用tab自动补全命令 On RHEL-based systems dnf install bash-completion -y yum install bash-completion -y On Debian-based systems apt-get install bash-completion -y 下载命令补全文件 curl https://raw.githubusercontent.com/docker/docker-ce/master/components/cli/contrib/completion/bash/docker -o /etc/bash_completion.d/docker.sh 如果下载失败最后附上文件内容。 重新登录终端 测试命令补全 docker p 两次tab ,命令自动补全 pause plugin port ps pull push 整理 先安装补全软件bash-completion，然后在/etc/bash_completion.d目录下创建文件，写入补全命令，重新登录终端，自动生效。
docker.sh文件内容如下：
#!/usr/bin/env bash # shellcheck disable=SC2016,SC2119,SC2155,SC2206,SC2207,SC2254 # # Shellcheck ignore list: # - SC2016: Expressions don&#39;t expand in single quotes, use double quotes for that. # - SC2119: Use foo &#34;$@&#34; if function&#39;s $1 should mean script&#39;s $1.]]></description></item><item><title>使用浏览器登录linux服务器</title><link>http://example.org/posts/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Mon, 20 Feb 2023 09:38:44 +0000</pubDate><author>Author</author><guid>http://example.org/posts/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>使用浏览器登录linux服务器 项目地址 https://github.com/huashengdun/webssh/releases/tag/v1.6.1 在这里我选在下载的版本是：v1.6.1 上传到服务器上
开始安装 创建解压目录 mkdir -p /tmpdisk/webssh 解压离线webssh安装包 cd /tmpdisk/webssh unzip webssh-1.6.1.zip . 进入解压目录 cd webssh-1.6.1 使用docker-compose一键启动 docker-compose up 安装docker-compose wget https://github.com/docker/compose/releases/download/1.24.0/docker-compose-Linux-x86_64 赋予文件执行权限 chmod +x docker-compose-Linux-x86_64 拷贝到目录 cp docker-compose-Linux-x86_64 /usr/local/bin/docker-compose 添加软链接 ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 最后查看版本 docker-compose --version webssh使用 使用docker-compose 启动后默认将容器内的8888 端口映射到宿主机8888.通过访问宿主机的8888端口，打开webssh页面，登录Linux服务器。</description></item><item><title>centos7.3离线安装docker</title><link>http://example.org/posts/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/</link><pubDate>Fri, 17 Feb 2023 13:38:44 +0000</pubDate><author>Author</author><guid>http://example.org/posts/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/</guid><description>离线安装 [root@HZ ~]$ uname -a Linux HZ 3.10.0-514.el7.centos.x86_64 #1 SMP Fri Jan 13 15:16:57 CST 2017 x86_64 x86_64 x86_64 GNU/Linux CentOS Linux release 7.3.1611 (Core) 离线包下载 https://download.docker.com/linux/static/stable/x86_64/ 在这里我选在下载的版本是：docker-20.10.9.tgz 上传到服务器上
开始安装 创建数据存储目录，如果不创建默认是/var/lib/docker
mkdir -p /tmpdisk/docker 创建解压目录 mkdir -p /tmpdisk/docker20.10.9 解压离线docker安装包 tar -zxvf docker-20.10.9.tgz -C /tmpdisk/docker20.10.9 进入解压目录 cd /tmpdisk/docker20.10.9/docker/bin cp * /usr/bin 创建开机自启文件 vi /etc/systemd/system/docker.service 输入以下内容 [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/bin/dockerd --selinux-enabled=false --insecure-registry=127.0.0.1 ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.</description></item><item><title>centos搭建内网邮件服务</title><link>http://example.org/posts/centos%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</link><pubDate>Fri, 10 Feb 2023 13:14:00 +0000</pubDate><author>Author</author><guid>http://example.org/posts/centos%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/</guid><description>安装环境 centos7.9 postfix2.10.1 dovecot2.2.36 foxmail(windows版) 功能概括 使用foxmail软件登录邮件服务器（192.168.1.89）能够成功发送和接收邮件。
具体实现配置步骤 搭建邮件服务器
配置服务器主机名称，服务器主机名称与发信域名要一致。
[root@mail ~]# vi /etc/hostname mail.lee.com [root@mail ~]# hostname mail.lee.com 配置postfix服务
yum install postfix 如果系统自带postfix，建议先卸载旧程序，然后再安装新程序。
rpm -e postfix 编辑postfix 程序主配置文件/etc/postfix/main.cf
75 myhostname = mail.lee.com 83 mydomain = lee.com 99 myorigin = $mydomain 113 inet_interfaces = all 119 inet_protocols = ipv4 164 mydestination = $myhostname, $mydomain 264 mynetworks = 192.168.1.0/24, 127.0.0.0/8 启动postfix并加入开机自启
systemctl restart postfix systemctl enable postfix 配置dovecot服务程序
yum install dovecot 配置dovecot主配置文件/etc/dovecot/dovecot.</description></item><item><title>二级域名创建与部署</title><link>http://example.org/posts/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/</link><pubDate>Tue, 24 Jan 2023 23:21:21 +0000</pubDate><author>Author</author><guid>http://example.org/posts/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/</guid><description><![CDATA[二级域名创建与部署 首先你需要拥有一个顶级域名 我是在namesoli购买的域名。可以查看该顶级域名能够创建二级域名最大数量。
登录账户，点击account Domains。
可以看到我们购买的域名，然后点击域名，进入域名控制台。
可以看到子域名转发选项，点击它。进入子域名配置界面。
点击help按钮，可以看到当前我们购买的顶级域名最多能够创建50个子域名。
二级域名（子域名）的格式 比如我的网站是www.haipengv.com,可以通过访问blog.haipengv.com查看我的博客。在haipengv.com前面用.隔开加任意字符就是二级域名的格式。
部署烟花网站 首先在github上部署项目
登录github，创建一个公开的新仓库。
复制仓库的ssh地址，一会连接库时需要。
准备上传烟花代码，在本地创建一个文件夹E:\fireworkshow。需要确保本地已经搭建好git环境。将烟花代码复制到E:\fireworkshow内。创建一个新文件夹test并进入test文件夹。此时所在位置E:\fireworkshow\test。
将仓库代码同步到本地test目录内
git clone git@github.com:Smithkenny/fireworkshow.git 将E:\fireworkshow\test\fireworkshow文件夹内的所有文件复制到E:\fireworkshow。然后删除空文件夹test和fireworkshow。
运行以下命令
git add . git commit -m &#34;上传代码测试&#34; git push origin main 这里注意我们默认创建的仓库主分支是main。
代码上传完毕后，此时还不能访问。
我这里使用cloudflare做一条域名解析。
登录cloudflare，找到DNS选项，添加一条A记录。指向一个ipv4地址。这里的地址是ping 仓库域名得来的。
2023.haipengv.com&ndash;&gt;ipv4地址
添加好A记录后，回到仓库，点击settings，找到pages选项，配置我们二级域名。稍等十分钟左右，就可以通过二级域名2023.haipengv.com访问我们的网站了。
遇到的问题 网站中音乐文件很大，超过2M，音乐加载超时，如何提升加载速度？
解决办法 将大文件上传到网盘，复制网盘对应的文件路径，将该路径添加到index.html文件中。我这里用的是永硕网盘。
最后访问2023.haipengv.com欣赏烟花吧！
相关参考
https://blog.wangriyu.wang/2018/01-githubpage.html ]]></description></item><item><title>centos7使用systemd管理程序</title><link>http://example.org/posts/centos7%E4%BD%BF%E7%94%A8systemd%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F/</link><pubDate>Tue, 03 Jan 2023 13:07:00 +0000</pubDate><author>Author</author><guid>http://example.org/posts/centos7%E4%BD%BF%E7%94%A8systemd%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F/</guid><description>centos7使用systemd管理程序 systemd的配置文件主要放在/usr/lib/systemd/system目录，也可能在/etc/systemd/system目录。
学习下sshd的系统配置文件写法：
$cat sshd.service [Unit] Description=OpenSSH server daemon Documentation=man:sshd(8) man:sshd_config(5) After=network.target sshd-keygen.service Wants=sshd-keygen.service [Service] Type=forking PIDFile=/var/run/sshd.pid EnvironmentFile=/etc/sysconfig/sshd ExecStart=/usr/sbin/sshd $OPTIONS ExecReload=/bin/kill -HUP $MAINPID KillMode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target 简单解释下：
[Unit] 区块：启动顺序与依赖关系。
Description：当前配置文件的描述信息。 Documentation：帮助信息。 After：表示当前服务是在那个服务后面启动，一般定义为网络服务启动后启动 Wants：表示 sshd.service 与 sshd-keygen.service 之间存在” 弱依赖” 关系，即如果”sshd-keygen.service” 启动失败或停止运行，不影响 sshd.service 继续执行。 [Service] 区块：启动行为
Type：定义启动类型。详细了解点此。 PIDFile：服务的 pid 文件路径。 EnvironmentFile：指定当前服务依赖的环境参数文件。 ExecStart：定义启动进程时执行的命令。 ExecReload：重启服务时执行的命令 KillMode：定义 Systemd 如何停止 sshd 服务。 Restart：定义了 sshd 退出后，Systemd 的重启方式。 RestartSec：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待 42 秒。 [Install] 区块：定义如何安装这个配置文件，即怎样做到开机启动。
WantedBy：表示该服务所在的 Target。multi-user.</description></item><item><title>linux根分区满了处理方法</title><link>http://example.org/posts/linux%E6%A0%B9%E5%88%86%E5%8C%BA%E6%BB%A1%E4%BA%86%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</link><pubDate>Wed, 28 Dec 2022 10:45:21 +0000</pubDate><author>Author</author><guid>http://example.org/posts/linux%E6%A0%B9%E5%88%86%E5%8C%BA%E6%BB%A1%E4%BA%86%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</guid><description>linux根分区满了处理方法 通过命令查看根分区内的大文件 du -sh /* 2&amp;gt;/dev/null | sort -hr | head -3 如果上述命令执行后发现/var/占空间最大，那么在查找/var分区内的大文件，如： du -sh /var/* 2&amp;gt;/dev/null | sort -hr | head -3 以此类推，最后找到那个大文件，删除或者采取其他措施（移动到替他路径）即可！ 注意：接业务报障，一般是因为应用程序配置错误，导致在/var/log目录下会生成很大的日志文件，进而导致/var分区使用了达到100%，这个可以临时将之前的log日志大文件移动到其他路径下，但后期还需要业务侧对应用配置进行优化才行。</description></item></channel></rss>