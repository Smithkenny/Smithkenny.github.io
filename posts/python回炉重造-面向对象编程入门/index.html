<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>python回炉重造-面向对象编程入门 - My New Hugo Site</title><meta name=Description content="This is my cool site"><meta property="og:title" content="python回炉重造-面向对象编程入门"><meta property="og:description" content="面向对象编程入门 程序是指令的集合
函数： 把相互独立且经常重复使用的代码放置到函数中，在需要使用这些代码的时候调用函数即可。
在面向对象编程的世界里，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为对象。对象可以接收消息。解决问题的方法是创建对象并向对象发出各种各样的消息。通过消息的传递，程序中的多个对象可以协同工作，这样就能构造出复杂的系统并解决现实中的问题。
类和对象 面向对象编程：把一组数据和处理数据的方法组成对象，把行为相同的对象归纳为类，通过封装隐藏对象的内部细节，通过继承实现类的特化和泛化，通过多态实现基于对象类型的动态分派。
对象（object）
类（class）
封装（encapsulation）
继承（inheritance）
多态（polymorphism）
在面向对象编程中，**类是一个抽象的概念，对象是一个具体的概念。**我们把同一类对象的共同特征抽出来就是一个类。比如 人类 就是一个抽象概念，我们每个人就是人类的这个抽象概念下的实实在在的存在，也就是一个对象。简而言之，类是对象的蓝图和模板，对象是类的实例，是可以接收消息的实体。
类属性和类方法 术语&ndash;实例
1.使用面向对象开发， 先设计类
2.使用 **类名()**创建对象，创建对象 的动作有两步
​	1.在内存空间中为对象 分配空间
2. 调用初始化方法`__init__`为对象初始化 3.对象创建后， 内存中就有了一个对象 的实实在在 的存在 &ndash; 实例
因此，通常也会把：
创建出来的 对象 叫做 类的实例
创建对象的 动作 叫做 实例化
对象的属性 叫做 实例属性
对象调用的方法 叫做 实例方法
在程序执行时：
1.对象各自拥有自己的 实例属性
2.调用对象方法，可以通过self.
访问自己的属性
调用自己的方法
结论
每一个对象 都有自己 独立的内存空间，保存各自不同的属性
多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用 传递到方法内部
类是一个特殊的对象 python中 一切皆对象
class AAA: 定义的类属于 类对象
obj1 = AAA()属于 实例对象"><meta property="og:type" content="article"><meta property="og:url" content="https://blog.haipengv.com/posts/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-03T22:10:37+00:00"><meta property="article:modified_time" content="2022-07-03T22:10:37+00:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary"><meta name=twitter:title content="python回炉重造-面向对象编程入门"><meta name=twitter:description content="面向对象编程入门 程序是指令的集合
函数： 把相互独立且经常重复使用的代码放置到函数中，在需要使用这些代码的时候调用函数即可。
在面向对象编程的世界里，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为对象。对象可以接收消息。解决问题的方法是创建对象并向对象发出各种各样的消息。通过消息的传递，程序中的多个对象可以协同工作，这样就能构造出复杂的系统并解决现实中的问题。
类和对象 面向对象编程：把一组数据和处理数据的方法组成对象，把行为相同的对象归纳为类，通过封装隐藏对象的内部细节，通过继承实现类的特化和泛化，通过多态实现基于对象类型的动态分派。
对象（object）
类（class）
封装（encapsulation）
继承（inheritance）
多态（polymorphism）
在面向对象编程中，**类是一个抽象的概念，对象是一个具体的概念。**我们把同一类对象的共同特征抽出来就是一个类。比如 人类 就是一个抽象概念，我们每个人就是人类的这个抽象概念下的实实在在的存在，也就是一个对象。简而言之，类是对象的蓝图和模板，对象是类的实例，是可以接收消息的实体。
类属性和类方法 术语&ndash;实例
1.使用面向对象开发， 先设计类
2.使用 **类名()**创建对象，创建对象 的动作有两步
​	1.在内存空间中为对象 分配空间
2. 调用初始化方法`__init__`为对象初始化 3.对象创建后， 内存中就有了一个对象 的实实在在 的存在 &ndash; 实例
因此，通常也会把：
创建出来的 对象 叫做 类的实例
创建对象的 动作 叫做 实例化
对象的属性 叫做 实例属性
对象调用的方法 叫做 实例方法
在程序执行时：
1.对象各自拥有自己的 实例属性
2.调用对象方法，可以通过self.
访问自己的属性
调用自己的方法
结论
每一个对象 都有自己 独立的内存空间，保存各自不同的属性
多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用 传递到方法内部
类是一个特殊的对象 python中 一切皆对象
class AAA: 定义的类属于 类对象
obj1 = AAA()属于 实例对象"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.haipengv.com/posts/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/><link rel=prev href=https://blog.haipengv.com/posts/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/><link rel=next href=https://blog.haipengv.com/posts/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"python回炉重造-面向对象编程入门","inLanguage":"en-us","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/blog.haipengv.com\/posts\/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8\/"},"genre":"posts","wordcount":1343,"url":"https:\/\/blog.haipengv.com\/posts\/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8\/","datePublished":"2022-07-03T22:10:37+00:00","dateModified":"2022-07-03T22:10:37+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Author"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="My New Hugo Site">My cool site</a></div><div class=menu><div class=menu-inner><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="My New Hugo Site">My cool site</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">python回炉重造-面向对象编程入门</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Author</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2022-07-03>2022-07-03</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;1343 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;7 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#面向对象编程入门>面向对象编程入门</a><ul><li><a href=#类和对象>类和对象</a></li></ul></li><li><a href=#类属性和类方法>类属性和类方法</a><ul><li><a href=#类是一个特殊的对象>类是一个特殊的对象</a></li></ul></li><li><a href=#定义类>定义类</a><ul><li><a href=#创建和使用对象>创建和使用对象</a></li></ul></li><li><a href=#初始化方法>初始化方法</a></li><li><a href=#打印对象>打印对象</a></li><li><a href=#面向对象的支柱>面向对象的支柱</a></li><li><a href=#继承>继承</a><ul><li><a href=#单继承>单继承</a></li><li><a href=#继承语法>继承语法</a></li><li><a href=#继承的传递性>继承的传递性</a></li><li><a href=#方法的重写>方法的重写</a></li><li><a href=#父类的-私有属性-和私有方法>父类的 私有属性 和私有方法</a></li><li><a href=#多继承>多继承</a></li><li><a href=#多继承的使用注意事项>多继承的使用注意事项</a></li><li><a href=#python-中的mro方法搜索顺序>python 中的MRO——方法搜索顺序</a></li><li><a href=#新式类和旧式类经典类>新式类和旧式类（经典类）</a></li></ul></li><li><a href=#可见性和属性的装饰器>可见性和属性的装饰器</a><ul><li><a href=#装饰器>装饰器</a></li></ul></li><li><a href=#动态属性>动态属性</a></li><li><a href=#静态方法和类方法>静态方法和类方法</a><ul><li><a href=#小结-1>小结</a></li></ul></li><li><a href=#多态>多态</a><ul><li><a href=#多态案例演练>多态案例演练</a></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=面向对象编程入门>面向对象编程入门</h2><p>程序是指令的集合</p><p>函数： 把相互独立且经常重复使用的代码放置到函数中，在需要使用这些代码的时候调用函数即可。</p><p>在面向对象编程的世界里，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为<strong>对象</strong>。对象可以接收消息。解决问题的方法是创建对象并向对象发出各种各样的消息。通过消息的传递，程序中的多个对象可以协同工作，这样就能构造出复杂的系统并解决现实中的问题。</p><h3 id=类和对象>类和对象</h3><p>面向对象编程：把一组数据和处理数据的方法组成<strong>对象</strong>，把行为相同的对象归纳为<strong>类</strong>，通过<strong>封装</strong>隐藏对象的内部细节，通过<strong>继承</strong>实现类的特化和泛化，通过<strong>多态</strong>实现基于对象类型的动态分派。</p><p><strong>对象（object）</strong></p><p><strong>类（class）</strong></p><p><strong>封装（encapsulation）</strong></p><p><strong>继承（inheritance）</strong></p><p><strong>多态（polymorphism）</strong></p><p>在面向对象编程中，**类是一个抽象的概念，对象是一个具体的概念。**我们把同一类对象的共同特征抽出来就是一个类。比如 人类 就是一个抽象概念，我们每个人就是人类的这个抽象概念下的实实在在的存在，也就是一个对象。简而言之，<strong>类是对象的蓝图和模板，对象是类的实例，是可以接收消息的实体。</strong></p><h2 id=类属性和类方法>类属性和类方法</h2><p><strong>术语&ndash;实例</strong></p><p>1.使用面向对象开发， 先设计类</p><p>2.使用 **类名()**创建对象，<strong>创建对象</strong> 的动作有两步</p><p>​ 1.在内存空间中为对象 <strong>分配空间</strong></p><pre><code>2. 调用初始化方法`__init__`为对象初始化
</code></pre><p>3.对象创建后， <strong>内存</strong>中就有了一个对象 的<strong>实实在在 的存在</strong> &ndash; 实例</p><p>因此，通常也会把：</p><p>创建出来的 <strong>对象</strong> 叫做 <strong>类的实例</strong></p><p>创建对象的 <strong>动作</strong> 叫做 <strong>实例化</strong></p><p><strong>对象的属性</strong> 叫做 <strong>实例属性</strong></p><p><strong>对象调用的方法</strong> 叫做 <strong>实例方法</strong></p><p>在程序执行时：</p><p>1.对象各自拥有自己的 实例属性</p><p>2.调用对象方法，可以通过<code>self.</code></p><p>访问自己的属性</p><p>调用自己的方法</p><p><strong>结论</strong></p><p><strong>每一个对象</strong> 都有自己 <strong>独立的内存空间</strong>，<strong>保存各自不同的属性</strong></p><p><strong>多个对象的方法</strong>，<strong>在内存中只有一份</strong>，在调用方法时，<strong>需要把对象的引用</strong> 传递到方法内部</p><h3 id=类是一个特殊的对象>类是一个特殊的对象</h3><p>python中 <strong>一切皆对象</strong></p><p><code>class AAA: </code>定义的类属于 <strong>类对象</strong></p><p><code>obj1 = AAA()</code>属于 <strong>实例对象</strong></p><p>在程序运行时， 类 同样 会被加载到内存</p><p>在 <code>python</code>中， 类是一个特殊的对象 &ndash; 类对象</p><p>在程序运行时， 类对象 在内存中 只有一份， 使用 一个类 可以创建出 很多个对象实例</p><p>除了封装 实例的 属性 和方法外，类对象 哈可以拥有自己的 属性和方法</p><p>类属性</p><p>类方法</p><p>通过 <code>类名.</code>的方式 可以访问类的属性 或者 调用类的方法</p><h2 id=定义类>定义类</h2><p>在python中，用<code>class</code>关键字加上类名来定义类，通过缩进确定类的代码块。类的代码块中写函数，这些函数是对<strong>一类对象共同的动态特征的提取</strong>。写在类里面的函数我们称之为<strong>方法</strong>。方法是对象的行为，也就是对象可以接收的消息。方法的第一个参数是<code>self</code>，它代表接收这个消息的对象本身。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>类名首字母要大写，Student类中定义了 study 和 play 两个方法。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>两个方法第一个参数`self`代表接收消息的学生对象，`study`方法的第二个参数是学习的课程名称。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>study</span>(self, course_name):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;学生正在学习</span><span style=color:#e6db74>{</span>course_name<span style=color:#e6db74>}</span><span style=color:#e6db74>.&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>play</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;学生正在玩游戏.&#39;</span>)
</span></span></code></pre></div><h3 id=创建和使用对象>创建和使用对象</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 当前的stu1 是Student这个类的对象 是一个具体的实例</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stu1 <span style=color:#f92672>=</span> Student()
</span></span><span style=display:flex><span>stu2 <span style=color:#f92672>=</span> Student()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 当前输出的值为这个具体实例在内存中的地址 十六进制的值</span>
</span></span><span style=display:flex><span>print(stu1) <span style=color:#75715e># &lt;__main__.Student object at 0x7f4c9b62af70&gt;</span>
</span></span><span style=display:flex><span>print(stu2) <span style=color:#75715e># &lt;__main__.Student object at 0x7f4c9b5ffb50&gt;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(hex(id(stu1)), hex(id(stu2))) <span style=color:#75715e># 0x7f4c9b62af70 0x7f4c9b5ffb50</span>
</span></span></code></pre></div><p>定义变量其实是保存 一个对象在内存中的地址（十六进制形式），和用<code>id</code>函数查看的值是相同的。</p><p>通过这个逻辑地址，就能在内存中找到这个对象。</p><p>常见报错，类没有实例化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Student<span style=color:#f92672>.</span>study(<span style=color:#e6db74>&#39;python&#39;</span>) <span style=color:#75715e># TypeError: study() missing 1 required positional argument: &#39;course_name&#39;</span>
</span></span></code></pre></div><p>正确写法，在调用类中方法时先 <strong>进行类的实例化</strong>。<strong>类名后加小括号就是类的实例化。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>Student()<span style=color:#f92672>.</span>study(<span style=color:#e6db74>&#39;java&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># 学生正在学习java.</span>
</span></span></code></pre></div><p>也可以将类实例化后赋给一个变量，像<code>stu1 = Student()</code>。后面调用类中的方法时就可以用<code>变量名.方法名</code>来调用方法。例如<code>stu1.play()</code>。</p><h2 id=初始化方法>初始化方法</h2><p>上面创建的对象只有行为没有属性，使用<code>__init__</code>方法来初始化属性。</p><p>修改<code>Student</code>类，给学生对象添加<code>name</code>（姓名）和<code>age</code>（年龄）两个属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>:
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;初始化方法 给当前对象创建属性&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self,name, age):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 给当前类添加属性</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>study</span>(self, course_name):
</span></span><span style=display:flex><span>       <span style=color:#75715e># 属性使用self 进行调用 参数是直接调用</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>正在学习</span><span style=color:#e6db74>{</span>course_name<span style=color:#e6db74>}</span><span style=color:#e6db74>.&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>play</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;玩耍&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>正在玩游戏.&#39;</span>)
</span></span></code></pre></div><p>由于初始化方法除了self之外还有两个参数，所以调用Student 类的构造器创建的对象时要传入这两个参数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>stu1 <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;john&#39;</span>, <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span>stu1<span style=color:#f92672>.</span>study(<span style=color:#e6db74>&#39;python&#39;</span>) <span style=color:#75715e># john正在学习python.</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stu2 <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;smith&#39;</span>, <span style=color:#ae81ff>30</span>)
</span></span><span style=display:flex><span>stu2<span style=color:#f92672>.</span>play() <span style=color:#75715e># smith正在玩游戏.</span>
</span></span></code></pre></div><h2 id=打印对象>打印对象</h2><p>在python中，以两个下划线<code>__</code>、开头和结尾的方法通常都是有特殊用途和意义的方法，我们一般称之为 <strong>魔术方法或魔法方法</strong>。</p><p>如果我们在打印对象时候不希望看到对象的地址二十看到我们自定义的信息。可以通过在类中使用<code>__repr__</code>魔术方法来做到。该方法返回的字符串就是用<code>print</code>函数打印对象的时候会显示的内容。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#75715e># 使用类中内置魔术方法来实现</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> __repr__(self):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>: </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>age<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 类实例化    </span>
</span></span><span style=display:flex><span>stu1 <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;john&#39;</span>, <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># 打印当前对象</span>
</span></span><span style=display:flex><span>print(stu1) <span style=color:#75715e># john: 20</span>
</span></span></code></pre></div><h2 id=面向对象的支柱>面向对象的支柱</h2><p>封装： 隐藏一切可以隐藏的实现细节，只向外界暴露简单的调用接口。</p><p>在类型中定义的对象其实是一种封装。在创建对象后，只需要给对象发送一个消息就可以执行方法中的代码，也就是说我们在只知道方法名字和参数（方法外部视图），不知道方法内部实现细节（方法内部视图）的情况下就完成了对方法的使用。</p><p>根据 <strong>职责</strong>将<strong>属性</strong>和<strong>方法</strong>封装到一个抽象的<strong>类</strong>中</p><p>继承：<strong>实现代码的重用</strong>，相同的代码不需要重复编写</p><p>多态：不同的对象调用相同的方法，产生不同的执行结果，<strong>增加代码的灵活度</strong>。</p><h2 id=继承>继承</h2><h3 id=单继承>单继承</h3><p><strong>继承的概念</strong>： <strong>子类</strong> 拥有 <strong>父类</strong>的所有<strong>方法</strong>和<strong>属性</strong></p><p>案例1：不使用继承创建两个类<code>动物类</code>和<code>狗类</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>开发两个类
</span></span></span><span style=display:flex><span><span style=color:#e6db74>动物类
</span></span></span><span style=display:flex><span><span style=color:#e6db74>狗类
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>动物类具有四个特性
</span></span></span><span style=display:flex><span><span style=color:#e6db74>吃
</span></span></span><span style=display:flex><span><span style=color:#e6db74>喝
</span></span></span><span style=display:flex><span><span style=color:#e6db74>跑
</span></span></span><span style=display:flex><span><span style=color:#e6db74>睡
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>狗的特性
</span></span></span><span style=display:flex><span><span style=color:#e6db74>吃
</span></span></span><span style=display:flex><span><span style=color:#e6db74>喝
</span></span></span><span style=display:flex><span><span style=color:#e6db74>跑
</span></span></span><span style=display:flex><span><span style=color:#e6db74>睡
</span></span></span><span style=display:flex><span><span style=color:#e6db74>汪汪叫
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>:
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>eat</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;吃&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>drink</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;喝&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;跑&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sleep</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;睡&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>eat</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;吃&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>drink</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;喝&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;跑&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sleep</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;睡&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bark</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;汪汪叫&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>laoha <span style=color:#f92672>=</span> Dog()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>laoha<span style=color:#f92672>.</span>eat()
</span></span><span style=display:flex><span>laoha<span style=color:#f92672>.</span>drink()
</span></span><span style=display:flex><span>laoha<span style=color:#f92672>.</span>run()
</span></span><span style=display:flex><span>laoha<span style=color:#f92672>.</span>sleep()
</span></span><span style=display:flex><span>laoha<span style=color:#f92672>.</span>bark()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>当前动物类和狗类的四个方法已经重复了
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>如何解决这样的情况
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>继承
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span></code></pre></div><p>使用继承特性较少重复代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>:
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>eat</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;吃&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>drink</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;喝&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;跑&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sleep</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;睡&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>(Animal):
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bark</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;汪汪叫&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 类实例化</span>
</span></span><span style=display:flex><span>laoha <span style=color:#f92672>=</span> Dog()
</span></span><span style=display:flex><span><span style=color:#75715e># 调用类中方法</span>
</span></span><span style=display:flex><span>laoha<span style=color:#f92672>.</span>eat()
</span></span><span style=display:flex><span>laoha<span style=color:#f92672>.</span>drink()
</span></span><span style=display:flex><span>laoha<span style=color:#f92672>.</span>run()
</span></span><span style=display:flex><span>laoha<span style=color:#f92672>.</span>sleep()
</span></span><span style=display:flex><span>laoha<span style=color:#f92672>.</span>bark()
</span></span></code></pre></div><h3 id=继承语法>继承语法</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>类名</span>(父类名):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p><strong>子类</strong> 继承自 <strong>父类</strong>，可以直接<strong>享受</strong> 父类中 已经封装好的方法，不需要再次开发。</p><p><strong>子类</strong> 中应该根据 职责，封装 子类特有的属性和方法</p><h4 id=专业术语>专业术语</h4><p><code>Dog</code> 类是<code>Animal</code>类的子集，<code>Animal</code>类是<code>Dog</code>类的父类，<code>Dog</code>类从 <code>Animal</code>类继承</p><p><code>Dog</code>类是 <code>Animal</code>类的派生类，<code>Animal</code>类是<code>Dog</code>类的基类，<code>Dog</code>类从 <code>Animal</code>类派生</p><h3 id=继承的传递性>继承的传递性</h3><p><code>C</code>类从<code>B</code>类继承，<code>B</code>类又从<code>A</code>类继承</p><p>那么<code>C</code>类就具有<code>B</code>类和<code>A</code>类的所有属性和方法</p><p><strong>子类</strong> 拥有 <strong>父类</strong> 以及 <strong>父类的父类</strong> 中封装的所有<strong>属性</strong>和<strong>方法</strong>。</p><h4 id=应用场景>应用场景</h4><p>当 父类 的方法实现不能满足子类需求时，可以对方法进行重写。</p><p><code>Dog</code>是<code>XiaoTianQuan</code>的父类，</p><p><code>Animal</code>又是<code>Dog</code>的父类。</p><p>所以<code>XiaoTianQuan</code>可以继承<code>Dog</code>和<code>Animal</code>中定义的所有方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>:
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>eat</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;吃&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>drink</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;喝&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;跑&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sleep</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;睡&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>(Animal):
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bark</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;汪汪叫&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>XiaoTianQuan</span>(Dog):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fly</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;飞&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 类实例化</span>
</span></span><span style=display:flex><span>wangwang <span style=color:#f92672>=</span> XiaoTianQuan()
</span></span><span style=display:flex><span><span style=color:#75715e># 可以调用自身定义的方法</span>
</span></span><span style=display:flex><span>wangwang<span style=color:#f92672>.</span>fly()
</span></span><span style=display:flex><span><span style=color:#75715e># 也可以调用父类以及父父类的方法</span>
</span></span><span style=display:flex><span>wangwang<span style=color:#f92672>.</span>bark()
</span></span><span style=display:flex><span>wangwang<span style=color:#f92672>.</span>run()
</span></span></code></pre></div><h3 id=方法的重写>方法的重写</h3><p>子类 拥有 父类的 所有方法 和属性</p><p>子类 继承自 父类，可以直接 享受 父类中已经封装好的方法， 不需要再次开发。</p><p>重写 父类方法有两种情况：</p><p>1.覆盖 父类的方法</p><p>如何在开发中， <strong>父类的方法实现</strong> 和 <strong>子类的方法实现</strong>，完全不同。</p><p>就可以使用 <strong>覆盖</strong> 的方法，在子类中 <strong>重新编写</strong> 父类的方法实现</p><p>具体的实现方式，就相当于在 子类中定义了一个 <strong>和父类同名的方法</strong>并且实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>:
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>eat</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;吃&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>drink</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;喝&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;跑&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sleep</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;睡&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>(Animal):
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bark</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;汪汪叫&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>XiaoTianQuan</span>(Dog):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fly</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;飞&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#75715e># bark方法的重写，规则：和继承的方法名称一样。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bark</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;叫的和神一样....&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wangwang <span style=color:#f92672>=</span> XiaoTianQuan()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wangwang<span style=color:#f92672>.</span>bark() <span style=color:#75715e># 叫的和神一样....</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>哮天犬是神犬和普通狗叫声不一样,
</span></span></span><span style=display:flex><span><span style=color:#e6db74>XiaoTianQuan 类中定义自己的方法，由于继承了父类（Dog）类的bark 方法。这里 覆盖父类的bark方法，创建一个和父类同名的方法。来区分神犬的叫声。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span></code></pre></div><h4 id=小结>小结：</h4><p>在子类中重写了父类的方法后，在进行方法调用时会执行子类中重写的方法。</p><p>2.对父类方法进行扩展</p><p>如果在开发中， <strong>子类的方法实现</strong>中 包含 <strong>父类的方法实现</strong></p><p>父类原本封装的方法实现 是 <strong>子类方法的一部分</strong></p><p>就可以使用 <strong>扩展</strong> 的方式</p><p>1.在子类中 重写 父类的方法</p><p>2.在需要的位置使用<code>super().父类方法</code>来调用父类方法的执行</p><p>3.代码其他的位置针对子类的需求，编写 子类特有的代码实现</p><p>关于 <code>super</code></p><p>在python中<code>super</code>是一个 <strong>特殊的类</strong></p><p><code>super()</code>就是使用<code>super</code>类创建出来的对象</p><p>最常 使用的场景是 在<strong>重写父类方法时</strong>，调用 <strong>在父类中封装的方法实现</strong>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Animal</span>:
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>eat</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;吃&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>drink</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;喝&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>run</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;跑&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sleep</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;睡&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>(Animal):
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bark</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;汪汪叫&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>XiaoTianQuan</span>(Dog):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fly</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;飞&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bark</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 在当前方法中去调用父类方法</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 使用super方法</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;叫的和神一样....&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e># super() 也是一个对象</span>
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>bark()
</span></span><span style=display:flex><span>        <span style=color:#75715e># 当前的子类方法进行扩展</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;这是一个测试...&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wangwang <span style=color:#f92672>=</span> XiaoTianQuan()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wangwang<span style=color:#f92672>.</span>bark() 
</span></span><span style=display:flex><span><span style=color:#75715e># 叫的和神一样....</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 汪汪叫</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 这是一个测试...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>XiaoTianQuan类不仅要调用自身的bark方法，也要调用它所继承父类（Dog）的bark方法。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>使用super().方法 来实现
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span></code></pre></div><p>调用父类方法的另外一种方式</p><p>在 <code>python2.x</code> 中，如果需要调用父类的方法，还可以使用以下方式：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>父类名<span style=color:#f92672>.</span>方法(self)
</span></span></code></pre></div><p>这种方式，目前在<code>python 3.x</code>还支持这种方式</p><p>这种方式 <strong>不推荐使用</strong>，因为一旦 <strong>父类发生变化</strong>，方法调用位置的 <strong>类名</strong> 同样需要修改</p><h4 id=提示>提示</h4><p>在开发中，<code>父类名</code>和<code>super()</code>两种方式不要混用</p><p>如果使用 <strong>当前子类名</strong> 调用方法，会形成递归调用，<strong>出现死循环</strong>。</p><h3 id=父类的-私有属性-和私有方法>父类的 私有属性 和私有方法</h3><p>1.<strong>子类对象 不能</strong>在自己的方法内部，<strong>直接</strong>访问父类的 <strong>私有属性</strong>或<strong>私有方法</strong></p><p>2.<strong>子类对象</strong> 可以通过 <strong>父类</strong>的<strong>公有方法</strong>间接访问到 <strong>私有属性或私有方法</strong></p><p>私有属性、方法是对象的隐私，不对外公开，<strong>外界</strong>以及<strong>子类</strong>都不能直接访问。</p><p>示例</p><p><strong>代码理解父类的私有属性和私有方法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 创建类属性</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 公共属性</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>num_1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 私有属性</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__num_2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 创建私有方法</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__test</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;私有属性与公共属性的值：</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>num_1<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>__num_2<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>(A):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>demo</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 父类方法</span>
</span></span><span style=display:flex><span>        super()<span style=color:#f92672>.</span>__test()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>B 具有父类的所有属性和方法
</span></span></span><span style=display:flex><span><span style=color:#e6db74>如果是私有属性和私有方法的情况下 不可以直接去使用。
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> B()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 使用子类去打印父类的公共属性</span>
</span></span><span style=display:flex><span>print(b<span style=color:#f92672>.</span>num_1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 打印父类中的私有属性 我们不可以直接打印弗莱的私有属性</span>
</span></span><span style=display:flex><span>print(b<span style=color:#f92672>.</span>__num_2) <span style=color:#75715e># AttributeError: &#39;B&#39; object has no attribute &#39;__num_2&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 调用父类中的私有方法 不允许子类直接去调用父类的私有方法</span>
</span></span><span style=display:flex><span>b<span style=color:#f92672>.</span>demo() <span style=color:#75715e># AttributeError: &#39;super&#39; object has no attribute &#39;_B__test&#39;</span>
</span></span></code></pre></div><p>子类访问父类的私有属性和私有方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>num_1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>100</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__num_2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>200</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 创建私有方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__test</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;私有属性与公共属性的值：</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>num_1<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>__num_2<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 创建公有方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;父类中的公共方法输出私有属性: </span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>__num_2<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e># 在公有方法中调用私有方法</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__test()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>(A):
</span></span><span style=display:flex><span>    <span style=color:#75715e># 公有方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>demo</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 1. 在子类方法中访问父类的公共属性</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;子类方法输出父类中的公有属性:</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>num_1<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#75715e># 2. 在子类中调用父类的公有方法输出私有属性</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>test()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> B()
</span></span><span style=display:flex><span>b<span style=color:#f92672>.</span>demo()
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>子类方法输出父类中的公有属性:100
</span></span></span><span style=display:flex><span><span style=color:#e6db74>父类中的公共方法输出私有属性: 200
</span></span></span><span style=display:flex><span><span style=color:#e6db74>私有属性与公共属性的值：100, 200
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span></code></pre></div><h3 id=多继承>多继承</h3><h4 id=概念>概念</h4><p>子类 可以拥有 多个父类，并且具有 所有父类的属性 和方法</p><p>例如： 孩子 会继承自己 父亲和母亲的特性</p><p><strong>语法</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>子类名</span>(父类名1, 父类名2<span style=color:#f92672>...</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span></code></pre></div><p>举例</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>test</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;test 方法&#34;</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>demo</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;demo 方法&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span>(A, B):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建C类对象</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> C()
</span></span><span style=display:flex><span>c<span style=color:#f92672>.</span>test()
</span></span><span style=display:flex><span>c<span style=color:#f92672>.</span>demo()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>在python中 面向对象是支持多个类进行继承的
</span></span></span><span style=display:flex><span><span style=color:#e6db74>子类同时具有父类中的所有方法和所有属性
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span></code></pre></div><h3 id=多继承的使用注意事项>多继承的使用注意事项</h3><p>如果 不同的父类 中存在 同名的方法，子类对象 在调用方法时，会调用 哪一个父类中的方法呢？</p><p>提示：开发时，应该尽量避免这种容易产生混淆的情况！ —— 如果 父类之间存在同名的属性或者方法，应该尽量避免使用多继承。</p><h3 id=python-中的mro方法搜索顺序>python 中的MRO——方法搜索顺序</h3><p>python中针对 类 提供了一个 内置属性 <code>__mro__</code>可以查看 方法 搜索顺序</p><p>MOR是 <code>method resolution order</code>,主要用于 在多继承时判断方法、属性的调用路径</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(C<span style=color:#f92672>.</span>__mro__)
</span></span></code></pre></div><p>输出结果</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>(<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#960050;background-color:#1e0010>&#39;</span><span style=color:#a6e22e>__main__</span><span style=color:#f92672>.</span>C<span style=color:#e6db74>&#39;&gt;, &lt;class &#39;</span>__main__<span style=color:#f92672>.</span>A<span style=color:#e6db74>&#39;&gt;, &lt;class &#39;</span>__main__<span style=color:#f92672>.</span><span style=color:#e6db74>B</span><span style=color:#e6db74>&#39;&gt;, &lt;class &#39;</span>object<span style=color:#e6db74>&#39;&gt;)</span>
</span></span></code></pre></div><p>在搜索方法时，是按照<code>__mro__</code>的输出结果 <strong>从左到右</strong>的顺序查找的</p><p>如果在当前类中<strong>找到方法，就直接执行，不再搜索。</strong></p><p>如果 <strong>没有找到，就查找下一个类</strong> 中是否有对应的方法，如果找到，就直接执行，不再搜索。</p><p>如果找到最后一个类，还没有找到方法，程序报错。</p><h3 id=新式类和旧式类经典类>新式类和旧式类（经典类）</h3><p><code>object</code>是python为所有对象提供的 <strong>基类</strong>，提供有一些内置的属性和方法，可以使用<code>dir</code>函数查看。</p><p>新式类： 以<code>object</code>为基类，推荐使用</p><p>经典类： 不以<code>object</code>为基类，不推荐使用</p><p>在<code>python 3.x</code>中定义类时，如果没有指定父类，会默认使用<code>object</code>作为该类的 基类——<code>python3.x</code>中定义的类都是 新式类</p><p>在<code>python 2.x</code>中定义类时，如果没有指定父类，不会以<code>object</code>作为基类。</p><p>新式类 和 经典类 在多继承时—会影响到方法的搜索顺序</p><p>为了保证编写的代码能够同时在<code>Python2.x</code>和<code>Python3.x</code>运行！今后在定义类时，如果没有父类，建议统一继承自<code>object</code>。</p><p><strong>在python3中如果不指定继承关系那么默认继承object。</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dir(A)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>[<span style=color:#e6db74>&#39;__class__&#39;</span>, <span style=color:#e6db74>&#39;__delattr__&#39;</span>, <span style=color:#e6db74>&#39;__dict__&#39;</span>, <span style=color:#e6db74>&#39;__dir__&#39;</span>, <span style=color:#e6db74>&#39;__doc__&#39;</span>, <span style=color:#e6db74>&#39;__eq__&#39;</span>, <span style=color:#e6db74>&#39;__format__&#39;</span>, <span style=color:#e6db74>&#39;__ge__&#39;</span>, <span style=color:#e6db74>&#39;__getattribute__&#39;</span>, <span style=color:#e6db74>&#39;__gt__&#39;</span>, <span style=color:#e6db74>&#39;__hash__&#39;</span>, <span style=color:#e6db74>&#39;__init__&#39;</span>, <span style=color:#e6db74>&#39;__init_subclass__&#39;</span>, <span style=color:#e6db74>&#39;__le__&#39;</span>, <span style=color:#e6db74>&#39;__lt__&#39;</span>, <span style=color:#e6db74>&#39;__module__&#39;</span>, <span style=color:#e6db74>&#39;__ne__&#39;</span>, <span style=color:#e6db74>&#39;__new__&#39;</span>, <span style=color:#e6db74>&#39;__reduce__&#39;</span>, <span style=color:#e6db74>&#39;__reduce_ex__&#39;</span>, <span style=color:#e6db74>&#39;__repr__&#39;</span>, <span style=color:#e6db74>&#39;__setattr__&#39;</span>, <span style=color:#e6db74>&#39;__sizeof__&#39;</span>, <span style=color:#e6db74>&#39;__str__&#39;</span>, <span style=color:#e6db74>&#39;__subclasshook__&#39;</span>, <span style=color:#e6db74>&#39;__weakref__&#39;</span>]
</span></span></code></pre></div><h2 id=可见性和属性的装饰器>可见性和属性的装饰器</h2><p>对象的方法通常是公开（public）的，因为公开的方法是对象能够接收的消息，也是对象暴露给外界的调用接口。可以用<code>__name</code>表示一个私有属性，<code>_name</code>表示一个受保护属性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 设置两个私有属性 name 和 age</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self,name, age):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>study</span>(self, course_name):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>正在学习</span><span style=color:#e6db74>{</span>course_name<span style=color:#e6db74>}</span><span style=color:#e6db74>.&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>play</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>正在玩游戏.&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># 类实例化， __init__函数中定义了2个参数，这里要传入两个参数。</span>
</span></span><span style=display:flex><span>stu1 <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#34;john&#34;</span>, <span style=color:#ae81ff>18</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 尝试调用私有属性 name。抛出异常。</span>
</span></span><span style=display:flex><span>stu1<span style=color:#f92672>.</span>study(<span style=color:#e6db74>&#34;python&#34;</span>) <span style=color:#75715e># AttributeError: &#39;Student&#39; object has no attribute &#39;__name&#39;</span>
</span></span></code></pre></div><p>由此可见，以<code>__</code>开头的属性<code>__name</code>是私有的，在类的外面无法直接访问，但是在类里面的<code>study</code>方法中可以通过<code>self.__name</code>访问该属性。</p><p>那么有没有方法在类的外面也能访问私有属性呢？</p><p>可以，需要更换名字规则。<code>对象._类名__方法名</code>这种形式来读取私有属性。或者使用下面的装饰器来实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>stu1 <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#34;john&#34;</span>, <span style=color:#ae81ff>18</span>)
</span></span><span style=display:flex><span>print(stu1<span style=color:#f92672>.</span>_Student__name, stu1<span style=color:#f92672>.</span>_Student__age) <span style=color:#75715e># john 18 </span>
</span></span></code></pre></div><h3 id=装饰器>装饰器</h3><p>python中可以通过<code>property</code>装饰器为“私有”属性提供读取和修改的方法。装饰器通常会放在类、函数或方法的声明之前，通过一个<code>@</code>符号表示将装饰器应用于类、函数或方法。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self,name, age):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>    <span style=color:#75715e># 私有属性读取（getter方法）- 获取__name属性</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>name</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>__name
</span></span><span style=display:flex><span>    <span style=color:#75715e># 私有属性修改器（setter方法）- 修改__name属性</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@name.setter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>name</span>(self, name):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 如果name 参数不为空就赋值给对象的__name属性</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># 否则将__name属性赋值为&#39;无名氏&#39;,有两种写法</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># self.__name = name if name else &#39;无名氏&#39;</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>__name <span style=color:#f92672>=</span> name <span style=color:#f92672>or</span> <span style=color:#e6db74>&#39;无名氏&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 获取私有属性</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@property</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>age</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>__age
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>study</span>(self, course_name):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>正在学习</span><span style=color:#e6db74>{</span>course_name<span style=color:#e6db74>}</span><span style=color:#e6db74>.&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>play</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>self<span style=color:#f92672>.</span>name<span style=color:#e6db74>}</span><span style=color:#e6db74>正在玩游戏.&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stu1 <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;smith&#39;</span>, <span style=color:#ae81ff>20</span>)
</span></span><span style=display:flex><span>print(stu1<span style=color:#f92672>.</span>age, stu1<span style=color:#f92672>.</span>name) <span style=color:#75715e># 20 smith</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 修改私有属性name的值，设置为空会触发私有属性修改器@name.setter。</span>
</span></span><span style=display:flex><span>stu1<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span>
</span></span><span style=display:flex><span>print(stu1<span style=color:#f92672>.</span>name) <span style=color:#75715e># 无名氏</span>
</span></span></code></pre></div><h2 id=动态属性>动态属性</h2><p>在python中，我们可以动态为对象添加属性。python是动态类型语言。</p><p>对象的方法本质上也是对象的属性，如果给对象发送一个无法接收的信息，引发的异常仍然是<code>AttributeError</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, age):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>stu <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;john&#39;</span>, <span style=color:#ae81ff>18</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># 想要在不修改当前类的代码的情况下，去添加一个sex属性</span>
</span></span><span style=display:flex><span>stu<span style=color:#f92672>.</span>sex <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;女&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print(stu<span style=color:#f92672>.</span>name, stu<span style=color:#f92672>.</span>age, stu<span style=color:#f92672>.</span>sex) <span style=color:#75715e># john 18 女</span>
</span></span></code></pre></div><p>如果不希望再使用对象时动态的为对象添加属性，可以使用python的<code>__slots__</code>魔法方法。对于<code>Student</code>类来说，可以在类中指定<code>__slots__ = ('name', 'age')</code>，这样<code>Student</code>类的对象只能有name 和 age 属性。如果想动态添加其他属性会引发异常。</p><p>注意添加位置，要在<code>__init__</code>方法之前添加。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Student</span>:
</span></span><span style=display:flex><span>    __slots__ <span style=color:#f92672>=</span> (<span style=color:#e6db74>&#34;name&#34;</span>, <span style=color:#e6db74>&#34;age&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name, age):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>age <span style=color:#f92672>=</span> age
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>stu <span style=color:#f92672>=</span> Student(<span style=color:#e6db74>&#39;john&#39;</span>, <span style=color:#ae81ff>18</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># 想要在不修改当前类的代码的情况下，去添加一个属性</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>stu<span style=color:#f92672>.</span>sex <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;女&#34;</span>
</span></span><span style=display:flex><span>print(stu<span style=color:#f92672>.</span>name, stu<span style=color:#f92672>.</span>age, stu<span style=color:#f92672>.</span>sex) <span style=color:#75715e># AttributeError: &#39;Student&#39; object has no attribute &#39;sex&#39;</span>
</span></span></code></pre></div><h2 id=静态方法和类方法>静态方法和类方法</h2><p>在类中定义的方法都是对象方法，这些方法都是对象可以接收消息。</p><p>静态方法和类方法是发送给类对象的消息。</p><p>举例：</p><p>定义一个三角形类，通过传入三条边的长度来构造三角形，并提供计算周长和面积的方法。计算周长和面积肯定是三角形对象的方法，这一点毫无疑问。但是在创建三角形对象时，传入的三条边长未必能构造出三角形，为此我们可以先写一个方法来验证给定的三条边长是否可以构成三角形，这种方法很显然就不是对象方法，因为在调用这个方法时三角形对象还没有创建出来。我们可以把这类方法设计为静态方法或类方法，也就是说这类方法不是发送给三角形对象的消息，而是发送给三角形类的消息，代码如下所示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Triangle</span>(object):
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;三角形类&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, a, b, c):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;初始化方法&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>a <span style=color:#f92672>=</span> a
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>b <span style=color:#f92672>=</span> b
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>c <span style=color:#f92672>=</span> c
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@staticmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_valid</span>(a,b,c):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;判断三条边长能否构成三角形（静态方法）&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>&gt;</span> c <span style=color:#f92672>and</span> b <span style=color:#f92672>+</span> c <span style=color:#f92672>&gt;</span> b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># @classmethod</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># def is_valid(cls, a, b, c):</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#     &#34;&#34;&#34;判断三条边长能否构成三角形（类方法）&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>#     return  a + b &gt; c and b + c &gt; b</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>perimeter</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;计算周长&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self<span style=color:#f92672>.</span>a <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>a <span style=color:#f92672>+</span> self<span style=color:#f92672>.</span>c
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>area</span>(self):
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;&#34;&#34;计算面积&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>perimeter() <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> (p <span style=color:#f92672>*</span> (p <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>a) <span style=color:#f92672>*</span> (p <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>b) <span style=color:#f92672>*</span> (p <span style=color:#f92672>-</span> self<span style=color:#f92672>.</span>c)) <span style=color:#f92672>**</span> <span style=color:#ae81ff>0.5</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 正常调用，需要先进行类的实例化。</span>
</span></span><span style=display:flex><span>triangle <span style=color:#f92672>=</span> Triangle(<span style=color:#ae81ff>10</span> ,<span style=color:#ae81ff>20</span> ,<span style=color:#ae81ff>30</span>)
</span></span><span style=display:flex><span>print(triangle<span style=color:#f92672>.</span>perimeter()) <span style=color:#75715e># 50</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 调用静态方法中定义的属性，不需要对当前类进行实例化，可以直接调用。类方法也一样。</span>
</span></span><span style=display:flex><span>print(Triangle<span style=color:#f92672>.</span>is_valid(<span style=color:#ae81ff>10</span>,<span style=color:#ae81ff>20</span>,<span style=color:#ae81ff>30</span>)) <span style=color:#75715e># False</span>
</span></span></code></pre></div><h3 id=小结-1>小结</h3><p>在调用静态方法时，不需要对当前类进行实例化，可以直接使用<code>类名.方法</code>。</p><p>静态方法和类方法的区别</p><p>1.静态方法传入的参数都是普通参数</p><p>2.类方法的参数第一位必须是cls</p><p>class简写，代表当前的方法是属于当前的类</p><p>静态方法是不和当前类进行绑定的，可以看成一个单独的函数。</p><h2 id=多态>多态</h2><p>面向对象三大特性</p><p>1.<strong>封装</strong> 根据 <strong>职责</strong> 将<strong>属性</strong> 和 <strong>方法</strong> 封装到一个抽象的<strong>类</strong>中</p><p>定义类的准则</p><p>2.<strong>继承 实现代码的重用</strong>，相同的代码不需要重复的编写</p><p>设计类的技巧</p><p>子类针对自己特有的需求，编写特有的代码</p><p>3.<strong>多态</strong> 不同的<strong>子类对象</strong> 调用相同的<strong>父类方法</strong>，产生不同的执行结果</p><p><strong>多态</strong> 可以 <strong>增加代码的灵活度</strong></p><p>以 <strong>继承</strong> 和 <strong>重写父类方法</strong> 为前提</p><p>是调用方法的技巧，不会影响到内部设计.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>A</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>work</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;人类需要工作&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 程序员</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>B</span>(A):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>work</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;程序员在工作--代码&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 设计师</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>C</span>(A):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>work</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;设计师在工作--图纸&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>b <span style=color:#f92672>=</span> B()
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> C()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>c<span style=color:#f92672>.</span>work()
</span></span><span style=display:flex><span>b<span style=color:#f92672>.</span>work()
</span></span></code></pre></div><h3 id=多态案例演练>多态案例演练</h3><p><strong>需求</strong></p><p>1.在<code>Dog</code>类中封装方法<code>game</code></p><p>普通狗只是简单的玩耍</p><p>2.定义<code>XiaoTianDog</code>继承自<code>Dog</code>，并且重写<code>game</code>方法</p><p>哮天犬需要在天上玩耍</p><p>3.定义<code>Person</code>类，并且封装一个 和狗玩 的方法</p><p>在方法内部，直接让狗对象 调用 <code>game</code>方法</p><p><strong>案例小结</strong></p><p><code>Person</code>类中只需要让 狗对象 调用<code>game</code>方法，而不关心具体是什么狗</p><p><code>game</code>方法是在<code>Dog</code>父类中定义的</p><p>在程序执行时，传入不同的 狗对象 实参，就会产生不同的执行效果</p><p>多态更容易编写出通用的代码，做出通用的编程，以适应需求的不断变化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Dog</span>:
</span></span><span style=display:flex><span>    <span style=color:#75715e># 定义类属性</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e># 方法</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>game</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> 在蹦蹦跳跳的玩耍...&#39;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>XiaoTianDog</span>(Dog):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># 当前的哮天犬和普通的狗不一样</span>
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    子类继承父类的时候 具有父类的所有属性和方法
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    &#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>game</span>(self):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> 飞到天上去玩耍...&#39;</span> <span style=color:#f92672>%</span> self<span style=color:#f92672>.</span>name)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Person</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> __init__(self, name):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>name  <span style=color:#f92672>=</span> name
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>game_with_dog</span>(self, dog):
</span></span><span style=display:flex><span>        <span style=color:#75715e># 让狗玩耍</span>
</span></span><span style=display:flex><span>        dog<span style=color:#f92672>.</span>game()
</span></span><span style=display:flex><span>        <span style=color:#75715e># 让狗与人一起玩耍</span>
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%s</span><span style=color:#e6db74> 和 </span><span style=color:#e6db74>%s</span><span style=color:#e6db74> 快乐的玩耍...&#39;</span> <span style=color:#f92672>%</span> (self<span style=color:#f92672>.</span>name, dog<span style=color:#f92672>.</span>name))    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 创建一个普通狗对象</span>
</span></span><span style=display:flex><span><span style=color:#75715e># wangcai = Dog(&#39;旺财&#39;)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>wangcai <span style=color:#f92672>=</span> XiaoTianDog(<span style=color:#e6db74>&#39;旺财&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#75715e># 创建一个人的对象</span>
</span></span><span style=display:flex><span>xiaoming <span style=color:#f92672>=</span> Person(<span style=color:#e6db74>&#39;小明&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>xiaoming<span style=color:#f92672>.</span>game_with_dog(wangcai)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>旺财 在蹦蹦跳跳的玩耍...
</span></span></span><span style=display:flex><span><span style=color:#e6db74>小明 和 旺财 快乐的玩耍...
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>旺财 飞到天上去玩耍...
</span></span></span><span style=display:flex><span><span style=color:#e6db74>小明 和 旺财 快乐的玩耍...
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>多态的运行情况
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    我们在调用子类中的同名方法时 输出的值不一样
</span></span></span><span style=display:flex><span><span style=color:#e6db74>
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    继承和重写的
</span></span></span><span style=display:flex><span><span style=color:#e6db74>&#34;&#34;&#34;</span>
</span></span></code></pre></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2022-07-03</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://blog.haipengv.com/posts/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ data-title=python回炉重造-面向对象编程入门><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Facebook" data-sharer=facebook data-url=https://blog.haipengv.com/posts/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/><i class="fab fa-facebook-square fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Hacker News" data-sharer=hackernews data-url=https://blog.haipengv.com/posts/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ data-title=python回炉重造-面向对象编程入门><i class="fab fa-hacker-news fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); title="Share on Line" data-sharer=line data-url=https://blog.haipengv.com/posts/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ data-title=python回炉重造-面向对象编程入门><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@6.20.0/icons/line.svg aria-hidden=true></i></a><a href=javascript:void(0); title="Share on 微博" data-sharer=weibo data-url=https://blog.haipengv.com/posts/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/ data-title=python回炉重造-面向对象编程入门><i class="fab fa-weibo fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/ class=prev rel=prev title=http和https各种方法测试><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>http和https各种方法测试</a>
<a href=/posts/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/ class=next rel=next title=python回炉重造-集合>python回炉重造-集合<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.115.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>