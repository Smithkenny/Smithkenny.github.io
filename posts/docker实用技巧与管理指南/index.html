<!doctype html><html lang=zh-CN><head><meta name=viewport content="width=device-width,initial-scale=1"><meta charset=utf-8><meta name=description content="Docker实用技巧与管理指南 - https://www.haipengv.com/posts/docker%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E7%AE%A1%E7%90%86%E6%8C%87%E5%8D%97/"><meta name=author content="Smith - https://www.haipengv.com/"><meta name=msvalidate.01 content="B46311949B856F2A7015F366FB3CE878"><title>Docker实用技巧与管理指南</title><base target=_self><link rel=icon type=image/png href=/favicon.ico><link rel=stylesheet href=https://www.haipengv.com/style.min.9a0cea23154ac1941e15c25aa2d31b77285a217d2606ec05b55236428cf1c3e6.css><script>const DARK=!1</script><script type=text/javascript src=/main.js defer></script></head><body class=active-animate><div class=cool-before></div><div id=header><div class=container-header><div class=right><h1 class=title>Docker实用技巧与管理指南</h1><div id=toc>📜</div></div></div></div><div id=content><div class="container-main container-page"><div class=rel><div class=curtag-desc><a href=https://www.haipengv.com/tags/docker/><img src=/imgs/icons/tag.svg width=16> 相关文章：Docker <sup>24</sup></a></div><div class=curtag-post><div class=curtag-post-item><a href=https://www.haipengv.com/posts/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/>Centos7.3离线安装docker</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/centos7%E9%85%8D%E7%BD%AEdocker/>Centos7配置docker</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker-compose%E6%90%AD%E5%BB%BAmysql8/>Docker Compose搭建mysql8</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/>Dockerfile指令详解</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker%E5%86%B7%E9%97%A8%E6%8A%80%E5%B7%A7/>Docker冷门技巧</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/>Docker创建专有网卡</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker%E5%88%9B%E5%BB%BA%E5%AE%B9%E5%99%A8rm%E5%8F%82%E6%95%B0%E4%BD%BF%E7%94%A8/>Docker创建容器rm参数使用</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker%E5%9F%BA%E7%A1%80/>Docker基础</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker%E5%AE%89%E8%A3%85jupyter/>Docker安装jupyter</a></div><div class="curtag-post-item curtag-post-item--active"><a href=https://www.haipengv.com/posts/docker%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%E4%B8%8E%E7%AE%A1%E7%90%86%E6%8C%87%E5%8D%97/>Docker实用技巧与管理指南</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%9101/>Docker应用开发01</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%9102/>Docker应用开发02</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%9103/>Docker应用开发03</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/>Docker配置tab补全命令</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/docker%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F/>Docker镜像加速</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/ghcr%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E6%96%B9%E5%BC%8F/>GHCR镜像加速方式</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/>Harbor使用自签名证书实现https登录</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/>Harbor安装与简单使用</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/ubuntu20.04%E5%AE%89%E8%A3%85docker/>Ubuntu20.04安装docker</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/%E4%B8%8D%E5%90%8C%E6%9E%B6%E6%9E%84%E5%B9%B3%E5%8F%B0%E4%B8%8Bdocker%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E5%8C%85%E6%9F%A5%E6%89%BE%E8%AF%B4%E6%98%8E/>不同架构平台下Docker官方镜像包查找说明</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/%E4%BD%BF%E7%94%A8dockerfile%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/>使用Dockerfile创建镜像</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/>使用docker搭建openvpn</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/%E8%87%AA%E5%BB%BA%E4%BB%93%E5%BA%93registry%E4%BD%BF%E7%94%A8%E8%AF%81%E4%B9%A6%E8%AE%A4%E8%AF%81%E6%96%B9%E6%B3%95/>自建仓库registry使用证书认证方法</a></div><div class=curtag-post-item><a href=https://www.haipengv.com/posts/%E8%87%AA%E5%BB%BA%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93-registry/>自建本地镜像仓库Registry</a></div></div></div><div class=desc><span><svg t="1656736000388" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="7409" width="12" height="12"><path d="M524.885333 338.986667l-324.522666 324.48c-17.28 15.274667-27.989333 36.693333-29.696 56.234666v133.76l130.730666.085334c22.784-1.621333 43.989333-12.245333 61.013334-31.701334L685.098667 499.2 524.885333 338.986667zM585.258667 278.656l160.170666 160.213333 102.144-102.144a19.712 19.712.0 000-27.861333l-132.48-132.437333a19.456 19.456.0 00-27.605333.0L585.258667 278.613333zM701.312 85.333333c27.946667.0 54.741333 11.136 74.282667 30.848L907.904 248.490667a105.045333 105.045333.0 010 148.565333L424.874667 879.957333C395.050667 914.304 352.768 935.424 304.426667 938.752H85.333333v-42.666667l.128-179.84c3.626667-44.970667 24.576-86.826667 56.448-114.944l485.12-485.034666a104.789333 104.789333.0 0174.24-30.933334z" p-id="7410" fill="#adb5bd"/></svg>2025-03-19&nbsp;&nbsp;&nbsp;<svg t="1656737270708" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="23838" width="11" height="11"><path d="M824.264 95.36c0-23.859 25.043-44.16 48.902-44.16s49.714 20.301 49.714 44.16v190.08c0 23.859-19.054 52.868-42.913 52.868h-190.08c-23.859.0-46.696-25.96-46.696-49.819s22.55-46.249 46.409-46.249h82.025C702.344 175.534 610.22 155.853 512 155.853c-206.775.0-360.398 149.372-360.398 356.147S305.225 870.23 512 870.23c206.775.0 357.467-151.455 357.467-358.23.0-23.859 23.634-50.706 53.413-50.706 29.78.0 49.92 26.847 49.92 50.706.0 254.493-206.307 460.8-460.8 460.8s-460.8-206.307-460.8-460.8C51.2 257.507 257.507 51.2 512 51.2c122.4.0 226.684 33.296 312.264 117.369.358.351.358-24.052.0-73.209z" p-id="23839" fill="#adb5bd"/></svg>
2025-03-19&nbsp;&nbsp;&nbsp;</span>
<span><svg t="1656737548689" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="33866" width="12" height="12"><path d="M832.038608 64.662657H192.030028c-70.774903.0-128.089859 57.325793-128.089859 128.03206v446.793671c0 70.7171050000001 57.314956 128.154884 128.089859 128.154884h133.353183a63.940169 63.940169.0 0155.219742 31.576328l76.099638 129.83828c12.358154 21.093031 33.790754 31.626903 55.216129 31.626903s42.832688-10.544709 55.198067-31.619678l76.222461-129.870792a63.940169 63.940169.0 0155.212517-31.551041h133.54103c70.576219.0 127.732228-57.289669 127.732227-127.800865V192.391272c0-70.536482-57.181295-127.728615-127.786414-127.728615zM895.884854 639.842407A63.85347 63.85347.0 01832.092795 703.703103h-133.54103a127.753903 127.753903.0 00-110.349172 63.09847l-76.222461 129.856342a.274545.274545.0 010-.050574h-.032512s-.021675.061411-.032512.061412l-76.1466-129.85273a127.804477 127.804477.0 00-110.385297-63.11292H192.030028A64.207489 64.207489.0 01127.880338 639.488388V192.694717a64.102729 64.102729.0 0164.14969-64.091891h640.00858a63.799284 63.799284.0 0163.846246 63.788446v447.451135z" fill="#adb5bd" p-id="33867"/><path d="M608.154093 288.092004a31.970084 31.970084.0 00-31.970084 31.970085v160.078006L441.53396 300.861976a31.970084 31.970084.0 00-57.531702 19.200113v255.760676a31.970084 31.970084.0 0063.940169.0V415.863969l134.650048 179.274507a31.970084 31.970084.0 0057.531703-19.200113V320.062089a31.970084 31.970084.0 00-31.970085-31.970085z" fill="#adb5bd" p-id="33868"/></svg>3199 字</span>&nbsp;
<span><svg t="1656737462334" class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" p-id="32892" width="12" height="12"><path d="M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667zm0 810.666666C307.2 885.333333 138.666667 716.8 138.666667 512S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z" p-id="32893" fill="#adb5bd"/><path d="M695.466667 567.466667 544 497.066667V277.333333c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v238.933334c0 12.8 6.4 23.466667 19.2 29.866666L669.866667 627.2c4.266667 2.133333 8.533333 2.133333 12.8 2.133333 12.8.0 23.466667-6.4 29.866666-19.2 6.4-14.933333.0-34.133333-17.066666-42.666666z" p-id="32894" fill="#adb5bd"/></svg>7 分钟</span><div class=container-ctgtag><div class=taxonomy><div class=tag><a href=/tags/docker>Docker</a></div></div></div></div><div class=toc><div class=container-page-operation><div class=page-operation><div><a href=/><img src=/imgs/icons/home-2.svg alt></a></div><div><a href=/nav><img src=/imgs/icons/iov-navigate-1.svg alt></a></div><div><a href=/wiki><img src=/imgs/icons/wiki.svg alt></a></div><div><a href=/tags><img src=/imgs/icons/treetags.svg alt></a></div><div id=light-dark><a><img src=/imgs/icons/moon2.svg alt></a></div><div><a href=#><img src=/imgs/icons/up2.svg alt></a></div></div></div><nav id=TableOfContents><ul><li><ul><li><a href=#一docker-容器的健康检查>一、Docker 容器的健康检查</a></li><li><a href=#二docker-数据卷的使用>二、Docker 数据卷的使用</a></li><li><a href=#三清理-docker-的无用资源>三、清理 Docker 的无用资源</a></li><li><a href=#四docker中的特殊镜像>四、Docker中的特殊镜像</a></li><li><a href=#五删除已退出的容器>五、删除已退出的容器</a></li><li><a href=#六灵活映射容器端口>六、灵活映射容器端口</a></li><li><a href=#七以特殊格式显示镜像>七、以特殊格式显示镜像</a></li><li><a href=#八释放空标签镜像>八、释放空标签镜像</a></li><li><a href=#九理解镜像构建上下文>九、理解镜像构建上下文</a></li></ul></li></ul></nav></div><div class=content><h3 id=一docker-容器的健康检查>一、Docker 容器的健康检查</h3><p>在 Docker 中，容器的运行状态不仅仅是“启动”或“停止”那么简单。通过健康检查（Health Check），我们可以更精确地了解容器内部应用程序的实际运行状况。Docker 提供了 HEALTHCHECK 指令，让用户可以在 Dockerfile 中定义如何检查容器的健康状态。
例如，一个简单的健康检查配置可能是这样的：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:navy>        healthcheck</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:navy>            interval</span>:<span style=color:#bbb> </span>30s<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:navy>            retries</span>:<span style=color:#bbb> </span><span style=color:#099>5</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:navy>            start_period</span>:<span style=color:#bbb> </span>30s<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:navy>            test</span>:<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>                - CMD<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>                - curl<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>                - -f<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>                - http://localhost:8090/actuator/health/readiness<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:navy>            timeout</span>:<span style=color:#bbb> </span>5s<span style=color:#bbb>
</span></span></span></code></pre></td></tr></table></div></div><p>30s检测一次，超时5s，若失败重试5次。
健康状态可以通过 docker ps 查看，显示为 (healthy)、(unhealthy) 或 (starting)。如果需要更详细的信息，可以使用 docker inspect 查看健康检查的输出结果。这种主动监控方式不仅提高了系统的可靠性，还能帮助我们在问题发生时及时采取措施。</p><h3 id=二docker-数据卷的使用>二、Docker 数据卷的使用</h3><p>Docker 容器的一个显著特点是其短暂性——容器停止后，内部数据可能会丢失。为了解决这个问题，Docker 提供了数据卷（Volume）和绑定挂载（Bind Mount）两种方式来持久化数据。
数据卷是 Docker 推荐的方式，因为它由 Docker 管理，独立于容器的生命周期。创建数据卷只需使用以下命令：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker volume create my-volume
</span></span></code></pre></td></tr></table></div></div><p>然后在运行容器时通过 -v 参数挂载：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -v my-volume:/app/data my-image
</span></span></code></pre></td></tr></table></div></div><p>这样，容器中的 /app/data 目录就会与数据卷关联，即使容器被删除，数据依然保留在卷中。
相比之下，绑定挂载直接将宿主机的目录映射到容器内，例如：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker run -v /host/path:/app/data my-image
</span></span></code></pre></td></tr></table></div></div><p>或者</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#000;font-weight:700>[</span>root@k3s-storage volume-ubuntu<span style=color:#000;font-weight:700>]</span><span style=color:#998;font-style:italic># docker run -itd --name test-ubuntu1 -v $(pwd):/usr/sbin ubuntu:latest bash </span>
</span></span><span style=display:flex><span>651c856a202e52fa66f316f60568c9c0fd844bc02efbd137e3b45974cad7a1df
</span></span></code></pre></td></tr></table></div></div><p>这种方式更直观，适合开发环境，但需要注意权限问题，比如SELinux环境下的额外配置。
通过合理使用数据卷和绑定挂载，我们可以确保数据的持久性，同时在开发、测试和生产环境中灵活切换。</p><h3 id=三清理-docker-的无用资源>三、清理 Docker 的无用资源</h3><p>随着Docker的使用，系统中可能会积累大量无用资源，比如停止的容器、未使用的镜像和网络。这些资源占用磁盘空间，影响系统性能，因此定期清理非常必要。
Docker提供了一些便捷的命令来完成清理工作。例如，要删除所有停止的容器，可以运行：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker container prune
</span></span></code></pre></td></tr></table></div></div><p>如果想清理未被使用的镜像，可以使用：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker image prune
</span></span></code></pre></td></tr></table></div></div><p>而清理无用的网络则可以用：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker network prune
</span></span></code></pre></td></tr></table></div></div><p>如果想一次性清理所有未使用的资源（包括容器、镜像、网络和构建缓存），只需一条命令：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker system prune
</span></span></code></pre></td></tr></table></div></div><p>需要注意的是，prune命令会删除所有未被引用的资源，因此在执行前最好确认没有重要的临时数据会被误删。通过这些清理操作，我们可以保持 Docker 环境的整洁，避免资源浪费。</p><h3 id=四docker中的特殊镜像>四、Docker中的特殊镜像</h3><p>在Docker的使用过程中，我们可能会遇到一些特殊的镜像，比如none镜像和scratch镜像，它们各有其独特的作用。
none镜像通常出现在镜像构建或更新时。当我们构建一个新镜像并覆盖已有标签时，旧的镜像会失去标签，变成 none状态。这些镜像虽然没有名称，但仍然占用空间，可以通过docker image prune 清理。
另一方面，scratch是一个极简的基础镜像，它完全为空，主要用于构建自定义镜像。例如，一个简单的 Dockerfile可以这样使用：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#000;font-weight:700>FROM</span><span style=color:#d14> scratch</span><span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#000;font-weight:700>COPY</span> hello /<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span><span style=display:flex><span><span style=color:#a61717;background-color:#e3d2d2></span><span style=color:#000;font-weight:700>CMD</span> [<span style=color:#d14>&#34;/hello&#34;</span>]<span style=color:#a61717;background-color:#e3d2d2>
</span></span></span></code></pre></td></tr></table></div></div><p>这种镜像适用于需要极致轻量化的场景，比如静态编译的二进制程序。不过，由于scratch不包含任何基础工具，调试和管理会更具挑战性。
理解这些特殊镜像的用途，可以帮助我们更好地管理镜像仓库，并在特定场景下优化容器部署。</p><h3 id=五删除已退出的容器>五、删除已退出的容器</h3><p>在使用Docker的过程中，经常会产生大量的已退出容器。这些容器虽然不再运行，但仍然占用系统资源。如果不及时清理，可能会导致磁盘空间不足或系统性能下降。以下是几种删除已退出容器的实用方法：</p><ol><li>手动删除单个容器<br>使用 docker ps -a 查看所有容器（包括已退出的），找到目标容器的 ID 或名称，然后通过以下命令删除：</li></ol><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker rm &lt;容器ID或名称&gt;
</span></span></code></pre></td></tr></table></div></div><p>例如：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>docker rm 1e2f3g4h
</span></span></code></pre></td></tr></table></div></div><p>2.批量删除所有已退出容器<br>当已退出容器数量较多时，手动逐一删除效率低下。可以通过以下命令一次性清理所有状态为 exited 的容器：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker rm $(docker ps -a -f status=exited -q)
</span></span></code></pre></td></tr></table></div></div><p>其中，-f status=exited 过滤出已退出状态的容器，-q 只返回容器 ID，结合 docker rm 实现批量删除。
3.自动清理容器<br>如果希望在容器运行结束后自动删除，可以在启动容器时加上 &ndash;rm 参数。例如：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker run --rm -it ubuntu bash
</span></span></code></pre></td></tr></table></div></div><p>容器退出后会自动被移除，无需手动清理。
注意事项：</p><ul><li>在删除容器前，确保已退出且不再需要，因为删除后无法恢复容器数据。</li><li>如果容器仍在运行，需先用 docker stop &lt;容器ID> 停止，再执行删除。</li></ul><h3 id=六灵活映射容器端口>六、灵活映射容器端口</h3><p>Docker 容器运行时，通常需要与宿主机或其他服务进行网络通信，而端口映射是实现这一目标的关键手段。Docker 提供了多种端口映射方式，以下是常见方法及其使用场景：</p><ol><li>随机映射端口<br>使用 -P 参数，Docker 会自动将容器内暴露的端口映射到宿主机的随机端口。例如：<div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker run -d -P nginx
</span></span></code></pre></td></tr></table></div></div>运行后，可通过 docker ps 查看映射结果，如 0.0.0.0:32768->80/tcp，表示容器内 80 端口被映射到宿主机的 32768 端口。</li><li>指定端口映射<br>使用 -p 参数，可以精确指定宿主机和容器之间的端口映射，格式为 -p 宿主机端口:容器端口。例如：<div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker run -d -p 8080:80 nginx
</span></span></code></pre></td></tr></table></div></div>这将容器内的 80 端口映射到宿主机的 8080 端口。</li><li>绑定特定 IP 的端口<br>如果宿主机有多个网络接口，可以指定 IP 地址进行映射，格式为 -p IP:宿主机端口:容器端口。例如：<div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker run -d -p 192.168.1.10:8080:80 nginx
</span></span></code></pre></td></tr></table></div></div>这样，只有通过 192.168.1.10:8080 才能访问容器服务。
实用技巧：</li></ol><ul><li>使用 docker port &lt;容器ID> 查看容器当前的端口映射情况。</li><li>如果端口被占用，可通过 netstat -tuln | grep &lt;端口号> 检查并释放。</li><li>在生产环境中，建议明确指定端口，避免随机映射带来的不确定性。</li></ul><h3 id=七以特殊格式显示镜像>七、以特殊格式显示镜像</h3><p>Docker 镜像管理中，查看镜像信息是日常操作之一。默认的 docker images 命令虽然简单，但输出格式有限。以下是如何以特殊格式显示镜像的技巧：</p><ol><li><p>基础用法<br>运行 docker images，输出包括镜像名称（REPOSITORY）、标签（TAG）、镜像 ID（IMAGE ID）、创建时间（CREATED）和大小（SIZE）。</p></li><li><p>自定义输出格式<br>使用 &ndash;format 参数结合 Go 模板语法，可以定制输出内容。例如：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker images --format &#34;{{.Repository}}:{{.Tag}} {{.Size}}&#34;
</span></span></code></pre></td></tr></table></div></div><p>输出示例：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>nginx:latest 133MB
</span></span><span style=display:flex><span>ubuntu:20.04 72.8MB
</span></span></code></pre></td></tr></table></div></div></li><li><p>过滤特定镜像<br>配合 &ndash;filter 参数，可以筛选出符合条件的镜像。例如，只显示带有 nginx 的镜像：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker images --filter &#34;reference=nginx&#34; --format &#34;{{.Repository}} {{.Size}}&#34;
</span></span></code></pre></td></tr></table></div></div></li><li><p>去除重复项<br>如果镜像存在多个标签，默认显示所有条目。加上 &ndash;no-trunc 和 &ndash;quiet 可优化输出。例如：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker images -q | sort | uniq
</span></span></code></pre></td></tr></table></div></div><p>这将列出唯一的镜像 ID，去除重复。</p></li></ol><p>应用场景：</p><ul><li><p>在脚本中处理镜像信息时，自定义格式更便于解析。</p></li><li><p>检查镜像占用空间时，结合大小字段快速定位大镜像。</p></li></ul><h3 id=八释放空标签镜像>八、释放空标签镜像</h3><p>Docker使用过程中，可能会产生none标签的镜像（即空标签镜像），通常由更新或重新构建镜像时遗留。这些镜像占用磁盘空间，需定期清理：</p><ol><li><p>查看空标签镜像<br>使用以下命令列出所有none镜像：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker images -f &#34;dangling=true&#34;
</span></span></code></pre></td></tr></table></div></div></li><li><p>删除空标签镜像<br>清理这些镜像的命令是：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker rmi $(docker images -f &#34;dangling=true&#34; -q)
</span></span></code></pre></td></tr></table></div></div><p>-q 只返回镜像 ID，结合 docker rmi 删除。</p></li><li><p>预防空标签镜像</p><ul><li><p>构建镜像时，始终指定明确的标签，例如：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker build -t myapp:1.0 .
</span></span></code></pre></td></tr></table></div></div></li><li><p>更新镜像后，及时删除旧版本，避免产生无用镜像。</p></li></ul></li></ol><p>注意事项：</p><ul><li><p>如果空标签镜像正在被容器使用，需先删除相关容器。</p></li><li><p>定期运行 docker system prune 可清理无用的镜像、容器和网络。</p></li></ul><h3 id=九理解镜像构建上下文>九、理解镜像构建上下文</h3><p>构建 Docker 镜像时，docker build 命令需要一个构建上下文（Build Context），理解其作用对优化构建过程至关重要。</p><ol><li><p>什么是构建上下文<br>构建上下文是 docker build 命令中指定的路径，默认是当前目录（.）。Docker 会将该路径下的所有文件和子目录打包上传到 Docker 守护进程，用于构建镜像。例如：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker build -t myapp:latest .
</span></span></code></pre></td></tr></table></div></div></li><li><p>优化构建上下文</p><ul><li><p>排除无关文件：构建上下文包含不必要的文件（如日志、临时文件）会增加传输时间。使用 .dockerignore 文件排除无关内容，类似 .gitignore。示例 .dockerignore：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>*.log
</span></span><span style=display:flex><span>node_modules
</span></span><span style=display:flex><span>.git
</span></span></code></pre></td></tr></table></div></div></li><li><p>指定特定上下文：如果 Dockerfile 不在当前目录，可通过 -f 参数指定文件路径，同时提供上下文路径。例如：</p><div class=highlight><div style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>docker build -f ./docker/Dockerfile -t myapp:latest ./src
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p>构建上下文的影响</p><ul><li><p>上下文过大可能导致构建变慢，尤其在远程守护进程上。</p></li><li><p>合理规划上下文目录结构，可以提升构建效率并减少错误。</p></li></ul></li></ol><p>实用建议：</p><ul><li><p>始终检查上下文目录，确保只包含构建所需文件。</p></li><li><p>在 CI/CD 管道中，优化 .dockerignore 以缩短构建时间。</p></li></ul></div></div></div><div id=footer><div class=container-footer><div class=beian><a target=_blank href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode="></a><a href target=_blank><span class=some>icp...<span></a></div><div class=info><a href=https://github.com/loveminimal/hugo-theme-virgo>🕊️</a> 2021 - <span id=info-date></span></div></div></div><div class=cool-after></div></body></html>