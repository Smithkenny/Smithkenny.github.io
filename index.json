[{"categories":["编程"],"content":"如何区分对象是否有返回值？ ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:1:0","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"1.有返回值 需要指定返回值类型，方法执行完毕后用return 将结果返回给调用者。 # 类型double public double area(){ return height * weight } ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:1:1","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"2.无返回值 用void 定义。不需要返回结果。 特点：定义的方法中没有return 语句或者return 语句后没有表达式。 # 类型：void public void info(String name){ System.out.println(name); } 在决定是否定义一个具有返回值的方法时，可以考虑以下几个因素： 没有返回值的方法只能执行一个固定的功能。 有返回值的方法还可以将有用的数据作为返回值供其他地方使用。 如何选用：如果只是完成一个功能，就直接用没有返回值的方法，否则用有返回值的方法。 需要返回结果：如果你需要从方法中获取某种计算结果或数据，那么就需要定义一个具有返回值的方法。返回值可以是基本类型（如int、double等）或引用类型（如对象、数组等）。 方法执行的目的：如果方法的主要目的是执行一些操作或修改对象的状态，而不需要返回结果，那么可以定义一个无返回值的方法（返回类型为void）。 ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:1:2","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"方法重载的理解 Java允许在一个类中定义多个名称相同的方法，但是参数的类型或个数必须不同，这就是方法的重载。 特点： 方法名一定相同 参数类型或者参数个数一定不同 一定在同一个类中 举例： 参数个数不同：如method(int x)与method(int x,int y)不同。 参数类型不同：如method(int x)与method(double x)不同。 参数顺序不同：如method(int x,double y)与method(double x,int y)不同。 重载只与方法名与参数类型相关与返回值无关 如void method(int x)与int method(int y)不是方法重载，不能同时存在。 重载与具体的变量标识符无关 如method(int x)与method(int y)不是方法重载，不能同时存在。 ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:2:0","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"面向对象完成具体功能的操作的三步流程（非常重要） 创建类，并设计类的内部成员（属性、方法） 创建类的对象。比如：Phone p1 = new Phone(); 通过对象，调用其内部声明的属性或方法，完成相关的功能。 ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:3:0","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"类的成员之一： 属性 ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:4:0","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"变量的分类： 角度一：按照数据类型来分：基本数据类型（8种）、引用数据类型（数组、类、接口、枚举、注解、记录） 角度二：按照变量在类中声明的位置不同：成员变量（或属性）、局部变量（方法内、方法形参、构造器内、构造器外） ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:4:1","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"属性的几个称谓： 成员变量、属性、field（字段、域） ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:4:2","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"区分成员变量 vs 局部变量 相同点： 变量声明格式相同： 数据类型 变量名 = 变量值 变量都有其有效的作用域。出了作用域，就失效了。 变量必须先声明，后赋值，再使用。 不同点 类中声明位置不同： 属性：声明类内，方法外的变量 局部变量： 声明方法、构造器内部的变量 在内存中分配的位置不同（难） 属性：随着对象的创建，存储在堆空间中 局部变量：存储在栈空间中 生命周期： 属性：随着对象的创建而创建，随着对象的消亡而消亡。 局部变量：随着方法对应的栈帧入栈，局部变量会在栈中分配；随着方法对应的栈帧出栈，局部变量消亡。 作用域: 属性： 在整个类的内部都是有效的 局部变量：仅限于声明此变量所在的方法（或构造器、代码块）中 是否有权限修饰符进行修饰： 都有哪些权限修饰符：public 、protected、缺省、private（用于表明所修饰的结构可调用的范围的大小） 属性：是可以使用权限修饰符的。而局部变量，不能进行任何权限修饰符进行修饰。 例子1： public class MyMethod { // 属性（成员变量） String name; // public String name; 可以使用权限修饰符修饰 int age; public void eat(){ System.out.println(\"正在吃饭...\"); } public String play(String name){ int age1 = 20; // 局部变量（只可方法内使用） // public int age1; // 错误。局部变量不能任何权限修饰符修饰。 return name; } } 是否有默认值（重点）： 属性： 都有默认初始化值 意味着，如果没有给属性进行显式初始化赋值，则会有默认初始化值。 局部变量：都没有默认初始化值 意味着，在使用局部变量之前，必须要显式赋值，否则报错。 注意：对于方法的形参而言，在调用方法时，给形参赋值即可。 例子1中方法、属性的调用 public class MymethodTest { public static void main(String[] args) { MyMethod myMethod = new MyMethod(); System.out.println(myMethod.age); System.out.println(myMethod.play(\"篮球\")); } } # 结果 0 篮球 ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:4:3","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"类成员之二： 方法（method） ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:5:0","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"使用方法的好处 方法的理解： 方法 是类或对象行为特征的抽象，用来完成某个功能操作。 方法的好处：实现代码重用，减少冗余，简化代码。 ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:5:1","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"使用举例 Math.random()的 random方法 Math.sqrt(x)的sqrt(x)方法 System.out.println(x)的println(x)方法 new Scanner(System.in).nextInt()的nextInt()方法 Arrays类中的binarySearch()方法、sort()方法、equals()方法 ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:5:2","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"声明举例 public void eat() public void sleep(int hour) public String interests(String hobby) public int getAge() ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:5:3","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["编程"],"content":"方法声明的格式（重要） 权限修饰符 [其他修饰符] 返回值类型 方法名(形参列表) [throws 异常类型] { // 方法头 // 方法体 } 权限修饰符 Java中规定了那些权限修饰符呢？ 有四种： private、缺省、protected、public 返回值类型：描述当调用完此方法时，是否需要返回一个结果。 分类： 无返回值类型：使用void表示即可。比如System.out.println(x) 的println(x) 方法、Arrays的sort()方法。 有具体的返回值类型：需要指明返回的数据的类型。可以是基本数据类型，也可以引用数据类型。 需要在方法内部配合使用“return + 返回值类型的变量或常量” 比如：Math.random() 、new Scanner(System.in).netxInt()等 【经验】我们在声明方法时，要不要提供返回值类型呢？ 根据方法具体实现的功能来决定。换句话说，具体问题具体分析 根据题目要求 ","date":"2023-10-26","objectID":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/:5:4","tags":["java"],"title":"Java知识点理解","uri":"/java%E7%9F%A5%E8%AF%86%E7%82%B9%E7%90%86%E8%A7%A3/"},{"categories":["linux"],"content":"1.根据行数切割 如下以一个372M大小的日志文件做切割演示，每一个文件按照50000行做切割，指定文件名为split-line，-d参数以数字的方式显示。 #源文件大小 [root@localhost /tmpdisk/test]$ ls -lh 总用量 372M -rw-------. 1 root root 372M 10月 26 09:08 messages #按行切割 [root@localhost /tmpdisk/test]$ split -l 50000 -d --verbose messages split-line #查看大小 [root@localhost /tmpdisk/test]$ ls -lh 总用量 743M -rw-------. 1 root root 372M 10月 26 09:08 messages -rw-r--r--. 1 root root 4.5M 10月 26 09:21 split-line00 -rw-r--r--. 1 root root 4.2M 10月 26 09:21 split-line01 -rw-r--r--. 1 root root 7.7M 10月 26 09:22 split-line02 -rw-r--r--. 1 root root 4.2M 10月 26 09:22 split-line03 -rw-r--r--. 1 root root 4.2M 10月 26 09:22 split-line04 -rw-r--r--. 1 root root 4.2M 10月 26 09:22 split-line05 -rw-r--r--. 1 root root 4.2M 10月 26 09:22 split-line06 -rw-r--r--. 1 root root 4.2M 10月 26 09:22 split-line07 -rw-r--r--. 1 root root 4.2M 10月 26 09:22 split-line08 -rw-r--r--. 1 root root 4.2M 10月 26 09:22 split-line09 -rw-r--r--. 1 root root 4.3M 10月 26 09:22 split-line10 ","date":"2023-10-26","objectID":"/linux%E6%97%A5%E5%BF%97%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2/:1:0","tags":["linux"],"title":"Linux日志大文件切割","uri":"/linux%E6%97%A5%E5%BF%97%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2/"},{"categories":["linux"],"content":"2.根据大小切割 除了按照行数切割之外，split还支持通过文件大小进行切割，通过指定-b参数指定文件大小进行切割，文件大小单位支持K, M, G, T, P, E, Z，如下以切割为50M演示文件切割过程。 [root@localhost /tmpdisk/test]$ split -b 50M -d --verbose messages split-size 正在创建文件\"split-size00\" 正在创建文件\"split-size01\" 正在创建文件\"split-size02\" 正在创建文件\"split-size03\" 正在创建文件\"split-size04\" 正在创建文件\"split-size05\" 正在创建文件\"split-size06\" 正在创建文件\"split-size07\" [root@localhost /tmpdisk/test]$ ls -lh 总用量 743M -rw-------. 1 root root 372M 10月 26 09:08 messages -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size00 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size01 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size02 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size03 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size04 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size05 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size06 -rw-r--r--. 1 root root 22M 10月 26 09:25 split-size07 ","date":"2023-10-26","objectID":"/linux%E6%97%A5%E5%BF%97%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2/:2:0","tags":["linux"],"title":"Linux日志大文件切割","uri":"/linux%E6%97%A5%E5%BF%97%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2/"},{"categories":["linux"],"content":"3.多文件合并 split是用户将大文件切割为多个小文件，如果需要将多个小文件合并为一个文件怎么处理呢？可以使用文件重定向方式实现，如下演示两个小文件合并为一个文件。 [root@localhost /tmpdisk/test]$ cat split-size00 split-size01 \u003e messages1 [root@localhost /tmpdisk/test]$ ls messages messages1 split-size00 split-size01 split-size02 split-size03 split-size04 split-size05 split-size06 split-size07 [root@localhost /tmpdisk/test]$ ls -lh 总用量 843M -rw-------. 1 root root 372M 10月 26 09:08 messages -rw-r--r--. 1 root root 100M 10月 26 09:27 messages1 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size00 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size01 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size02 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size03 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size04 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size05 -rw-r--r--. 1 root root 50M 10月 26 09:25 split-size06 -rw-r--r--. 1 root root 22M 10月 26 09:25 split-size07 合并方式通过读取文件的方式+输出重定向，对于大文件一样会存在性能的问题，建议根据需要使用。 ","date":"2023-10-26","objectID":"/linux%E6%97%A5%E5%BF%97%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2/:3:0","tags":["linux"],"title":"Linux日志大文件切割","uri":"/linux%E6%97%A5%E5%BF%97%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2/"},{"categories":["linux"],"content":"4.多文件同一关键字筛选 [root@localhost /tmpdisk/test]$ grep faild split-size* split-size01:2023-09-07T10:54:01.447068+08:00 localhost jman[691]: init mysql default password faild split-size01:2023-10-07T13:27:47.356650+08:00 localhost jman[695]: init mysql default password faild [参考](微信公众平台 (qq.com) ) ","date":"2023-10-26","objectID":"/linux%E6%97%A5%E5%BF%97%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2/:4:0","tags":["linux"],"title":"Linux日志大文件切割","uri":"/linux%E6%97%A5%E5%BF%97%E5%A4%A7%E6%96%87%E4%BB%B6%E5%88%87%E5%89%B2/"},{"categories":["数据库"],"content":"GP调整的参数如下： (1)全局死锁检测开关 在Greenplum 6中其默认关闭，需要打开它才可以支持并发更新/删除操作； gpconfig -c gp_enable_global_deadlock_detector -v on (2) 禁用GPORCA优化器（据说GPDB6默认的优化器为：GPORCA） gpconfig -c optimizer -v off (3)关闭日志 此GUC减少不必要的日志，避免日志输出对I/O性能的干扰。 gpconfig -c log_statement -v none 注意：参数配置修改后，我使用gpstop -u重新加载配置，并用gpconfig -s检查了各个参数确为修改成功 注意：如果命令无法使用可以在postgresql.conf配置文件中追加参数,并使用gpstop -u重新加载配置。 optimizer=off gp_enable_global_deadlock_detector=on log_statement=none 登录库： [gpadmin@mdw gpseg-1]$ psql -Ugpadmin -d postgres psql (12.12) Type \"help\" for help. postgres=# \\d List of relations Schema | Name | Type | Owner | Storage --------+------------------------+----------+---------+--------- public | company | table | gpadmin | heap public | customer | table | gpadmin | heap public | customer_id_sequenct | sequence | gpadmin | public | demo01 | table | gpadmin | heap public | demo01_demo01_id_seq | sequence | gpadmin | public | demo02 | table | gpadmin | heap public | demo02_id_seq | sequence | gpadmin | public | jtsec_db_change_01 | table | gpadmin | heap public | jtsec_db_change_02 | table | gpadmin | heap public | jtsec_db_change_046 | table | gpadmin | heap public | jtsec_dep_sequence_01 | sequence | gpadmin | public | jtsec_dep_sequence_02 | sequence | gpadmin | public | jtsec_dep_sequence_046 | sequence | gpadmin | public | product | table | gpadmin | heap public | product_code_seq | sequence | gpadmin | (15 rows) postgres=# show log_statement; log_statement --------------- none (1 row) postgres=# \\q 参考 ","date":"2023-10-12","objectID":"/greenplumdb7%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/:0:0","tags":["greenplum7"],"title":"Greenplumdb7数据入库速度优化","uri":"/greenplumdb7%E6%95%B0%E6%8D%AE%E5%85%A5%E5%BA%93%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/"},{"categories":["数据库"],"content":"一、安装环境 提前安装任意版本docker 宿主机系统环境：centos7.7 ","date":"2023-10-11","objectID":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/:1:0","tags":["greenplum7"],"title":"Greenplum-Db7容器方式安装","uri":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/"},{"categories":["数据库"],"content":"二、docker安装 安装过程 ","date":"2023-10-11","objectID":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/:2:0","tags":["greenplum7"],"title":"Greenplum-Db7容器方式安装","uri":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/"},{"categories":["数据库"],"content":"三、安装脚本 build.sh Dockerfile entrypoint.sh install.sh test.sh build.sh脚本内容： #!/bin/bash ############################################ # Function : Docker镜像制作脚本 # Author : tang # Date : 2021-07-04 # # Usage: sh build.sh # ############################################ docker build -t inrgihc/greenplum:7.0.0 . Dockerfile脚本内容： FROM rockylinux:9.2 # Greenplum的数据存放目录 ENV DATADIR=/data # 文件准备 COPY install.sh /tmp/install.sh COPY entrypoint.sh /entrypoint.sh # 配置Aliyun的仓库(以安装libcgroup) RUN yum install -y wget \u0026\u0026 wget -O /etc/yum.repos.d/Aliyun-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo # 执行安装 RUN yum -y install passwd openssl openssh-server openssh-clients \u0026\u0026\\ mkdir /var/run/sshd/ \u0026\u0026 sed -i 's?#HostKey?HostKey?' /etc/ssh/sshd_config \u0026\u0026 \\ ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N '' \u0026\u0026 \\ echo -e '#!/bin/bash\\n/usr/sbin/sshd -D \u0026' \u003e /var/run/sshd/sshd_start.sh \u0026\u0026 \\ chmod u+x /var/run/sshd/sshd_start.sh RUN /var/run/sshd/sshd_start.sh \u0026\u0026 \\ sleep 10s \u0026\u0026 cd /tmp \u0026\u0026 sh /tmp/install.sh \u0026\u0026 \\ rm -rf /tmp/install.sh \u0026\u0026 rm -rf /tmp/files # 暴露端口 EXPOSE 5432 22 USER root CMD [ \"sh\" , \"/entrypoint.sh\"] entrypoint.sh 脚本内容： #!/bin/bash ############################################ # Function : EntryPoint入口 # Author : tang # Date : 2020-12-09 # # Usage: sh entrypoint.sh # ############################################ # 启动ssh服务 /var/run/sshd/sshd_start.sh \u0026\u0026 sleep 5s # 设置gpadmin账号的环境变量 su - gpadmin -l -c \"echo -e 'source /usr/local/greenplum-db/greenplum_path.sh' \u003e\u003e ~/.bashrc\" su - gpadmin -l -c \"echo -e 'export COORDINATOR_DATA_DIRECTORY=$DATADIR/coordinator/gpseg-1/' \u003e\u003e ~/.bashrc\" su - gpadmin -l -c \"echo -e 'export PGPORT=5432' \u003e\u003e ~/.bashrc\" su - gpadmin -l -c \"echo -e 'export PGUSER=gpadmin' \u003e\u003e ~/.bashrc\" su - gpadmin -l -c \"echo -e 'export PGDATABASE=postgres' \u003e\u003e ~/.bashrc\" if [ \"`ls -A $DATADIR`\" = \"\" ]; then # 创建数据库存放目录 mkdir -p $DATADIR/coordinator mkdir -p $DATADIR/primary chown -R gpadmin:gpadmin $DATADIR # 启动数据库集群 su - gpadmin -l -c \"source ~/.bashrc;gpinitsystem -a -D -c /home/gpadmin/gpinitsystem_config_singlenode -h /home/gpadmin/gp_hosts_list\" sleep 10s RET=`netstat -tuln | grep 5432 | wc -l` echo \"!!!!!!Check server start:$RET\" su - gpadmin -l -c \"source ~/.bashrc;psql -d postgres -U gpadmin -f /home/gpadmin/initdb_gpdb.sql\" su - gpadmin -l -c \"source ~/.bashrc;gpconfig -c log_statement -v none\" su - gpadmin -l -c \"source ~/.bashrc;gpconfig -c gp_enable_global_deadlock_detector -v on\" su - gpadmin -l -c \"echo \\\"host all all 0.0.0.0/0 password\\\" \u003e\u003e $DATADIR/coordinator/gpseg-1/pg_hba.conf\" su - gpadmin -l -c \"source ~/.bashrc \u0026\u0026 sleep 5s \u0026\u0026 gpstop -u \u0026\u0026 tail -f gpAdminLogs/*.log\" else su - gpadmin -l -c \"source ~/.bashrc \u0026\u0026 gpstart -a \u0026\u0026 tail -f gpAdminLogs/*.log\" fi install.sh脚本内容： #!/bin/bash ############################################ # Function : Greenplum单机一键安装脚本 # Author : tang # Date : 2020-12-09 # # Usage: sh install.sh # ############################################ # GPDB的RPM包版本 GPDBVER=7.0.0 # 账号密码 PASSWORD=greenplum # 日志等级 ERROR_MSG=\"[ERROR] \" INFO_MSG=\"[INFO] \" # 日志函数 function log() { TIME=$(date +\"%Y-%m-%d %H:%M:%S\") echo \"$TIME $1\" } # 利用yum安装依赖包函数 function package_install() { log \"$INFO_MSG check command package : [ $1 ]\" if ! rpm -qa | grep -q \"^$1\"; then yum install -y $1 package_check_ok else log \"$INFO_MSG command [ $1 ] already installed.\" fi } # 检查命令是否执行成功 function package_check_ok() { ret=$? if [ $ret != 0 ]; then log \"$ERROR_MSG Install failed, error code is $ret, Check the error log.\" exit 1 fi } function gpdb_install(){ log \"$INFO_MSG Start to install greenplum for single node.\" # 安装依赖包 package=(wget iputils net-tools) for p in ${package[@]}; do package_install $p done # 安装readline(pgsql依赖) yum install -y readline-devel ln -s /usr/lib64/libreadline.so.8.1 /lib64/libreadline.so.7 # 配置ping命令执行权限 chmod u+s /bin/ping # 创建用户与用户组 /usr/sbin/groupadd gpadmin /usr/sbin/useradd gpadmin -g gpadmin usermod -G gpadmin gpadmin echo \"${PASSWORD}\" | passwd --stdin gpadmin # ssh配置 sed -i 's/#PermitRoo","date":"2023-10-11","objectID":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/:3:0","tags":["greenplum7"],"title":"Greenplum-Db7容器方式安装","uri":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/"},{"categories":["数据库"],"content":"四、部署过程 ","date":"2023-10-11","objectID":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/:4:0","tags":["greenplum7"],"title":"Greenplum-Db7容器方式安装","uri":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/"},{"categories":["数据库"],"content":"1.镜像制作 mkdir -p /tmpdisk/greendb7 cd /tmpdisk/greendb7 sh build.sh ","date":"2023-10-11","objectID":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/:4:1","tags":["greenplum7"],"title":"Greenplum-Db7容器方式安装","uri":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/"},{"categories":["数据库"],"content":"2.镜像测试 cd /tmpdisk/greendb7 sh test.sh ","date":"2023-10-11","objectID":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/:4:2","tags":["greenplum7"],"title":"Greenplum-Db7容器方式安装","uri":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/"},{"categories":["数据库"],"content":"3.使用 mkdir /tmpdisk/greendb7-data/gpdb docker run -d --name greenplum -p 15432:5432 -v /tmpdisk/greendb7-data/gpdb:/data inrgihc/greenplum:7.0.0 ","date":"2023-10-11","objectID":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/:4:3","tags":["greenplum7"],"title":"Greenplum-Db7容器方式安装","uri":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/"},{"categories":["数据库"],"content":"4.参数解释 说明：首次启动镜像时会初始化集群，需要耐心等待10~60秒左右，然后方可用客户端连接数据库。 参数名称 取值 备注说明 软件安装路径 /usr/local/greenplum-db greenplum程序软件安装所在目录，目前无法定制配置 数据所在路径 /data greenplum数据库数据安装所在目录, 该参数可在打包时定制配置 Greenplum超管账号 gpadmin 登录Greenplum数据库的超级管理员账号为gpadmin Greenplum超管密码 greenplum 登录Greenplum数据库的超级管理员gpadmin的密码 数据库连接端口 5432 greenplum数据库master的连接端口号 参考：链接 ","date":"2023-10-11","objectID":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/:4:4","tags":["greenplum7"],"title":"Greenplum-Db7容器方式安装","uri":"/greenplum-db7%E5%AE%B9%E5%99%A8%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85/"},{"categories":["数据库"],"content":"一、安装环境 系统：Rocky8.8 数据库版本：greenplum-db7.0.0-beta5 注意：greenplum数据库只能用普通用户运行，不可用root管理员直接运行！！！！ ","date":"2023-09-08","objectID":"/greenplum-db7%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/:1:0","tags":["greenplum7"],"title":"Greenplum Db7单节点安装说明","uri":"/greenplum-db7%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/"},{"categories":["数据库"],"content":"二、安装过程 1.Rocky8.8 系统更新 yum update -y 2.关闭防火墙 sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config systemctl stop firewalld systemctl disable firewalld setenforce 0 reboot 3.安装依赖 yum install -y gcc gcc-c++ make readline-devel zlib-devel flex bison python-devel openssl-devel pam-devel 推荐将官方 依赖也安装上. Rhel-Rocky.bash install needed packages. Please add to this list if you discover additional prerequisites sudo yum group install -y \"Development Tools\" INSTALL_PKGS=\"apr-devel bison bzip2-devel cmake3 epel-release flex gcc gcc-c++ krb5-devel libcurl-devel libevent-devel libkadm5 libxml2-devel libzstd-devel openssl-devel python39 python39-devel python39-psutil python3-pip perl-ExtUtils-MakeMaker.noarch perl-ExtUtils-Embed.noarch readline-devel rsync xerces-c-devel zlib-devel python3-psutil python3-pyyaml\" for i in $INSTALL_PKGS; do sudo yum install -y $i done sudo yum install -y postgresql sudo yum install -y postgresql-devel sudo yum install -y python3-psycopg2 pip3.9 install -r python-dependencies.txt #Remove the python3 softlink because on Rocky8 its pointing to python3.6 by default. We need python3.9 for gpdb7. sudo rm -rf /usr/bin/python3 sudo ln -s /usr/bin/python3.9 /usr/bin/python3 #For all Greenplum Database host systems running RHEL, CentOs or Rocky8, SELinux must either be Disabled or configured to allow unconfined access to Greenplum processes, directories, and the gpadmin user. setenforce 0 sudo tee -a /etc/selinux/config \u003c\u003c EOF SELINUX=disabled EOF #To prevent SELinux-related SSH authentication denials that could occur even with SELinux deactivated sudo tee -a /etc/sssd/sssd.conf \u003c\u003c EOF selinux_provider=none EOF sudo systemctl stop firewalld.service #Configure kernel settings so the system is optimized for Greenplum Database. sudo tee -a /etc/sysctl.d/10-gpdb.conf \u003c\u003c EOF kernel.msgmax = 65536 kernel.msgmnb = 65536 kernel.msgmni = 2048 kernel.sem = 500 2048000 200 8192 kernel.shmmni = 1024 kernel.core_uses_pid = 1 kernel.core_pattern=/var/core/core.%h.%t kernel.sysrq = 1 net.core.netdev_max_backlog = 2000 net.core.rmem_max = 4194304 net.core.wmem_max = 4194304 net.core.rmem_default = 4194304 net.core.wmem_default = 4194304 net.ipv4.tcp_rmem = 4096 4224000 16777216 net.ipv4.tcp_wmem = 4096 4224000 16777216 net.core.optmem_max = 4194304 net.core.somaxconn = 10000 net.ipv4.ip_forward = 0 net.ipv4.tcp_congestion_control = cubic net.ipv4.tcp_tw_recycle = 0 net.core.default_qdisc = fq_codel net.ipv4.tcp_mtu_probing = 0 net.ipv4.conf.all.arp_filter = 1 net.ipv4.conf.default.accept_source_route = 0 net.ipv4.ip_local_port_range = 10000 65535 net.ipv4.tcp_max_syn_backlog = 4096 net.ipv4.tcp_syncookies = 1 net.ipv4.ipfrag_high_thresh = 41943040 net.ipv4.ipfrag_low_thresh = 31457280 net.ipv4.ipfrag_time = 60 net.ipv4.ip_local_reserved_ports=65330 vm.overcommit_memory = 2 vm.overcommit_ratio = 95 vm.swappiness = 10 vm.dirty_expire_centisecs = 500 vm.dirty_writeback_centisecs = 100 vm.zone_reclaim_mode = 0 EOF RAM_IN_KB=`cat /proc/meminfo | grep MemTotal | awk '{print $2}'` RAM_IN_BYTES=$(($RAM_IN_KB*1024)) echo \"vm.min_free_kbytes = $(($RAM_IN_BYTES*3/100/1024))\" | sudo tee -a /etc/sysctl.d/10-gpdb.conf \u003e /dev/null echo \"kernel.shmall = $(($RAM_IN_BYTES/2/4096))\" | sudo tee -a /etc/sysctl.d/10-gpdb.conf \u003e /dev/null echo \"kernel.shmmax = $(($RAM_IN_BYTES/2))\" | sudo tee -a /etc/sysctl.d/10-gpdb.conf \u003e /dev/null if [ $RAM_IN_BYTES -le $((64*1024*1024*1024)) ]; then echo \"vm.dirty_background_ratio = 3\" | sudo tee -a /etc/sysctl.d/10-gpdb.conf \u003e /dev/null echo \"vm.dirty_ratio = 10\" | sudo tee -a /etc/sysctl.d/10-gpdb.conf \u003e /dev/null else echo \"vm.dirty_background_ratio = 0\" | sudo tee -a /etc/sysctl.d/10-gpdb.conf \u003e /dev/null echo \"vm.dirty_ratio = 0\" | sudo tee -a /etc/sysctl.d/10-gpdb.conf \u003e /dev/null echo \"vm.dirty_background_bytes = 1610612736 # 1.5GB\" | sudo tee -a /etc/sysctl.d/10-gpdb.conf \u003e /dev/null echo \"vm.dirty_bytes = 4294967296 # 4GB\" | sudo tee -a /etc/sysctl.d/10-gpdb.conf \u003e /dev/null fi sudo sysctl -p sudo t","date":"2023-09-08","objectID":"/greenplum-db7%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/:2:0","tags":["greenplum7"],"title":"Greenplum Db7单节点安装说明","uri":"/greenplum-db7%E5%8D%95%E8%8A%82%E7%82%B9%E5%AE%89%E8%A3%85%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"一、证书 Ubuntu server 20.04.3 给apache2创建自签名证书 介绍 TLS（传输层安全）及其前身SSL是用于将正常流量包装在受保护的加密包装器中的协议。使用这项技术，服务器可以安全地向其客户端发送信息，而不会被外界拦截或读取其消息。 注意：自签名证书将加密您的服务器和任何客户端之间的通信。但是，由于它不是由 Web 浏览器和操作系统中包含的任何受信任的证书颁发机构签署的，因此用户无法使用该证书来自动验证您的服务器的身份。因此，您的用户在访问您的网站时会看到安全错误。 由于此限制，自签名证书不适用于为公众服务的生产环境。它们通常用于测试或保护单个用户或一小群用户使用的非关键服务，这些用户可以通过备用通信渠道建立对证书有效性的信任。如需更适合生产的证书解决方案，请查看Let’s Encrypt ，一个免费的证书颁发机构。 先决条件 使用非root 用户、启用 sudo 的用户访问 Ubuntu 20.04 服务器。我们的Ubuntu 20.04 初始服务器设置 指南可以向您展示如何创建此帐户。 您还需要安装 Apache。 sudo apt update 然后，安装apache2软件包： sudo apt install apache2 最后，如果您ufw设置了防火墙，请打开http和https端口： sudo ufw allow \"Apache Full\" 步骤1：启用mod_ssl 在我们可以使用任何SSL 证书之前，我们首先必须启用mod_sslApache 模块，它提供对 SSL 加密的支持。 mod_ssl使用以下a2enmod命令启用： sudo a2enmod ssl 重启Apache激活模块： sudo systemctl restart apache2 该mod_ssl模块现已启用并可以使用。 步骤2：创建ssl证书 现在 Apache 已准备好使用加密，我们可以继续生成新的 SSL 证书。该证书将存储有关您站点的一些基本信息，并附带一个允许服务器安全处理加密数据的密钥文件。 我们可以使用以下openssl命令创建 SSL 密钥和证书文件： sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/apache-selfsigned.key -out /etc/ssl/certs/apache-selfsigned.crt 参数详解： openssl：这是用于创建和管理 OpenSSL 证书、密钥和其他文件的命令行工具。 req -x509：这指定我们要使用 X.509 证书签名请求 (CSR) 管理。X.509 是 SSL 和 TLS 遵守的用于密钥和证书管理的公钥基础结构标准。 -nodes：这告诉 OpenSSL 跳过使用密码保护我们的证书的选项。当服务器启动时，我们需要 Apache 能够在没有用户干预的情况下读取文件。密码可以防止这种情况发生，因为我们必须在每次重新启动后输入它。 -days 365：此选项设置证书被视为有效的时间长度。我们在这里设置了一年。许多现代浏览器会拒绝任何有效期超过一年的证书。 -newkey rsa:2048：这指定我们要同时生成新证书和新密钥。我们没有在上一步中创建签署证书所需的密钥，因此我们需要将其与证书一起创建。该rsa:2048部分告诉它制作一个 2048 位长的 RSA 密钥。 -keyout：这一行告诉 OpenSSL 在哪里放置我们正在创建的生成的私钥文件。 -out：这告诉 OpenSSL 在哪里放置我们正在创建的证书。 最重要的一行是请求Common Name. 您需要输入用于访问服务器的主机名或服务器的公共 IP。重要的是，此字段与您将放入浏览器地址栏中以访问该站点的任何内容相匹配，因为不匹配会导致更多的安全错误。 完整的提示列表如下所示： Country Name (2 letter code) [XX]:US State or Province Name (full name) []:Example Locality Name (eg, city) [Default City]:Example Organization Name (eg, company) [Default Company Ltd]:Example Inc Organizational Unit Name (eg, section) []:Example Dept Common Name (eg, your name or your server's hostname) []:your_domain_or_ip Email Address []:webmaster@example.com 您创建的两个文件都将放置在/etc/ssl. 接下来，我们将更新我们的 Apache 配置以使用新的证书和密钥。 步骤3：配置apache使用ssl 现在我们有了自签名证书和密钥，我们需要更新我们的 Apache 配置以使用它们。在 Ubuntu 上，您可以将新的 Apache 配置文件（它们必须以 结尾.conf）放入/etc/apache2/sites-available/，它们将在下次重新加载或重新启动 Apache 进程时加载。 在本教程中，我们将创建一个新的最小配置文件。（如果您已经\u003cVirtualhost\u003e设置了Apache并且只需要向其中添加 SSL，您可能需要复制以 开头的配置行SSL，并将VirtualHost端口从切换80到443。我们将80在下一步中处理端口。 ) 在 /etc/apache2/sites-available 目录中打开一个新文件： sudo nano /etc/apache2/sites-available/your_domain_or_ip.conf 粘贴以下最小的 VirtualHost 配置： /etc/apache2/sites-available/your_domain_or_ip.conf \u003cVirtualHost *:443\u003e ServerName your_domain_or_ip DocumentRoot /var/www/your_domain_or_ip SSLEngine on SSLCertificateFile /etc/ssl/certs/apache-selfsigned.crt SSLCertificateKeyFile /etc/ssl/private/apache-selfsigned.key \u003c/VirtualHost\u003e 请务必将ServerName行更新为您打算寻址服务器的任何方式。这可以是主机名、完整域名或 IP 地址。确保您选择的任何内容与Common Name您在制作证书时选择的内容相匹配。 剩下的几行指定一个DocumentRoot目录来提供文件，以及将 Apache 指向我们新创建的证书和密钥所需的 SSL 选项。 现在让我们创建我们DocumentRoot的 HTML 文件并将其放入其中，仅用于测试目的： sudo mkdir /var/www/your_domain_or_ip index.html使用文本编辑器打开一个新文件： sudo nano /var/www/your_domain_or_ip/index.html 将以下内容粘贴到空白文件中： /var/www/your_domain_or_ip/index.html \u003ch1\u003eit worked!\u003c/h1\u003e 当然，这不是一个完整的 HTML 文件，但浏览器很宽松，足以验证我们的配置。 保存并关闭文件 接下来，我们需要使用a2ensite工具启用配置文件： sudo a2ensite your_domain_or_ip.conf 接下来，让我们测试一下配置错误： sudo apache2ctl configtest 如果一切顺利，您将得到如下所示的结果： OutputAH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1. Set the 'ServerName' directive globally to suppress this messageSyntax OK 第一行是一条消息，告诉您该ServerName指令未全局设置。如果你想摆脱那条消息，你可以ServerName在/etc/apache2/apache2.conf. 这是可选的，因为该消息不会造成伤害。 如果您的输出包含Syntax OK在其中，则您的配置文件没有语法错误。我们可以安全地重新加载 Apache 以实现我们的更改： sudo systemctl reload apache2 现在在浏览器中加载您的站点，确保https://在开始时使用。 您应该会看到一个错误。这对于自签名证书来说是正常的！浏览器警告您它无法验证服务器的身份，因为我们的证书没有由任何已知的证书颁发机构签署。对于测试目的和个人使用，这可以很好。您应该能够点击进入高级信息或更多信息，然后选择继续。 执行此操作后，您的浏览器将加载该it worked!消息。 注意：如果您的浏览器根本没有连接到服务器，请确保您的连接没有被防火墙阻止。如果您使用的是ufw，以下命令将打开端口80和443：sudo ufw allow \"Apache Full\" 复制 接下来，","date":"2023-08-14","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/:0:1","tags":["ubuntu"],"title":"Ubuntu使用下篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/"},{"categories":["工具"],"content":"二、容器 LXD LXD（发音为 lex-dee）是更轻的管理程序，或轻量级容器管理程序。LXC (lex-see) 是一个在本地系统上创建和管理“容器”的程序。它还提供了一个 API 以允许更高级别的管理器（例如 LXD）管理容器。从某种意义上说，可以将 LXC 与 QEMU 进行比较，同时将 LXD 与 libvirt 进行比较。 LXC API 处理“容器”。LXD API 处理“远程”，它提供图像和容器。这通过网络扩展了 LXC 功能，并允许对容器迁移和容器映像发布等任务进行简洁的管理。 LXD 在幕后使用 LXC 来完成一些容器管理任务。但是，它保留自己的容器配置信息并有自己的约定，因此最好不要将经典的 LXC 命令与 LXD 容器一起使用. ubuntu server 预装LXD。其他系统可以使用以下命令安装 lxd 包 sudo snap install lxd 配置 lxd 初始化（必须以root身份运行） sudo lxd init 详细参数： LXD Clustering：不需要 New storage pool：需要创建一个存储池 Name of storage pool：给存储池命名 storage backend：存储后端，使用 ZFS Create a new ZFS pool：需要创建一个 ZFS 池 Use an existing block device：Yes Path to block device：使用已有的磁盘分区用于 ZFS 的存储后端 MAAS server?：不知道是啥，不需要 New local network bridge?：需要，我只需要使用 LXD 默认的网桥即可 New bridge be called：给网桥命名 IPv4：默认 auto IPv6：默认 auto LXD available over the network？：默认 no Stale cached？：默认 yes YAML printed？：打印信息，yes/no 都行 如果不能用root用户，普通用户如lhp 需要加入lxd用户组。 adduser lhp lxd 查看lxd配置信息 sudo lxc info 查看默认容器配置 sudo lxc profile show default 查看容器列表 sudo lxc list 创建容器模板 配置清华镜像源 https://mirrors.tuna.tsinghua.edu.cn/help/lxc-images/ LXD/LXC 2.0及以上版本使用镜像加速的方法: 创建一个remote链接，指向镜像站即可，或替换掉默认的images链接。 # lxc remote add tuna-images https://mirrors.tuna.tsinghua.edu.cn/lxc-images/ --protocol=simplestreams --public # lxc image list tuna-images: 查看镜像列表，寻找合适的镜像的FINGERPRINT，用于下载(注意选择x86_64架构) sudo lxc image list tuna-images: root@lhp-server:~/snap/lxd/common/config# lxc image list tuna-images:ubuntu | grep x86_64 | ubuntu/16.04 (7 more) | 4f34b9f8a490 | yes | Ubuntu xenial amd64 (20210924_07:42) | x86_64 | VIRTUAL-MACHINE | 204.25MB | Sep 24, 2021 at 12:00am (UTC) | | ubuntu/16.04 (7 more) | 10c1476cf890 | yes | Ubuntu xenial amd64 (20210924_07:42) | x86_64 | CONTAINER | 84.59MB | Sep 24, 2021 at 12:00am (UTC) | | ubuntu/16.04/cloud (3 more) | 31a69e3218ef | yes | Ubuntu xenial amd64 (20210924_07:42) | x86_64 | CONTAINER | 103.50MB | Sep 24, 2021 at 12:00am (UTC) | | ubuntu/16.04/cloud (3 more) | b3637c07e450 | yes | Ubuntu xenial amd64 (20210924_07:42) | x86_64 | VIRTUAL-MACHINE | 233.88MB | Sep 24, 2021 at 12:00am (UTC) | | ubuntu/18.04 (7 more) | 89e249e9c85d | yes | Ubuntu bionic amd64 (20210924_07:42) | x86_64 | CONTAINER | 100.45MB | Sep 24, 2021 at 12:00am (UTC) | FINGERPRINT是镜像的指纹，在上条命令下查找，ContainerTemplateName为容器模板名称，自己定义 sudo lxc launch tuna-images:\u003cFINGERPRINT\u003e \u003cContainerTemplateName\u003e 举例，创建一个名为ubuntu的容器。在lxc清华源中10c1476cf890是Ubuntu16.04的fingerprint sudo lxc launch tuna-images:10c1476cf890 ubuntu 进行容器列表查看 sudo lxc list +--------+---------+----------------------+-----------------------------------------------+-----------+-----------+ | NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS | +--------+---------+----------------------+-----------------------------------------------+-----------+-----------+ | ubuntu | RUNNING | 10.235.54.209 (eth0) | fd42:1082:67cd:27dd:216:3eff:fec0:6ed1 (eth0) | CONTAINER | 0 | +--------+---------+----------------------+-----------------------------------------------+-----------+-----------+ 可进入容器的 root 用户下 bash sudo lxc exec \u003cContainerTemplateName\u003e bash 用户切换 sudo susu ubuntu 配置共享目录 设置共享目录来实现宿主机与容器之间的文件传输 设置键值 sudo lxc config set \u003cContainerTemplateName\u003e security.privileged true 设置共享目录，其中shareName为虚拟的设备名称，lxd会虚拟出该设备并导通接通两者共享目录，path1为宿主机下共享目录路径，path2为容器下共享目录路径 sudo lxc config device add \u003cContainerTemplateName\u003e \u003cshareName\u003e disk source=\u003cpath1\u003e path=\u003cpath2\u003e 实例： oot@lhp-server:~# lxc config set ubuntu security.privileged true root@lhp-server:~# lxc config device add ubuntu share disk source=/share path=/media Device share added to ubuntu 可以在宿主机/media中创建文件测试，容器/share中文件是否存在。 设置用户名密码： sudo lxc exec \u003cContainerTemplateName\u003e bashpasswd 容器克隆 克隆容器 参数一为模板容器名称，参数二为目标容器名称 sudo lxc copy \u003cContainerTemplateName\u003e \u003cnewContainerName\u003e 运行新容器 sudo lxc start \u003cnewContainerName\u003e 进入新容器bash sudo lxc exec \u003cnewContainerName\u003e bash 注意，此步骤后需要修改Frp的端口，重新建立内外网穿透，建议修改后使用snapshot快照备份sudo lxc snapshot \u003cContainerName\u003e。 实例： root@lhp-server:~# lxc list +---------+---------+----------------------+-------------------------------------","date":"2023-08-14","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/:0:2","tags":["ubuntu"],"title":"Ubuntu使用下篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/"},{"categories":["工具"],"content":"三、数据库 PostgreSQL PostgreSQL 是一个对象关系数据库系统，它具有传统商业数据库系统的特性，并在下一代 DBMS 系统中进行了增强。 安装 sudo apt install postgresql 配置 要使其他计算机能够连接到您的 PostgreSQL 服务器，请编辑文件 /etc/postgresql/12/main/postgresql.conf 找到*#listen_addresses = ’localhost’ 行*并将其更改为： listen_addresses = '*' 笔记 要同时允许 IPv4 和 IPv6 连接，请将 ’localhost’ 替换为 ‘::’ 现在我们可以连接到我们的 PostgreSQL 服务器，下一步是为postgres用户设置密码。在终端提示符下运行以下命令以连接到默认的 PostgreSQL 模板数据库： sudo -u postgres psql template1 上面的命令以用户postgres连接到 PostgreSQL 数据库template1。连接到 PostgreSQL 服务器后，您将看到 SQL 提示符。您可以在 psql 提示符下运行以下 SQL 命令来配置用户postgres的密码。 ALTER USER postgres with encrypted password 'your_password'; 配置密码后，编辑文件/etc/postgresql/12/main/pg_hba.conf以对postgres用户使用MD5身份验证： local all postgres md5 最后，您应该重新启动 PostgreSQL 服务以初始化新配置。从终端提示输入以下内容以重新启动 PostgreSQL： sudo systemctl restart postgresql.service 警告 以上配置无论如何都不完整。更多参数请参考《PostgreSQL 管理员指南》 。 您可以使用 PostgreSQL 客户端测试来自其他机器的服务器连接。 sudo apt install postgresql-client psql -h postgres.example.com -U postgres -W 笔记 将域名替换为您的实际服务器域名。 参考：https://ubuntu.com/server/docs/databases-postgresql ","date":"2023-08-14","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/:0:3","tags":["ubuntu"],"title":"Ubuntu使用下篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/"},{"categories":["工具"],"content":"四、监控 集群监控软件 Prometheus Prometheus Alertmanager Grafana Telegraf 所需端口 Prometheus monitor:9090 Alertmanager monitor:9093 Grafana monitor:3000 Telegraf workload:9273 nagios 安装 https://www.osradar.com/how-to-install-nagios-on-ubuntu-20-04/#:~:text=How%20To%20Install%20Nagios%20on%20Ubuntu%2020.04%201,pre-checks%20are%20okay.%20...%209%20Access%20Web%20Dashboard ","date":"2023-08-14","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/:0:4","tags":["ubuntu"],"title":"Ubuntu使用下篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/"},{"categories":["工具"],"content":"五、备份 备份软件： 方案1：bacula 方案2：NFS+shell script + crontab 场景：nfs server ：10.4.7.141 共享目录： /mnt/backup ​ nfs client : 10.4.7.142 新建目录/opt/example 需要与 10.4.7.141的/mnt/backup 目录做绑定。 server： sudo apt install nfs-kernel-server sudo systemctl start nfs-kernel-server.service 配置： vim /etc/exports /mnt/backup *(ro,sync,subtree_check) 如果/mnt/backup 不存在先创建该目录。 mkdir -p /mnt/backup 配置生效 sudo exportfs -a client: 安装nfs客户端 sudo apt install nfs-common 创建目录 sudo mkdir /opt/example sudo mount 10.4.7.141:/mnt/backup /opt/example 最后需要配置fstab vim /etc/fstab 10.4.7.141:/mnt/backup /opt/example nfs rsize=8192,wsize=8192,timeo=14,intr 备份脚本编写 场景：定时将client中 /home /var/spool/mail /etc /opt 中文件备份到server 的/mnt/backup 中。每天凌晨12：00 备份一次。 backup.sh #!/bin/bash #################################### # # Backup to NFS mount script. # #################################### # What to backup. backup_files=\"/home /var/spool/mail /etc /opt\" # Where to backup to. dest=\"/mnt/backup\" # Create archive filename. day=$(date +%A) hostname=$(hostname -s) archive_file=\"$hostname-$day.tgz\" # Print start status message. echo \"Backing up $backup_files to $dest/$archive_file\" date echo # Backup the files using tar. tar czf $dest/$archive_file $backup_files # Print end status message. echo echo \"Backup finished\" date # Long listing of files in $dest to check file sizes. ls -lh $dest crontab 0 0 * * * bash /usr/local/bin/backup.sh 从备份中恢复 查看存档内容的列表。从终端提示输入： tar -tzvf /mnt/backup/host-Monday.tgz 要将文件从存档恢复到不同的目录，请输入： tar -xzvf /mnt/backup/host-Monday.tgz -C /tmp etc/hosts tar的*-C*选项将提取的文件重定向到指定的目录。上面的例子将/etc/hosts文件解压到/tmp/etc/hosts. tar 重新创建它包含的目录结构。 另外，请注意前导*“/”*不在要恢复的文件路径之外。 要恢复存档中的所有文件，请输入以下内容： cd /sudo tar -xzvf /mnt/backup/host-Monday.tgz 笔记 这将覆盖当前文件系统上的文件。 ","date":"2023-08-14","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/:0:5","tags":["ubuntu"],"title":"Ubuntu使用下篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/"},{"categories":["工具"],"content":"六、邮件服务 dovecot postfix ","date":"2023-08-14","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/:0:6","tags":["ubuntu"],"title":"Ubuntu使用下篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/"},{"categories":["工具"],"content":"七、web服务 状态码 1xx : Informational - 收到请求，继续处理 2xx : 成功- 动作被成功接收、理解和接受 3xx : 重定向- 必须采取进一步行动才能完成请求 4xx : 客户端错误- 请求包含错误的语法或无法完成 5xx： 服务器错误- 服务器未能满足明显有效的请求 静态 Web 服务器：服务器响应的内容将是托管文件“原样”。 动态 Web 服务器：由一个 Web 服务器和一个额外的软件组成，通常是一个应用服务器和一个数据库。例如，要生成您在 Web 浏览器中看到的 Web 页面，应用程序服务器可能会用数据库中的内容填充 HTML 模板。因此，我们说服务器响应的内容是动态生成的。 apache2 Apache 是 Linux 系统上最常用的 Web 服务器。Web 服务器用于为客户端计算机请求的网页提供服务。客户端通常使用 Firefox、Opera、Chromium 或 Internet Explorer 等 Web 浏览器应用程序请求和查看网页. 用于传输网页的最常用协议是超文本传输协议 (HTTP)。还支持诸如基于安全套接字层的超文本传输协议 (HTTPS) 和文件传输协议 (FTP)（用于上传和下载文件的协议）等协议。 Apache Web 服务器通常与 MySQL 数据库引擎、超文本预处理器 (PHP) 脚本语言和其他流行的脚本语言（如 Python 和 Perl）结合使用。这种配置被称为 LAMP（Linux、Apache、MySQL 和 Perl/Python/PHP），它为基于 Web 的应用程序的开发和部署形成了一个强大而健壮的平台。 安装 在终端提示符下输入以下命令： sudo apt install apache2 配置 Apache2 是通过在纯文本配置文件中放置指令来配置的。这些指令在以下文件和目录之间分开： apache2.conf：Apache2 的主要配置文件。包含对 Apache2全局的设置。 httpd.conf：历史上主要的 Apache2 配置文件，以 httpd 守护进程命名。在其他发行版（或旧版本的 Ubuntu）中，该文件可能存在。在 Ubuntu 中，所有配置选项已移至apache2.conf及以下引用目录，该文件不再存在。 conf-available：该目录包含可用的配置文件。以前在的所有文件/etc/apache2/conf.d都应移动到/etc/apache2/conf-available. conf-enabled：持有符号链接*到文件/etc/apache2/conf-available。当配置文件被符号链接时，它将在下次重新启动 apache2 时启用。 envvars：设置Apache2环境变量的文件。 mods-available：此目录包含加载模块和配置它们的配置文件。然而，并非所有模块都有特定的配置文件。 mods-enabled：持有符号链接到文件/etc/apache2/mods-available。当模块配置文件被符号链接时，它将在下次重新启动 apache2 时启用。 ports.conf：包含确定 Apache2 正在侦听的 TCP 端口的指令。 sites-available: 此目录包含 Apache2虚拟主机的配置文件。虚拟主机允许为具有单独配置的多个站点配置 Apache2。 sites-enabled：与mods-enabled一样，sites-enabled包含指向/etc/apache2/sites-available目录的符号链接。类似地，当sites-available 中的配置文件被符号链接时，一旦Apache2 重新启动，由它配置的站点将处于活动状态。 magic：根据文件的前几个字节确定 MIME 类型的说明。 新建站点或虚拟主机 sudo cp /etc/apache2/sites-available/000-default.conf /etc/apache2/sites-available/mynewsite.conf 最终要访问的域名或IP和/etc/apache2/sites-available/中.conf文件同名 更改默认监听端口在： /etc/apache2/ports.conf 您可能还希望您的站点响应www.mynewsite.com，因为许多用户会认为 www 前缀是合适的。为此使用ServerAlias指令。您还可以在 ServerAlias 指令中使用通配符。 例如，以下配置将使您的站点响应任何以.mynewsite.com结尾的域请求。 ServerAlias *.mynewsite.com 默认站点位置： /var/www/html 示例：将80端口重定向到443端口 /etc/apache2/sites-available/10.4.7.142.conf \u003cVirtualHost *:443\u003e ServerName 10.4.7.142 DocumentRoot /var/www/10.4.7.142 SSLEngine on SSLCertificateFile /etc/ssl/certs/apache-selfsigned.crt SSLCertificateKeyFile /etc/ssl/private/apache-selfsigned.key \u003c/VirtualHost\u003e \u003cVirtualHost *:80\u003e ServerName 10.4.7.142 Redirect / https://10.4.7.142/ \u003c/VirtualHost\u003e 站点主页： /var/www/10.4.7.142/index.html \u003ch1\u003eit worked!\u003c/h1\u003e 自签名证书需要自行创建： /etc/ssl/certs/apache-selfsigned.crt 和/etc/ssl/private/apache-selfsigned.key 开启应用配置： sudo a2ensite l0.4.7.142 sudo systemctl restart apache2.service 禁用站点配置： sudo a2dissite 10.4.7.142 sudo systemctl restart apache2.service 启动ssl模块 sudo a2enmod ssl 您可以通过https://your_hostname/url/在浏览器地址栏中键入来访问安全服务器页面。 ","date":"2023-08-14","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/:0:7","tags":["ubuntu"],"title":"Ubuntu使用下篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/"},{"categories":["工具"],"content":"八、密码管理 root密码忘记重置 重启系统 按F1进入。 重启Ubuntu 在启动界面选择 （高级）-》 选择 recovery mode-》 首先重建GRUB引导，否则改密码可能会出现 Authentication token manipulation error 错误-》 完成后回车，继续选择root，接下来按照提示修改密码就可以。 passwd root 修改完成后，重启服务器 reboot ","date":"2023-08-14","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/:0:8","tags":["ubuntu"],"title":"Ubuntu使用下篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/"},{"categories":["工具"],"content":"九、ubuntu20.04 进入命令行模式 启动时禁用GUI sudo systemctl set-default multi-user 重新启动或退出当前会话以退出GUI: gnome-session-quit 恢复图形模式 sudo systemctl set-default graphical ","date":"2023-08-14","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/:0:9","tags":["ubuntu"],"title":"Ubuntu使用下篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8B%E7%AF%87/"},{"categories":["网站"],"content":"一、需求 由于文章中图片比较大，所以迫切需要将原图片压缩但质量又不会丢失太多。google发现可以将png、jpeg等格式的图片转换成webp格式。体积缩小的同时又不失真。 工具官网 。 我的环境是windows,下载：libwebp-1.3.1-windows-x64.zip。解压后添加环境变量。 我的电脑-\u003e属性-\u003e高级-\u003e环境变量-\u003e系统变量中找到path-\u003e新增cwebp程序路径：C:\\Users\\1\\Downloads\\libwebp-1.3.1-windows-x64\\bin。 这样可以在任何文件夹内都可以使用cwebp命令压缩图片。 ","date":"2023-08-12","objectID":"/%E6%96%87%E7%AB%A0%E4%B8%AD%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/:0:1","tags":["cwebp"],"title":"文章中图片优化","uri":"/%E6%96%87%E7%AB%A0%E4%B8%AD%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/"},{"categories":["网站"],"content":"二、图片压缩命令 首先进入需要压缩的图片文件夹内，在当前文件夹内输入cmd命令打开dos窗口。例如我们需要将所有png、jpg格式的图片转换成webp格式。输入以下命令: for %f in (*.jpg *.png) do cwebp -q 80 \"%f\" -o \"%~nf.webp\" 然后将转换完成后的图片转移到我们项目的图片路径中（我这里是/postimages），最后在文章中引入图片路径就完成了。 ","date":"2023-08-12","objectID":"/%E6%96%87%E7%AB%A0%E4%B8%AD%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/:0:2","tags":["cwebp"],"title":"文章中图片优化","uri":"/%E6%96%87%E7%AB%A0%E4%B8%AD%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96/"},{"categories":["网站"],"content":"一、使用zeabur平台搭建umami zeabur官方部署说明 根据官方说明，首先需要部署PostageSQL数据库，用来存储umami的数据。需要注意的是，部署好数据库后需要手动创建一个名称为umami的数据库。由于平台没有用于连接数据库的终端，所以我这里使用DBeaver连接数据库。 ","date":"2023-08-12","objectID":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/:1:0","tags":["umami"],"title":"网站访客统计搭建","uri":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/"},{"categories":["网站"],"content":"1.连接数据库 查看PostageSQL数据库中连接信息 创建连接，第一次连接需要下载驱动。 ","date":"2023-08-12","objectID":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/:1:1","tags":["umami"],"title":"网站访客统计搭建","uri":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/"},{"categories":["网站"],"content":"2.创建数据库 ","date":"2023-08-12","objectID":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/:1:2","tags":["umami"],"title":"网站访客统计搭建","uri":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/"},{"categories":["网站"],"content":"二、创建umami项目 这里可以根据平台文档来创建。需要注意的是：创建完毕后，需要将刚刚创建的PostageSQL数据库的用户名、密码、端口信息应用到umami项目中。最后重启等待部署完毕。 ","date":"2023-08-12","objectID":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/:2:0","tags":["umami"],"title":"网站访客统计搭建","uri":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/"},{"categories":["网站"],"content":"三、自定义域名 将自定义的域名（umami.haipengv.com）指向名平台默认域名(我这里是myumami.zeabur.app),注意勾选Redirect to another domain选项。 ","date":"2023-08-12","objectID":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/:3:0","tags":["umami"],"title":"网站访客统计搭建","uri":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/"},{"categories":["网站"],"content":"四、域名映射 最后需要在cloudflare中新增一条A记录，将umami.haipengv.com和ip绑定。这里的IP可以通过ping平台默认域名（myumami.zeabur.app）来得到。 DNS-\u003e添加记录-\u003e类型选择’A’。 最后可以通过访问我们自定义的域名 ，来查看访客记录了。 umami默认的用户名是：admin,密码是：umami。 官方项目地址 ","date":"2023-08-12","objectID":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/:4:0","tags":["umami"],"title":"网站访客统计搭建","uri":"/%E7%BD%91%E7%AB%99%E8%AE%BF%E5%AE%A2%E7%BB%9F%E8%AE%A1%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"shell执行脚本报错如下(环境centos7) [: ==: unexpected operator 脚本如下： #!/bin/sh if [ $1 == \"hello\" ]; then echo \"Well done!\" fi 这是因为 shell 脚本开头使用 #!/bin/sh，而不是 #!/bin/bash。而 /bin/sh 使用的是 dash，dash 中默认的判断语句是 =，而不是 bash 使用的 ==。 将#!/bin/sh改为#!/bin/bash后，执行成功。 ","date":"2023-08-04","objectID":"/crontab%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99/:0:0","tags":["crontab"],"title":"Crontab执行shell脚本报错","uri":"/crontab%E6%89%A7%E8%A1%8Cshell%E8%84%9A%E6%9C%AC%E6%8A%A5%E9%94%99/"},{"categories":["工具"],"content":"Linux Crontab定时执行脚本出错，但手动执行脚本正常原因及解决方案 手动执行脚本可以执行成功，但用定时任务后却执行不成功。查看日志tail -f /var/log/cron 显示执行成功了。 2023-07-31T16:06:01.624003+08:00 localhost CROND[7853]: (root) CMD (/root/pidcheck.sh) 原因就在于，crontab没有去读环境变量，需要再脚本中手动引入环境变量。 #！bin/bash source /etc/profile source ~/.bash_profile ... 再执行时，问题解决。 原来就是因为crontab在执行脚本时没有读取环境变量，导致执行脚本失败。 ","date":"2023-07-31","objectID":"/crontab%E8%B8%A9%E5%9D%91%E8%AE%B0/:1:0","tags":["crontab"],"title":"Crontab踩坑记","uri":"/crontab%E8%B8%A9%E5%9D%91%E8%AE%B0/"},{"categories":["secretpost"],"content":"Linux命令英文全称 cat: Concatenate 串联 uname: Unix name 系统名称 df: Disk free 空余硬盘 du: Disk usage 硬盘使用率 chown: Change owner 改变所有者 chgrp: Change group 改变用户组 ps：Process Status 进程状态 tar：Tape archive 解压文件 chmod: Change mode 改变模式 umount: Unmount 卸载 ldd：List dynamic dependencies 列出动态相依 insmod：Install module 安装模块 rmmod：Remove module 删除模块 lsmod：List module 列表模块 alias :Create your own name for a command bash :GNU Bourne-Again Shell linux内核 grep:global regular expression print httpd :Start Apache ipcalc :Calculate IP information for a host ping :Send ICMP ECHO_Request to network hosts reboot: Restart your computer sudo:Superuser do /bin = BINaries /dev = DEVices /etc = ETCetera /lib = LIBrary /proc = PROCesses /sbin = Superuser BINaries /tmp = TeMPorary /usr = Unix Shared Resources /var = VARiable ? FIFO = First In, First Out GRUB = GRand Unified Bootloader IFS = Internal Field Seperators LILO = LInux LOader PS = Prompt String Perl = \"Pratical Extraction and Report Language\" = \"Pathologically Eclectic Rubbish Lister\" Tcl = Tool Command Language Tk = ToolKit VT = Video Terminal YaST = Yet Another Setup Tool apt = Advanced Packaging Tool ar = archiver as = assembler bash = Bourne Again SHell bc = Basic (Better) Calculator bg = BackGround cal = CALendar cat = CATenate cd = Change Directory chgrp = CHange GRouP chmod = CHange MODe chown = CHange OWNer chsh = CHange SHell cmp = compare cobra = Common Object Request Broker Architecture comm = common cp = CoPy cpio = CoPy In and Out cpp = C Pre Processor cups = Common Unix Printing System cvs = Current Version System dc = Desk Calculator dd = Disk Dump df = Disk Free diff = DIFFerence dmesg = diagnostic message du = Disk Usage ed = editor egrep = Extended GREP elf = Extensible Linking Format elm = ELectronic Mail emacs = Editor MACroS eval = EVALuate ex = EXtended exec = EXECute fd = file descriptors fg = ForeGround fgrep = Fixed GREP fmt = format fsck = File System ChecK fstab = FileSystem TABle fvwm = F*** Virtual Window Manager gawk = GNU AWK gpg = GNU Privacy Guard groff = GNU troff hal = Hardware Abstraction Layer joe = Joe's Own Editor ksh = Korn SHell lame = Lame Ain't an MP3 Encoder lex = LEXical analyser lisp = LISt Processing = Lots of Irritating Superfluous Parentheses ln = LiNk lpr = Line PRint ls = list lsof = LiSt Open Files m4 = Macro processor Version 4 man = MANual pages mawk = Mike Brennan's AWK mc = Midnight Commander mkfs = MaKe FileSystem mknod = MaKe NODe motd = Message of The Day mozilla = MOsaic GodZILLa mtab = Mount TABle mv = MoVe nano = Nano's ANOther editor nawk = New AWK nl = Number of Lines nm = names nohup = No HangUP nroff = New ROFF od = Octal Dump passwd = PASSWorD pg = pager pico = PIne's message COmposition editor pine = \"Program for Internet News \u0026 Email\" = \"Pine is not Elm\" ping = Packet InterNet Grouper pirntcap = PRINTer CAPability popd = POP Directory pr = pre printf = PRINT Formatted ps = Processes Status pty = pseudo tty pushd = PUSH Directory pwd = Print Working Directory rc = runcom = run command, shell rev = REVerse rm = ReMove rn = Read News roff = RunOFF rpm = RPM Package Manager = RedHat Package Manager rsh, rlogin, = Remote rxvt = ouR XVT sed = Stream EDitor seq = SEQuence shar = SHell ARchive slrn = S-Lang rn ssh = Secure SHell ssl = Secure Sockets Layer stty = Set TTY su = Substitute User svn = SubVersioN tar = Tape ARchive tcsh = TENEX C shell telnet = TEminaL over Network termcap = terminal capability terminfo = terminal information tr = traslate troff = Typesetter new ROFF tsort = Topological SORT tty = TeleTypewriter twm = Tom's Window Manager tz = TimeZone udev = Userspace DEV ulimit = User's LIMIT umask = User's MASK uniq = UNIQue vi = VIsual = Very Inconvenient vim = Vi IMproved wall = write all wc = Word Count wine = WINE Is Not an Emulator xargs = eXtended ARGuments xdm = X Display Manager xlfd = X Logical Font Description xmms = X Multimedia System xrdb = X Resources DataBase xwd = X Window Dump yacc = yet another compiler compiler ","date":"2023-07-22","objectID":"/secret/:0:1","tags":["secret"],"title":"Secret","uri":"/secret/"},{"categories":null,"content":"测试功能 Peng \"One World, One Dream.\" ","date":"2023-07-22","objectID":"/friends/:0:1","tags":null,"title":"友链墙","uri":"/friends/"},{"categories":null,"content":"blog美化 雨临Lewis \"不想当写手的码农不是好咸鱼_(xз」∠)_\" ","date":"2023-07-22","objectID":"/friends/:0:2","tags":null,"title":"友链墙","uri":"/friends/"},{"categories":null,"content":"欢迎访问我的博客，这里主要分享我的一些经验、想法和作品。 你可以通过 [RSS ] 的方式持续关注我的博客更新。 ","date":"2023-07-21","objectID":"/about/:0:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"我的网站访问统计 [快来点我! ] ","date":"2023-07-21","objectID":"/about/:0:1","tags":null,"title":"About","uri":"/about/"},{"categories":["工具"],"content":"nvm管理node.js ","date":"2023-05-11","objectID":"/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/:1:0","tags":["nvm"],"title":"前端框架","uri":"/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"categories":["工具"],"content":"环境： centos 7.9 ","date":"2023-05-11","objectID":"/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/:1:1","tags":["nvm"],"title":"前端框架","uri":"/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"categories":["工具"],"content":"nvm 安装 新创建一个名为myapp的桥接网卡 cd /root wget https://github.com/nvm-sh/nvm/archive/refs/tags/v0.39.3.tar.gz mkdir -p /root/.nvm tar -zxvf nvm-0.39.3.tar.gz -C /root/.nvm 配置环境 vim ~/.bashrc 在~/.bashrc的末尾，添加如下语句： export NVM_DIR=\"$HOME/.nvm/nvm-0.39.3\" [ -s \"$NVM_DIR/nvm.sh\" ] \u0026\u0026 \\. \"$NVM_DIR/nvm.sh\" # This loads nvm [ -s \"$NVM_DIR/bash_completion\" ] \u0026\u0026 \\. \"$NVM_DIR/bash_completion\" # This loads nvm bash_completion 启用环境 source ~/.bashrc 安装node.js，测试 nvm install 8.16.0 切换版本 nvm use 8.16.0 查看已安装的版本 nvm ls ","date":"2023-05-11","objectID":"/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/:1:2","tags":["nvm"],"title":"前端框架","uri":"/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"categories":["工具"],"content":"docker创建专有网卡 ","date":"2023-02-22","objectID":"/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/:1:0","tags":["docker"],"title":"docker创建专有网卡","uri":"/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/"},{"categories":["工具"],"content":"需求： tomcat容器需要通过jdbc模块连接数据库mysql，配置文件如果指定IP地址，mysql容器一旦损坏，IP地址就会更改，需要将mysql容器的IP固定。这样就不用每次更改tomcat配置文件了。 ","date":"2023-02-22","objectID":"/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/:1:1","tags":["docker"],"title":"docker创建专有网卡","uri":"/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/"},{"categories":["工具"],"content":"专有网卡创建 新创建一个名为myapp的桥接网卡 docker network create myapp 使用--network-alias参数给网卡起别名，启动MySQL容器。 docker run -d \\ --network myapp --network-alias mysql1 \\ --name=mysql57-test \\ -p 33306:3306 \\ -v /tmpdisk/test2:/var/lib/mysql \\ -v /etc/localtime:/etc/localtime:ro \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -e MYSQL_DATABASE=todos \\ mysql:5.7 注意：这里创建的mysql容器使用myapp 网卡，分配的IP自动和mysql1 网卡别名绑定，后面创建的容器只要使用同一个网卡创建的，都可以和mysql容器互通。 如何证明呢？ 使用nicolaka/netshoot镜像创建一个测试容器 docker run -it --name test --network myapp nicolaka/netshoot 可以直接和mysql容器通信 62337a7ad7f1# ping mysql1 PING mysql1 (172.20.0.5) 56(84) bytes of data. 64 bytes from mysql57-test.myapp (172.20.0.5): icmp_seq=1 ttl=64 time=0.042 ms 64 bytes from mysql57-test.myapp (172.20.0.5): icmp_seq=2 ttl=64 time=0.020 ms 查看解析，发现一条A记录。正是这条记录将myapp网卡自动分配的ip和网卡别名mysql1绑定。 62337a7ad7f1# dig mysql1 ; \u003c\u003c\u003e\u003e DiG 9.18.11 \u003c\u003c\u003e\u003e mysql1 ;; global options: +cmd ;; Got answer: ;; -\u003e\u003eHEADER\u003c\u003c- opcode: QUERY, status: NOERROR, id: 10768 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION: ;mysql1. IN A ;; ANSWER SECTION: mysql1. 600 IN A 172.20.0.5 ;; Query time: 0 msec ;; SERVER: 127.0.0.11#53(127.0.0.11) (UDP) ;; WHEN: Wed Feb 22 01:36:59 UTC 2023 ;; MSG SIZE rcvd: 46 创建tomcat容器 docker run -itd \\ -p 28080:8080 \\ --restart=always \\ --name tomcat-test \\ --network myapp \\ -v /tmpdisk/tomcat-test2/webapps:/usr/local/tomcat/webapps \\ -v /etc/localtime:/etc/localtime:ro \\ tomcat:9.0.56 更改jdbc连接配置，将localhost改成mysql1 旧： jdbc:mysql://localhost:3306/jt_ow_dbsync_src?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false 新： jdbc:mysql://mysql1:3306/jt_ow_dbsync_src?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;useSSL=false ","date":"2023-02-22","objectID":"/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/:1:2","tags":["docker"],"title":"docker创建专有网卡","uri":"/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/"},{"categories":["工具"],"content":"测试 测试内容：mysql容器IP更改后，会不会影响业务访问。 **查看当前mysql 容器IP** [root@HZ ~]$ docker inspect mysql57-test | grep -i ipaddress \"SecondaryIPAddresses\": null, \"IPAddress\": \"\", \"IPAddress\": \"172.20.0.5\", 删除容器 docker rm -f mysql57-test 重新创建新容器 docker run -itd --name test2 --network myapp busybox 再创建mysql容器 docker run -d \\ --network myapp --network-alias mysql1 \\ --name=mysql57-test \\ -p 33306:3306 \\ -v /tmpdisk/test2:/var/lib/mysql \\ -v /etc/localtime:/etc/localtime:ro \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -e MYSQL_DATABASE=todos \\ mysql:5.7 再次查看mysql容器IP [root@HZ ~]$ docker inspect mysql57-test | grep -i ipaddress \"SecondaryIPAddresses\": null, \"IPAddress\": \"\", \"IPAddress\": \"172.20.0.6\", 访问业务，发现业务访问正常。所以完美实现了mysql容器内部IP变更后不会影响业务。 ","date":"2023-02-22","objectID":"/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/:1:3","tags":["docker"],"title":"docker创建专有网卡","uri":"/docker%E5%88%9B%E5%BB%BA%E4%B8%93%E6%9C%89%E7%BD%91%E5%8D%A1/"},{"categories":["工具"],"content":"docker使用tab自动补全命令 ","date":"2023-02-21","objectID":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/:1:0","tags":["docker"],"title":"docker使用tab自动补全命令","uri":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"On RHEL-based systems dnf install bash-completion -y yum install bash-completion -y ","date":"2023-02-21","objectID":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/:1:1","tags":["docker"],"title":"docker使用tab自动补全命令","uri":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"On Debian-based systems apt-get install bash-completion -y ","date":"2023-02-21","objectID":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/:1:2","tags":["docker"],"title":"docker使用tab自动补全命令","uri":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"下载命令补全文件 curl https://raw.githubusercontent.com/docker/docker-ce/master/components/cli/contrib/completion/bash/docker -o /etc/bash_completion.d/docker.sh ","date":"2023-02-21","objectID":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/:1:3","tags":["docker"],"title":"docker使用tab自动补全命令","uri":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"如果下载失败最后附上文件内容。 ","date":"2023-02-21","objectID":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/:1:4","tags":["docker"],"title":"docker使用tab自动补全命令","uri":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"重新登录终端 ","date":"2023-02-21","objectID":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/:1:5","tags":["docker"],"title":"docker使用tab自动补全命令","uri":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"测试命令补全 docker p 两次tab ,命令自动补全 pause plugin port ps pull push ","date":"2023-02-21","objectID":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/:1:6","tags":["docker"],"title":"docker使用tab自动补全命令","uri":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"整理 先安装补全软件bash-completion，然后在/etc/bash_completion.d目录下创建文件，写入补全命令，重新登录终端，自动生效。 docker.sh文件内容如下： #!/usr/bin/env bash # shellcheck disable=SC2016,SC2119,SC2155,SC2206,SC2207,SC2254 # # Shellcheck ignore list: # - SC2016: Expressions don't expand in single quotes, use double quotes for that. # - SC2119: Use foo \"$@\" if function's $1 should mean script's $1. # - SC2155: Declare and assign separately to avoid masking return values. # - SC2206: Quote to prevent word splitting, or split robustly with mapfile or read -a. # - SC2207: Prefer mapfile or read -a to split command output (or quote to avoid splitting). # - SC2254: Quote expansions in case patterns to match literally rather than as a glob. # # You can find more details for each warning at the following page: # https://github.com/koalaman/shellcheck/wiki/\u003cSCXXXX\u003e # # bash completion file for core docker commands # # This script provides completion of: # - commands and their options # - container ids and names # - image repos and tags # - filepaths # # To enable the completions either: # - place this file in /etc/bash_completion.d # or # - copy this file to e.g. ~/.docker-completion.sh and add the line # below to your .bashrc after bash completion features are loaded # . ~/.docker-completion.sh # # Configuration: # # For several commands, the amount of completions can be configured by # setting environment variables. # # DOCKER_COMPLETION_SHOW_CONFIG_IDS # DOCKER_COMPLETION_SHOW_CONTAINER_IDS # DOCKER_COMPLETION_SHOW_NETWORK_IDS # DOCKER_COMPLETION_SHOW_NODE_IDS # DOCKER_COMPLETION_SHOW_PLUGIN_IDS # DOCKER_COMPLETION_SHOW_SECRET_IDS # DOCKER_COMPLETION_SHOW_SERVICE_IDS # \"no\" - Show names only (default) # \"yes\" - Show names and ids # # You can tailor completion for the \"events\", \"history\", \"inspect\", \"run\", # \"rmi\" and \"save\" commands by settings the following environment # variables: # # DOCKER_COMPLETION_SHOW_IMAGE_IDS # \"none\" - Show names only (default) # \"non-intermediate\" - Show names and ids, but omit intermediate image IDs # \"all\" - Show names and ids, including intermediate image IDs # # DOCKER_COMPLETION_SHOW_TAGS # \"yes\" - include tags in completion options (default) # \"no\" - don't include tags in completion options # # Note: # Currently, the completions will not work if the docker daemon is not # bound to the default communication port/socket # If the docker daemon is using a unix socket for communication your user # must have access to the socket for the completions to function correctly # # Note for developers: # Please arrange options sorted alphabetically by long name with the short # options immediately following their corresponding long form. # This order should be applied to lists, alternatives and code blocks. __docker_previous_extglob_setting=$(shopt -p extglob) shopt -s extglob __docker_q() { docker ${host:+--host \"$host\"} ${config:+--config \"$config\"} ${context:+--context \"$context\"} 2\u003e/dev/null \"$@\" } # __docker_configs returns a list of configs. Additional options to # `docker config ls` may be specified in order to filter the list, e.g. # `__docker_configs --filter label=stage=production`. # By default, only names are returned. # Set DOCKER_COMPLETION_SHOW_CONFIG_IDS=yes to also complete IDs. # An optional first option `--id|--name` may be used to limit the # output to the IDs or names of matching items. This setting takes # precedence over the environment setting. __docker_configs() { local format if [ \"$1\" = \"--id\" ] ; then format='{{.ID}}' shift elif [ \"$1\" = \"--name\" ] ; then format='{{.Name}}' shift elif [ \"$DOCKER_COMPLETION_SHOW_CONFIG_IDS\" = yes ] ; then format='{{.ID}} {{.Name}}' else format='{{.Name}}' fi __docker_q config ls --format \"$format\" \"$@\" } # __docker_complete_configs applies completion of configs based on the current value # of `$cur` or the value of the optional first option `--cur`, if given. __docker_complete_configs() { local current=\"$cur\" if [ \"$1\" = \"--cur\" ] ; then current=\"$2\" shift 2 fi COMPREPLY=( $(compgen -W \"$(__dock","date":"2023-02-21","objectID":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/:1:7","tags":["docker"],"title":"docker使用tab自动补全命令","uri":"/docker%E9%85%8D%E7%BD%AEtab%E8%A1%A5%E5%85%A8%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"使用浏览器登录linux服务器 ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:0","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"项目地址 https://github.com/huashengdun/webssh/releases/tag/v1.6.1 在这里我选在下载的版本是：v1.6.1 上传到服务器上 ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:1","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"开始安装 ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:2","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"创建解压目录 mkdir -p /tmpdisk/webssh ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:3","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"解压离线webssh安装包 cd /tmpdisk/webssh unzip webssh-1.6.1.zip . ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:4","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"进入解压目录 cd webssh-1.6.1 ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:5","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"使用docker-compose一键启动 docker-compose up ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:6","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"安装docker-compose wget https://github.com/docker/compose/releases/download/1.24.0/docker-compose-Linux-x86_64 ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:7","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"赋予文件执行权限 chmod +x docker-compose-Linux-x86_64 ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:8","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"拷贝到目录 cp docker-compose-Linux-x86_64 /usr/local/bin/docker-compose ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:9","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"添加软链接 ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:10","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"最后查看版本 docker-compose --version ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:11","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["工具"],"content":"webssh使用 使用docker-compose 启动后默认将容器内的8888 端口映射到宿主机8888.通过访问宿主机的8888端口，打开webssh页面，登录Linux服务器。 ","date":"2023-02-20","objectID":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/:1:12","tags":["webssh"],"title":"使用浏览器登录linux服务器","uri":"/%E4%BD%BF%E7%94%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%99%BB%E5%BD%95linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["linux"],"content":"离线安装 [root@HZ ~]$ uname -a Linux HZ 3.10.0-514.el7.centos.x86_64 #1 SMP Fri Jan 13 15:16:57 CST 2017 x86_64 x86_64 x86_64 GNU/Linux CentOS Linux release 7.3.1611 (Core) ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:0","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"离线包下载 https://download.docker.com/linux/static/stable/x86_64/ 在这里我选在下载的版本是：docker-20.10.9.tgz 上传到服务器上 ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:1","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"开始安装 创建数据存储目录，如果不创建默认是/var/lib/docker mkdir -p /tmpdisk/docker ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:2","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"创建解压目录 mkdir -p /tmpdisk/docker20.10.9 ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:3","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"解压离线docker安装包 tar -zxvf docker-20.10.9.tgz -C /tmpdisk/docker20.10.9 ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:4","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"进入解压目录 cd /tmpdisk/docker20.10.9/docker/bin cp * /usr/bin ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:5","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"创建开机自启文件 vi /etc/systemd/system/docker.service ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:6","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"输入以下内容 [Unit] Description=Docker Application Container Engine Documentation=https://docs.docker.com After=network-online.target firewalld.service Wants=network-online.target [Service] Type=notify ExecStart=/usr/bin/dockerd --selinux-enabled=false --insecure-registry=127.0.0.1 ExecReload=/bin/kill -s HUP $MAINPID LimitNOFILE=infinity LimitNPROC=infinity LimitCORE=infinity TimeoutStartSec=0 Delegate=yes KillMode=process Restart=on-failure StartLimitBurst=3 StartLimitInterval=60s [Install] WantedBy=multi-user.target ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:7","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"赋予文件执行权限 chmod +x /etc/systemd/system/docker.service ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:8","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"重新加载配置 systemctl daemon-reload ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:9","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"设为开机启动 systemctl enable docker.service ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:10","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"启动docker systemctl start docker.service ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:11","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"更改docker默认存储路径，新建文件daemon.json vi /etc/docker/daemon.json { \"storage-driver\": \"vfs\", \"graph\": \"/tmpdisk/docker\" } ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:12","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"赋予权限 chmod 755 /etc/docker/daemon.json 重启docker服务,如果多次启动失败，检查daemon.json配置文件是否有多余字符。可以使用systemctl reset-failed docker.service重置失败。 ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:1:13","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"错误排查 ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:2:0","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"安装mysql57容器 docker pull mysql:5.7 docker run -itd --name mysql2 --restart=always -p 13306:3306 -e MYSQL_ROOT_PASSWORD=123456 -v /etc/localtime:/etc/localtime:ro -v /tmpdisk/mysqldata:/var/lib/mysql mysql:5.7 ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:2:1","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"启动时报错 failed to register layer: ApplyLayer exit status 1 stdout: stderr: open /etc/.pwd.lock: no such device or address 更改存储驱动,重启docker vi /etc/docker/daemon.json { \"storage-driver\": \"vfs\" } 报错2 write /var/lib/docker/vfs/dir/3bf1a7e9505dff94e1c4ba0293a90e1d17c1b5b4318ec7a355f74185f421c240/usr/sbin/mysqld: no space left on device 更改docker默认存储路径 vi /etc/docker/daemon.json { \"storage-driver\": \"vfs\", \"graph\": \"/tmpdisk/mysql5.7\" } ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:2:2","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"安装tomcat9.0容器 创建项目路径，将容器内部路径映射进来。 docker pull tomcat9.0 docker run -itd -p 18080:8080 --restart=always --name tomcat04 -v /tmpdisk/tomcat9.0.56/webapps:/usr/local/tomcat/webapps -v /etc/localtime:/etc/localtime:ro tomcat:9.0.56 进入容器，启动项目时报错 # Cannot create worker GC thread. Out of system resources. # An error report file with more information is saved as: # /usr/local/tomcat/bin/hs_err_pid46.log NOTE: Picked up JDK_JAVA_OPTIONS: --add-opens=java.base/java.lang=ALL-UNNAMED --add-opens=java.base/java.io=ALL-UNNAMED --add-opens=java.base/java.util=ALL-UNNAMED --add-opens=java.base/java.util.concurrent=ALL-UNNAMED --add-opens=java.rmi/sun.rmi.transport=ALL-UNNAMED [0.002s][warning][os,thread] Failed to start thread \"GC Thread#0\" - pthread_create failed (EPERM) for attributes: stacksize: 1024k, guardsize: 4k, detached. # # There is insufficient memory for the Java Runtime Environment to continue. # Cannot create worker GC thread. Out of system resources. # An error report file with more information is saved as: # /usr/local/tomcat/bin/hs_err_pid68.log 解决方法，更换tomcat镜像。 docker pull tomcat9.0.56 重新创建容器 docker run -itd -p 18080:8080 --name tomcat05 -v /tmpdisk/tomcat9.0.56/webapps:/usr/local/tomcat/webapps tomcat:9.0.56 后续可以添加tomcat项目的war包到宿主机目录下，包会自动加载。 ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:2:3","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"整体访问流程 tomcat项目访问mysql数据库 ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:3:0","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"容器内时区同步 启动容器时添加以下参数，会和宿主机保持一致。 -v /etc/localtime:/etc/localtime:ro 查看所有在线的容器IP docker inspect -f='{{.Name}} {{.NetworkSettings.IPAddress}} {{.HostConfig.PortBindings}}' $(docker ps -aq) ","date":"2023-02-17","objectID":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/:4:0","tags":["centos7"],"title":"centos7.3离线安装docker","uri":"/centos7.3%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85docker/"},{"categories":["linux"],"content":"安装环境 centos7.9 postfix2.10.1 dovecot2.2.36 foxmail(windows版) ","date":"2023-02-10","objectID":"/centos%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:1","tags":["centos7"],"title":"centos搭建内网邮件服务","uri":"/centos%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["linux"],"content":"功能概括 使用foxmail软件登录邮件服务器（192.168.1.89）能够成功发送和接收邮件。 ","date":"2023-02-10","objectID":"/centos%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:2","tags":["centos7"],"title":"centos搭建内网邮件服务","uri":"/centos%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["linux"],"content":"具体实现配置步骤 搭建邮件服务器 配置服务器主机名称，服务器主机名称与发信域名要一致。 [root@mail ~]# vi /etc/hostname mail.lee.com [root@mail ~]# hostname mail.lee.com 配置postfix服务 yum install postfix 如果系统自带postfix，建议先卸载旧程序，然后再安装新程序。 rpm -e postfix 编辑postfix 程序主配置文件/etc/postfix/main.cf 75 myhostname = mail.lee.com 83 mydomain = lee.com 99 myorigin = $mydomain 113 inet_interfaces = all 119 inet_protocols = ipv4 164 mydestination = $myhostname, $mydomain 264 mynetworks = 192.168.1.0/24, 127.0.0.0/8 启动postfix并加入开机自启 systemctl restart postfix systemctl enable postfix 配置dovecot服务程序 yum install dovecot 配置dovecot主配置文件/etc/dovecot/dovecot.conf vi /etc/dovecot/dovecot.conf 24 protocols = pop3 lmtp imap 48 login_trusted_networks = 192.168.1.0/24 配置邮件格式与存储路径 vi /etc/dovecot/conf.d/10-mail.conf mail_location = mbox:~/mail:INBOX=/var/mail/%u 重启dovecot服务并开机启动 systemctl restart dovecot systemctl enable dovecot 创建电子邮件系统的登录账户（本地系统的账户和密码，因此在本地系统创建常规账户即可） 1.发送邮件用户 useradd test passwd test 2.接收文件用户 useradd recv passwd test **关键！！！！**分别进入test 用户和 recv用户，默认家目录在/home/test 和/home/recv下。创建用于保存邮件的目录 [test@mail ~]$ mkdir -p mail/.imap/INBOX [recv@mail ~]$ mkdir -p mail/.imap/INBOX 最后重启postfix和dovacot服务 systemctl restart postfix systemctl restart dovacot 邮件发送和接收测试 windows 上安装foxmail。 1、发送用户配置 邮件类型：pop3 账号：test@lee.com 收件服务器： 192.168.1.89 端口110 ssl不勾选 发送服务器： 192.168.1.89 端口25 ssl不勾选 2.接收用户配置 邮件类型：pop3 账号：recv@lee.com 收件服务器： 192.168.1.89 端口110 ssl不勾选 发送服务器： 192.168.1.89 端口25 ssl不勾选 最后使用test 用户发送邮件，用recv用户接收邮件。 ","date":"2023-02-10","objectID":"/centos%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/:0:3","tags":["centos7"],"title":"centos搭建内网邮件服务","uri":"/centos%E6%90%AD%E5%BB%BA%E5%86%85%E7%BD%91%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"categories":["网站"],"content":"二级域名创建与部署 ","date":"2023-01-24","objectID":"/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/:1:0","tags":["域名"],"title":"二级域名创建与部署","uri":"/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/"},{"categories":["网站"],"content":"首先你需要拥有一个顶级域名 我是在namesoli 购买的域名。可以查看该顶级域名能够创建二级域名最大数量。 登录账户，点击account Domains。 可以看到我们购买的域名，然后点击域名，进入域名控制台。 可以看到子域名转发选项，点击它。进入子域名配置界面。 点击help按钮，可以看到当前我们购买的顶级域名最多能够创建50个子域名。 二级域名（子域名）的格式 比如我的网站是www.haipengv.com,可以通过访问blog.haipengv.com查看我的博客。在haipengv.com前面用.隔开加任意字符就是二级域名的格式。 ","date":"2023-01-24","objectID":"/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/:1:1","tags":["域名"],"title":"二级域名创建与部署","uri":"/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/"},{"categories":["网站"],"content":"部署烟花网站 首先在github上部署项目 登录github ，创建一个公开的新仓库。 复制仓库的ssh地址，一会连接库时需要。 准备上传烟花代码，在本地创建一个文件夹E:\\fireworkshow。需要确保本地已经搭建好git环境。将烟花代码复制到E:\\fireworkshow内。创建一个新文件夹test并进入test文件夹。此时所在位置E:\\fireworkshow\\test。 将仓库代码同步到本地test目录内 git clone git@github.com:Smithkenny/fireworkshow.git 将E:\\fireworkshow\\test\\fireworkshow文件夹内的所有文件复制到E:\\fireworkshow。然后删除空文件夹test和fireworkshow。 运行以下命令 git add . git commit -m \"上传代码测试\" git push origin main 这里注意我们默认创建的仓库主分支是main。 代码上传完毕后，此时还不能访问。 我这里使用cloudflare做一条域名解析。 登录cloudflare ，找到DNS选项，添加一条A记录。指向一个ipv4地址。这里的地址是ping 仓库域名得来的。 2023.haipengv.com–\u003eipv4地址 添加好A记录后，回到仓库，点击settings，找到pages选项，配置我们二级域名。稍等十分钟左右，就可以通过二级域名2023.haipengv.com访问我们的网站了。 遇到的问题 网站中音乐文件很大，超过2M，音乐加载超时，如何提升加载速度？ 解决办法 将大文件上传到网盘，复制网盘对应的文件路径，将该路径添加到index.html文件中。我这里用的是永硕网盘 。 最后访问2023.haipengv.com欣赏烟花吧！ 相关参考 https://blog.wangriyu.wang/2018/01-githubpage.html ","date":"2023-01-24","objectID":"/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/:1:2","tags":["域名"],"title":"二级域名创建与部署","uri":"/%E4%BA%8C%E7%BA%A7%E5%9F%9F%E5%90%8D%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%83%A8%E7%BD%B2/"},{"categories":["linux"],"content":"centos7使用systemd管理程序 systemd的配置文件主要放在/usr/lib/systemd/system目录，也可能在/etc/systemd/system目录。 学习下sshd的系统配置文件写法： $cat sshd.service [Unit] Description=OpenSSH server daemon Documentation=man:sshd(8) man:sshd_config(5) After=network.target sshd-keygen.service Wants=sshd-keygen.service [Service] Type=forking PIDFile=/var/run/sshd.pid EnvironmentFile=/etc/sysconfig/sshd ExecStart=/usr/sbin/sshd $OPTIONS ExecReload=/bin/kill -HUP $MAINPID KillMode=process Restart=on-failure RestartSec=42s [Install] WantedBy=multi-user.target 简单解释下： [Unit] 区块：启动顺序与依赖关系。 Description：当前配置文件的描述信息。 Documentation：帮助信息。 After：表示当前服务是在那个服务后面启动，一般定义为网络服务启动后启动 Wants：表示 sshd.service 与 sshd-keygen.service 之间存在” 弱依赖” 关系，即如果”sshd-keygen.service” 启动失败或停止运行，不影响 sshd.service 继续执行。 [Service] 区块：启动行为 Type：定义启动类型。详细了解点此 。 PIDFile：服务的 pid 文件路径。 EnvironmentFile：指定当前服务依赖的环境参数文件。 ExecStart：定义启动进程时执行的命令。 ExecReload：重启服务时执行的命令 KillMode：定义 Systemd 如何停止 sshd 服务。 Restart：定义了 sshd 退出后，Systemd 的重启方式。 RestartSec：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待 42 秒。 [Install] 区块：定义如何安装这个配置文件，即怎样做到开机启动。 WantedBy：表示该服务所在的 Target。multi-user.target 表明当系统以多用户方式（默认的运行级别）启动时，这个服务需要被自动运行。 配置一个自己的系统服务 日常启动程序方式： ./etc/test/sipholeWatchDog/sipholeWatchDog 现在添加配置通过systemd来管理 vi /usr/lib/systemd/system/sipholeWatchDog.service 添加如下配置： [Unit] Description=sipholeWatchDog After= syslog.target network.target jtsec-firstrun.service [Service] Type=forking ExecStart=/etc/test/sipholeWatchDog/sipholeWatchDog UMask=0007 RestartSec=10 Restart=always [Install] WantedBy=multi-user.target 加载单元 systemctl daemon-reload 启动服务并查看服务状态 systemctl start sipholeWatchDog systemctl status sipholeWatchDog ● sipholeWatchDog.service - sipholeWatchDog Loaded: loaded (/usr/lib/systemd/system/sipholeWatchDog.service; enabled; vendor preset: disabled) Active: active (running) since 二 2023-01-03 11:10:57 CST; 14min ago Main PID: 22088 (sipholeWatchDog) CGroup: /system.slice/sipholeWatchDog.service ├─22088 /etc/test/sipholeWatchDog/sipholeWatchDog ├─22269 /etc/siphole/siphole_back -c /etc/siphole/siphole_back_5.conf └─22281 journalctl _PID=22269 -f 1月 03 11:24:59 video_back siphole_back[22269]: msp-P28181: 0:videoSrvId:00:RUN: MESSAGE: CmdType: RecordInfo Devices: 3301...001389 1月 03 11:25:03 video_back siphole_back[22269]: msp-P28181: 0:videoSrvId:00:Find Route ... 1月 03 11:25:03 video_back siphole_back[22269]: msp-P28181: 0:videoSrvId:00:RUN: MESSAGE: CmdType: RecordInfo Devices: 3301...001389 1月 03 11:25:11 video_back siphole_back[22269]: msp-P28181: 0:videoSrvId:00:Find Route ... 1月 03 11:25:11 video_back siphole_back[22269]: msp-P28181: 0:videoSrvId:00:RUN: MESSAGE: CmdType: RecordInfo Devices: 3301...001391 1月 03 11:25:12 video_back siphole_back[22269]: msp-P28181: 0:videoSrvId:00:Find Route ... 1月 03 11:25:12 video_back siphole_back[22269]: msp-P28181: 0:videoSrvId:00:RUN: MESSAGE: CmdType: RecordInfo Devices: 3301...001391 1月 03 11:25:13 video_back siphole_back[22269]: RUN:plugin/p28181.c 636:videoSrvId:00:Total devices flow: 20 bytes. 0 medias. 1月 03 11:25:14 video_back siphole_back[22269]: msp-P28181: 0:videoSrvId:00:Find Route ... 1月 03 11:25:14 video_back siphole_back[22269]: msp-P28181: 0:videoSrvId:00:RUN: MESSAGE: CmdType: RecordInfo Devices: 3301...001391 Hint: Some lines were ellipsized, use -l to show in full. 可以加入开机启动 systemctl enable sipholeWatchDog systemctl命令整理 显示所有单元状态 systemctl 或 systemctl list-units 只显示服务单元的状态 systemctl --type=service 验证 sshd 服务当前是否活动 systemctl is-active sshd 启动，停止和重启 sshd 服务 systemctl start sshd.service systemctl stop sshd.service systemctl restart sshd.service 重新加载配置 systemctl reload sshd.service 列出活动状态的所有服务单元 systemctl list-units --type=service 列出所有服务单元 systemctl list-units --type=service --all 查看所有的服务单元是否为开机自启 systemctl list-unit-files --type=service 列出依赖的单元 systemctl list-dependencies sshd 验证 sshd 服务是否开机启动 systemctl is-enabled sshd 关闭开机自启 systemctl disable network 启用 network 开机自启。 systemctl enable network systemd日志管理 systemd 提供了自己日志系统（logging system），称为 journal. 使用 systemd 日志，无需额外安装日志服务（syslog）。读取日","date":"2023-01-03","objectID":"/centos7%E4%BD%BF%E7%94%A8systemd%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F/:1:0","tags":["centos7"],"title":"centos7使用systemd管理程序","uri":"/centos7%E4%BD%BF%E7%94%A8systemd%E7%AE%A1%E7%90%86%E7%A8%8B%E5%BA%8F/"},{"categories":[2023],"content":"满天星 点我! ","date":"2023-01-01","objectID":"/%E7%83%9F%E8%8A%B12023/:1:0","tags":["满天星"],"title":"烟花2023","uri":"/%E7%83%9F%E8%8A%B12023/"},{"categories":["问题"],"content":"linux根分区满了处理方法 通过命令查看根分区内的大文件 du -sh /* 2\u003e/dev/null | sort -hr | head -3 如果上述命令执行后发现/var/占空间最大，那么在查找/var分区内的大文件，如： du -sh /var/* 2\u003e/dev/null | sort -hr | head -3 以此类推，最后找到那个大文件，删除或者采取其他措施（移动到替他路径）即可！ 注意：接业务报障，一般是因为应用程序配置错误，导致在/var/log目录下会生成很大的日志文件，进而导致/var分区使用了达到100%，这个可以临时将之前的log日志大文件移动到其他路径下，但后期还需要业务侧对应用配置进行优化才行。 ","date":"2022-12-28","objectID":"/linux%E6%A0%B9%E5%88%86%E5%8C%BA%E6%BB%A1%E4%BA%86%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/:1:0","tags":["linux"],"title":"linux根分区满了处理方法","uri":"/linux%E6%A0%B9%E5%88%86%E5%8C%BA%E6%BB%A1%E4%BA%86%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"},{"categories":["工具"],"content":"搭建rss订阅器 mkdir -p /data/freshrss docker run -d --name=freshrss -e PUID=1000 -e PGID=1000 -e TZ=Asia/Shanghai -p 8000:80 -v /data/freshrss:/config --restart unless-stopped freshrss/freshrss:latest ","date":"2022-12-02","objectID":"/%E6%90%AD%E5%BB%BArss%E8%AE%A2%E9%98%85%E5%99%A8/:1:0","tags":["docker"],"title":"搭建rss订阅器","uri":"/%E6%90%AD%E5%BB%BArss%E8%AE%A2%E9%98%85%E5%99%A8/"},{"categories":["问题"],"content":"dmesg时间显示问题 默认显示时间戳 # dmesg [24241362.110367] rmlog.sh (14746): drop_caches: 1 [24241362.120529] rmlog.sh (14746): drop_caches: 2 [24241362.218306] rmlog.sh (14746): drop_caches: 3 [24846165.362560] rmlog.sh (7364): drop_caches: 1 [24846165.371097] rmlog.sh (7364): drop_caches: 2 [24846165.463682] rmlog.sh (7364): drop_caches: 3 添加 -T参数，显示人类可以读懂的时间戳。 # dmesg -T [四 10月 20 00:01:10 2022] rmlog.sh (14746): drop_caches: 1 [四 10月 20 00:01:10 2022] rmlog.sh (14746): drop_caches: 2 [四 10月 20 00:01:10 2022] rmlog.sh (14746): drop_caches: 3 [四 10月 27 00:01:13 2022] rmlog.sh (7364): drop_caches: 1 [四 10月 27 00:01:13 2022] rmlog.sh (7364): drop_caches: 2 [四 10月 27 00:01:13 2022] rmlog.sh (7364): drop_caches: 3 ","date":"2022-12-02","objectID":"/dmesg%E6%97%B6%E9%97%B4%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/:1:0","tags":["dmesg"],"title":"dmesg命令时间显示问题","uri":"/dmesg%E6%97%B6%E9%97%B4%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"},{"categories":["问题"],"content":"前言 服务器安装pve后发现cpu占用率过高有点不正常，于是查其原因。 参考这个博主的文章。发现现象一致。 https://blog.csdn.net/jzz601264258/article/details/105850816 top查看cpu占用率 root@www:~# top top - 09:58:10 up 35 min, 2 users, load average: 8.00, 8.00, 7.09 Tasks: 220 total, 1 running, 219 sleeping, 0 stopped, 0 zombie %Cpu(s): 99.2 us, 0.8 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st MiB Mem : 15651.4 total, 8695.9 free, 6572.6 used, 382.9 buff/cache MiB Swap: 8192.0 total, 8192.0 free, 0.0 used. 8748.4 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1334 root 20 0 3375880 5092 4 S 800.0 0.0 255:49.67 kswapd0 1 root 20 0 166460 10756 7720 S 0.0 0.1 0:01.27 systemd 发现kswapd0进程cpu使用率高达800%。我的服务器配置是8核16G。 详细查看该进程下的所有线程 root@www:~# top -Hp 1334 top - 09:58:39 up 35 min, 2 users, load average: 8.05, 8.01, 7.13 Threads: 14 total, 8 running, 6 sleeping, 0 stopped, 0 zombie %Cpu(s): 99.6 us, 0.4 sy, 0.0 ni, 0.0 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st MiB Mem : 15651.4 total, 8697.7 free, 6570.8 used, 382.9 buff/cache MiB Swap: 8192.0 total, 8192.0 free, 0.0 used. 8750.2 avail Mem PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1431 root 20 0 3375880 5092 4 R 99.9 0.0 32:23.46 kswapd0 1429 root 20 0 3375880 5092 4 R 99.7 0.0 32:21.50 kswapd0 1433 root 20 0 3375880 5092 4 R 99.7 0.0 32:23.20 kswapd0 1434 root 20 0 3375880 5092 4 R 99.7 0.0 32:22.80 kswapd0 1432 root 20 0 3375880 5092 4 R 99.3 0.0 32:22.95 kswapd0 1430 root 20 0 3375880 5092 4 R 99.0 0.0 32:21.44 kswapd0 1435 root 20 0 3375880 5092 4 R 99.0 0.0 32:23.55 kswapd0 1436 root 20 0 3375880 5092 4 R 99.0 0.0 32:23.23 kswapd0 1334 root 20 0 3375880 5092 4 S 0.0 0.0 0:00.15 kswapd0 1335 root 20 0 3375880 5092 4 S 0.0 0.0 0:00.84 kswapd0 1336 root 20 0 3375880 5092 4 S 0.0 0.0 0:00.00 kswapd0 1337 root 20 0 3375880 5092 4 S 0.0 0.0 0:00.00 kswapd0 1338 root 20 0 3375880 5092 4 S 0.0 0.0 0:00.00 kswapd0 1339 root 20 0 3375880 5092 4 S 0.0 0.0 0:00.00 kswapd0 于是查看系统外部链接 root@www:~# netstat -aplt Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:sunrpc 0.0.0.0:* LISTEN 1/init tcp 0 0 0.0.0.0:ssh 0.0.0.0:* LISTEN 1273/sshd: /usr/sbi tcp 0 0 localhost.localdom:smtp 0.0.0.0:* LISTEN 1129/master tcp 0 0 localhost.localdomai:85 0.0.0.0:* LISTEN 1280/pvedaemon tcp 0 1 www.pve.com:34882 45.9.148.99:https SYN_SENT 1305/rsync tcp 0 280 www.pve.com:ssh 192.168.1.110:49909 ESTABLISHED 2629/sshd: root@pts tcp 0 0 www.pve.com:54690 45.9.148.125:http ESTABLISHED 1334/./kswapd0 tcp 0 0 www.pve.com:ssh 192.168.1.182:3219 ESTABLISHED 1314/sshd: root@pts tcp6 0 0 [::]:sunrpc [::]:* LISTEN 1/init tcp6 0 0 [::]:ssh [::]:* LISTEN 1273/sshd: /usr/sbi tcp6 0 0 [::]:3128 [::]:* LISTEN 1295/spiceproxy tcp6 0 0 ip6-localhost:smtp [::]:* LISTEN 1129/master tcp6 0 0 [::]:8006 [::]:* LISTEN 1284/pveproxy 发现有两个外部IP正在和本机通信。 使用www.ip138.com查看45.9.148.125 、45.9.148.99IP，归属地是荷兰。如此便确定了是挖矿程序。 查看kswapd0 和 rsync 进程对应的文件路径。 root@www:~# ls -l /proc/1334/exe lrwxrwxrwx 1 root root 0 Nov 16 10:00 /proc/1334/exe -\u003e /root/.configrc/a/kswapd0 root@www:~# ls -l /proc/1305/exe lrwxrwxrwx 1 root root 0 Nov 16 10:01 /proc/1305/exe -\u003e /usr/bin/perl 先把/root/.configrc 重命名为/root/configrc,并压缩一份拷贝到本机。然后删除该文件夹。 mv /root/.configrc /root/configrc tar -zcvf /root/configrc.tgz /root/configrc rm -rf /root/configrc 发现有定时任务定期执行该程序，即时服务器重启也会立即执行对应脚本。 root@www:~# crontab -l 1 1 */2 * * /root/.configrc/a/upd\u003e/dev/null 2\u003e\u00261 @reboot /root/.configrc/a/upd\u003e/dev/null 2\u003e\u00261 5 8 * * 0 /root/.configrc/b/sync\u003e/dev/null 2\u003e\u00261 @reboot /root/.configrc/b/sync\u003e/dev/null 2\u003e\u00261 0 0 */3 * * /tmp/.X25-unix/.rsync/c/aptitude\u003e/dev/null 2\u003e\u00261 清除定时任务。 回想现象发生的原因： root密码设置过于简单 参考了一篇文章https://www.cpci.dev/pve-cloud-init-and-cloud-image/下载了网上的云镜像虚拟机模板然后就中招了。 处理方式： 设置较复杂的root密码，追踪到挖矿进程对应的配置文件所在的文件夹，删除掉。重启服务器。 ","date":"2022-11-16","objectID":"/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B1%E4%BA%8Ekswapd0%E8%BF%9B%E7%A8%8B%E5%AF%BC%E8%87%B4%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8/:1:0","tags":["cpu爆满"],"title":"记一次由于kswapd0进程导致cpu占满","uri":"/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B1%E4%BA%8Ekswapd0%E8%BF%9B%E7%A8%8B%E5%AF%BC%E8%87%B4%E7%B3%BB%E7%BB%9F%E5%BC%82%E5%B8%B8/"},{"categories":["pve"],"content":"pve优化 ","date":"2022-11-11","objectID":"/pve%E4%BC%98%E5%8C%96/:0:1","tags":["pve"],"title":"pve优化","uri":"/pve%E4%BC%98%E5%8C%96/"},{"categories":["pve"],"content":"1.Proxmox VE(PVE)系统移除《无有效订阅》弹窗提示通知 Proxmox VE(PVE)系统安装完成后，输入账号密码登录系统后会有提示：无有效订阅，本文主要介绍如何去除此弹窗提示。 提示：无有效订阅 You do not have a valid subscription for this server. Please visit www.proxmox.com to get a list of available options. 形成此问题的主要原因是因为我们使用的是免费版Proxmox VE系统，所以每次登录后都会提示这个《无有效订阅》弹窗。 此教程演示系统环境为：Proxmox Virtual Environment 7.2 ，更新日期为：2022年11月10日，其他版本请参考本教程. 需要修改文件路径为：/usr/share/javascript/proxmox-widget-toolkit/proxmoxlib.js 修改之前请做好文件备份，防止误操作造成不可预知的错误。 解决方法 搜索关键词：Ext.Msg.show 将：Ext.Msg.show({修改为：Ext.Msg.noshow({ 文件修改后保存上传，执行 systemctl restart pveproxy 命令重启网页服务 root@pve:~# systemctl restart pveproxy 注销后登陆，使用 CTRL+F5 快捷键强制重新加载网页页面，或清理浏览器缓存（很多修改后没有反应的童学记得清缓存） 再次打开登陆 Proxmox VE系统控制台主界面，就没有弹窗提示了。 注意：此方法可能在升级 pve 后失效，失效后再修改即可。 ","date":"2022-11-11","objectID":"/pve%E4%BC%98%E5%8C%96/:0:2","tags":["pve"],"title":"pve优化","uri":"/pve%E4%BC%98%E5%8C%96/"},{"categories":["pve"],"content":"2.Proxmox VE更换apt源并更新软件包数据库 1、查看当前镜像源配置 cat /etc/apt/sources.list 2、查看当前pve版本 pveversion -v 3、注释默认配置，修改为中科大镜像源 nano /etc/apt/sources.list deb https://mirrors.ustc.edu.cn/debian bullseye main contrib deb https://mirrors.ustc.edu.cn/debian bullseye-updates main contrib deb https://mirrors.ustc.edu.cn/debian-security bullseye-security main contrib 4、注释proxmox企业版更新源 因为我们安装的是社区版，没有订阅企业版的服务，这个默认启用，所以会报错，使用时我们可以注释掉它。 nano /etc/apt/sources.list.d/pve-enterprise.list 5、运行 apt update 更新索引以生效 6、查看可以更新的包 apt list --upgradable 7、执行软件包数据库更新 apt update \u0026\u0026 apt upgrade -y 8、也可以在页面更新 pve-更新-刷新 ","date":"2022-11-11","objectID":"/pve%E4%BC%98%E5%8C%96/:0:3","tags":["pve"],"title":"pve优化","uri":"/pve%E4%BC%98%E5%8C%96/"},{"categories":["pve"],"content":"3.PVE更改安装时绑定的网卡 当服务器有多个网卡时，安装pve后，绑定的网卡非管理口网卡导致局域网中机器无法连接pve。此时需要更改pve安装时绑定的网卡。 root@www:~# ip a 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: eno1: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 3c:ec:ef:90:ea:96 brd ff:ff:ff:ff:ff:ff altname enp181s0f0 3: enp101s0f0: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 58:53:c0:64:19:94 brd ff:ff:ff:ff:ff:ff 4: eno2: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc mq master vmbr0 state UP group default qlen 1000 link/ether 3c:ec:ef:90:ea:97 brd ff:ff:ff:ff:ff:ff altname enp181s0f1 5: enp23s0f0: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 68:91:d0:6a:66:a6 brd ff:ff:ff:ff:ff:ff 6: enp101s0f1: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 58:53:c0:64:19:95 brd ff:ff:ff:ff:ff:ff 7: enp23s0f1: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 68:91:d0:6a:66:a7 brd ff:ff:ff:ff:ff:ff 8: enp182s0f0: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 68:91:d0:6a:66:a0 brd ff:ff:ff:ff:ff:ff 9: enp182s0f1: \u003cBROADCAST,MULTICAST\u003e mtu 1500 qdisc noop state DOWN group default qlen 1000 link/ether 68:91:d0:6a:66:a1 brd ff:ff:ff:ff:ff:ff 10: vmbr0: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 3c:ec:ef:90:ea:97 brd ff:ff:ff:ff:ff:ff inet 192.168.1.191/24 scope global vmbr0 valid_lft forever preferred_lft forever inet6 fe80::3eec:efff:fe90:ea97/64 scope link valid_lft forever preferred_lft forever 12: tap100i0: \u003cBROADCAST,MULTICAST,PROMISC,UP,LOWER_UP\u003e mtu 1500 qdisc pfifo_fast master vmbr0 state UNKNOWN group default qlen 1000 link/ether 2e:dd:9f:18:5d:41 brd ff:ff:ff:ff:ff:ff 由以上信息可知pve的虚拟网卡vmbr0是桥接到mac为3c:ec:ef:90:ea:97的网卡即eno2上，需要将vmbr0更改桥接到eno1上。 nano /etc/network/interfaces 原内容 auto lo iface lo inet loopback iface eno2 inet manual auto vmbr0 iface vmbr0 inet static address 192.168.1.191/24 gateway 192.168.1.254 bridge-ports eno2 bridge-stp off bridge-fd 0 iface enp101s0f0 inet manual iface enp101s0f1 inet manual iface enp23s0f0 inet manual iface enp23s0f1 inet manual iface eno2 inet manual iface enp182s0f0 inet manual iface enp182s0f1 inet manual 需要更改为 auto lo iface lo inet loopback iface eno1 inet manual auto vmbr0 iface vmbr0 inet static address 192.168.1.191/24 gateway 192.168.1.254 bridge-ports eno1 bridge-stp off bridge-fd 0 iface enp101s0f0 inet manual iface enp101s0f1 inet manual iface enp23s0f0 inet manual iface enp23s0f1 inet manual iface eno2 inet manual iface enp182s0f0 inet manual iface enp182s0f1 inet manual 重启机器 ","date":"2022-11-11","objectID":"/pve%E4%BC%98%E5%8C%96/:0:4","tags":["pve"],"title":"pve优化","uri":"/pve%E4%BC%98%E5%8C%96/"},{"categories":["pve"],"content":"4.pve中虚拟机无法关闭，解决方法。 删除虚拟机ID对应的配置文件 rm /var/lock/qemu-server/lock-102.conf #102是你的虚拟机编号 然后关闭虚拟机 qm stop 102 ","date":"2022-11-11","objectID":"/pve%E4%BC%98%E5%8C%96/:0:5","tags":["pve"],"title":"pve优化","uri":"/pve%E4%BC%98%E5%8C%96/"},{"categories":["pve"],"content":"5.centos7.9常用工具一键安装 yum -y install wget gcc gcc-c++ pcre pcre-devel zlib zlib-devel ruby openssl openssl-devel patch lsof unzip zip lrzsz bash-completion net-tools nmap-ncat ","date":"2022-11-11","objectID":"/pve%E4%BC%98%E5%8C%96/:0:6","tags":["pve"],"title":"pve优化","uri":"/pve%E4%BC%98%E5%8C%96/"},{"categories":["pve"],"content":"6.Proxmox VE 7.2 iso 镜像重置 pve root密码 u盘引导进入pve安装界面，选择Advanced Options。 选择 Debug mode 进入后发现默认在/路径下，继续按CTRL D，进入root@proxmox:/ 验证LVM并挂载 #查看VG，输出应该是有VG PVE vgs #查看LV，可以看到 data root lvs 激活VG vgchange -a y 挂载lvm mount /dev/mapper/pve-root /mnt chroot chroot /mnt 修改root密码，更改完成密码重启服务器 passwd root ","date":"2022-11-11","objectID":"/pve%E4%BC%98%E5%8C%96/:0:7","tags":["pve"],"title":"pve优化","uri":"/pve%E4%BC%98%E5%8C%96/"},{"categories":["pve"],"content":"7.Proxmox集群部分节点出现问号 决定pve上状态的服务是pvestat daemon，也就是pvestatd，因此查看它的运行状况，果然有问题！ root@www:~# service pvestatd status ● pvestatd.service - PVE Status Daemon Loaded: loaded (/lib/systemd/system/pvestatd.service; enabled; vendor preset: enabled) Active: failed (Result: signal) since Wed 2022-11-16 09:23:04 CST; 10min ago Process: 1146 ExecStart=/usr/bin/pvestatd start (code=killed, signal=KILL) CPU: 286ms Nov 16 09:23:03 www systemd[1]: Starting PVE Status Daemon... Nov 16 09:23:04 www systemd[1]: pvestatd.service: Control process exited, code=killed, status=9/KILL Nov 16 09:23:04 www systemd[1]: pvestatd.service: Failed with result 'signal'. Nov 16 09:23:04 www systemd[1]: Failed to start PVE Status Daemon. 重启该服务状态恢复正常 root@www:~# service pvestatd restart root@www:~# service pvestatd status ● pvestatd.service - PVE Status Daemon Loaded: loaded (/lib/systemd/system/pvestatd.service; enabled; vendor preset: enabled) Active: active (running) since Wed 2022-11-16 09:34:06 CST; 1s ago Process: 1510 ExecStart=/usr/bin/pvestatd start (code=exited, status=0/SUCCESS) Main PID: 1511 (pvestatd) Tasks: 1 (limit: 18701) Memory: 79.2M CPU: 851ms CGroup: /system.slice/pvestatd.service └─1511 pvestatd Nov 16 09:34:05 www systemd[1]: Starting PVE Status Daemon... Nov 16 09:34:06 www pvestatd[1511]: starting server Nov 16 09:34:06 www systemd[1]: Started PVE Status Daemon. ","date":"2022-11-11","objectID":"/pve%E4%BC%98%E5%8C%96/:0:8","tags":["pve"],"title":"pve优化","uri":"/pve%E4%BC%98%E5%8C%96/"},{"categories":["pve"],"content":"8.解决pve创建的虚拟机无法复制粘贴 配置xterm.js PVE创建虚拟机后默认只有novnc方法连接虚拟机，无法复制粘贴，很不方便，因此可以打开xterm.js的方式弥补此缺陷。 关闭 VM，并且新增 serial port 给 VM 在PVE Host 中用 qm 命令建立 serial port，假设我的 VM ID 是 100 qm set 100 -serial0 socket 重新开启 VM，用 dmesg 验证是否有 ttyS 出现。 dmesg | grep ttyS 如果出现如下代表有了 [ 3.521757] 00:04: ttyS0 at I/O 0x3f8 (irq = 4, base_baud = 115200) is a 16550A 接下来配置VM的grub，进入VM的ssh cd /etc/default/ vi grub 修改grub中的GRUB_CMDLINE_LINUX值 GRUB_CMDLINE_LINUX=\"quiet console=tty0 console=ttyS0,115200” 更新grub debian based update-grub redhat based grub2-mkconfig --output=/boot/grub2/grub.cfg 在虚拟机添加 /etc/init/ttyS0.conf 并添加如下 # ttyS0 - getty # # This service maintains a getty on ttyS0 from the point the system is # started until it is shut down again. start on stopped rc RUNLEVEL=[12345] stop on runlevel [!12345] respawn exec /sbin/getty -L 115200 ttyS0 vt102 设置自启动 systemctl enable serial-getty@ttyS0.service systemctl start serial-getty@ttyS0.service 重启VM，测试xterm，已经可以用。 官方文档如下：https://pve.proxmox.com/wiki/Serial_Terminal ","date":"2022-11-11","objectID":"/pve%E4%BC%98%E5%8C%96/:0:9","tags":["pve"],"title":"pve优化","uri":"/pve%E4%BC%98%E5%8C%96/"},{"categories":["linux"],"content":"centos7.9恢复旧网卡名称显示及网口乱序解决方法 换回旧版网卡名称 grubby --update-kernel=ALL --args=\"net.ifnames=0 biosdevname=0\" 修改/etc/sysconfig/network-scripts/中的网卡配置文件 [root@QZ network-scripts]# cat ifcfg-lan0 TYPE=\"Ethernet\" BOOTPROTO=\"static\" DEFROUTE=\"yes\" NAME=\"lan0\" DEVICE=\"lan0\" ONBOOT=\"yes\" IPADDR=192.168.242.130 NETWORK=255.255.255.0 GATEWAY=192.168.242.1 [root@QZ network-scripts]# cat ifcfg-lan1 TYPE=\"Ethernet\" BOOTPROTO=\"static\" DEFROUTE=\"yes\" NAME=\"lan1\" DEVICE=\"lan1\" ONBOOT=\"yes\" IPADDR=192.168.35.130 NETWORK=255.255.255.0 GATEWAY=192.168.35.2 DNS1=192.168.35.2 [root@QZ network-scripts]# cat ifcfg-lan2 TYPE=\"Ethernet\" BOOTPROTO=\"static\" DEFROUTE=\"yes\" NAME=\"lan2\" DEVICE=\"lan2\" ONBOOT=\"yes\" IPADDR=192.168.242.131 NETWORK=255.255.255.0 重启设备 reboot 带有光口的物理服务器经常会遇到网口乱序现象。解决方法： vi /etc/systemd/network/10-lan0.link [Match] MACAddress=00:0c:29:36:a6:c7 [Link] Name=lan0 vi /etc/systemd/network/11-lan1.link [Match] MACAddress=00:0c:29:36:a6:b3 [Link] Name=lan1 [Match] MACAddress=00:0c:29:36:a6:bd vi /etc/systemd/network/12-lan2.link [Link] Name=lan2 最后创建对应名称的网卡配置文件，重启设备。 ","date":"2022-11-01","objectID":"/centos7.9%E6%9B%B4%E6%8D%A2%E7%BD%91%E5%8D%A1%E5%90%8D%E7%A7%B0/:0:0","tags":["centos7"],"title":"centos7.9更换网卡名称","uri":"/centos7.9%E6%9B%B4%E6%8D%A2%E7%BD%91%E5%8D%A1%E5%90%8D%E7%A7%B0/"},{"categories":["linux"],"content":"将centos7网卡改回eth0显示 grubby --update-kernel=ALL --args=\"net.ifnames=0 biosdevname=0\" 实验环境–\u003enet.ifnames=0 物理环境dell—\u003ebiosdevname=0 net.ifnames=0 云环境——\u003e 默认都是eth0 eth1 修改网卡配置文件的名称 mv /etc/sysconfig/network-scripts/ifcfg-ens32 /etc/sysconfig/network-scripts/ifcfg-eth0 修改网卡配置文件中设备的名字 sed -i 's#ens32#eth0#g' /etc/sysconfig/network-scripts/ifcfg-eth0 重启设备 网卡配置实例 NAME=eth0 DEVICE=eth0 ONBOOT=yes BOOTPROTO=static IPADDR=192.168.1.192 NETMASK=255.255.255.0 GATEWAY=192.168.1.254 DNS1=114.114.114.114 TYPE=Ethernet 查看网卡信息 cat /proc/net/dev ","date":"2022-10-26","objectID":"/centos7%E7%BD%91%E5%8D%A1%E6%94%B9%E5%9B%9Eeth0%E6%98%BE%E7%A4%BA/:1:0","tags":["centos7"],"title":"centos7网卡改回eth0显示","uri":"/centos7%E7%BD%91%E5%8D%A1%E6%94%B9%E5%9B%9Eeth0%E6%98%BE%E7%A4%BA/"},{"categories":["工具"],"content":"rsyslog日志服务器搭建 rsyslog客户端：负责发送日志到远程日志服务器，支持udp,tcp,relp协议。 rsyslog服务端：负责接收客户端发来的日志并存储在本地，支持文件存储和数据库存储方式。 保存日志的路径格式为：源IP地址/设施名（日志类别）/年月.log。 安装rsyslog软件 yum install rsyslog -y 配置rsyslog.conf文件 开放514 tcp 和 udp 监听 # Provides UDP syslog reception $ModLoad imudp $UDPServerRun 514 # Provides TCP syslog reception $ModLoad imtcp $InputTCPServerRun 514 服务端核心配置 #### GLOBAL DIRECTIVES #### # Where to place auxiliary files $WorkDirectory /var/lib/rsyslog # Use default timestamp format $ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat ##这里是服务端添加的配置 begin # 使用 RemoteLogs 模板接收客户端的日志，保存到本地的/var/log/remote目录下，每台客户端的ip_年份_月份_日期的log $template RemoteLogs,\"/var/log/remote/%fromhost-ip%/%fromhost-ip%_%$YEAR%-%$MONTH%-%$DAY%.log\" # 所有服务所有级别的日志都记录 *.* ?RemoteLogs #服务端本机的日志不记录 :fromhost-ip, !isequal, \"127.0.0.1\" ?Remote #指示rsyslog在将消息写入文件后停止处理消息，如果不包含\"\u0026 ~\",则消息将被写入本地文件，导致消息被记录2次。 \u0026 ~ ## 这里是服务端添加的配置 end 重启rsyslog服务 systemctl restart rsyslog 最后到配置目录下查看是否有日志生成 [root@localhost 127.0.0.1]# ll total 4 -rw------- 1 root root 1639 Oct 25 10:01 127.0.0.1_2022-10-25.log [root@localhost 127.0.0.1]# pwd /var/log/remote/127.0.0.1 rsyslog客户端配置 表示将用户登录日志和定时任务日志发送到192.168.1.74的514端口，默认采用TCP进行发送。 vi /etc/rsyslog.conf ###rule for 192.168.1.74 ### auth.*;authpriv.*;cron.* @@192.168.1.74:514 ","date":"2022-10-25","objectID":"/rsyslog%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/:1:0","tags":["rsyslog"],"title":"rsyslog日志服务器搭建","uri":"/rsyslog%E6%97%A5%E5%BF%97%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"安装inxi $ sudo apt-get install inxi [On Debian/Ubuntu/Linux Mint] $ sudo yum install inxi [On CentOs/RHEL/Fedora] $ sudo dnf install inxi [On Fedora 22+] 查看 Inxi 所有依赖和推荐的应用，以及各种目录，并显示需要安装哪些包来支持给定的功能。 $ inxi --recommends 输出如下 inxi will now begin checking for the programs it needs to operate. Check inxi --help or the man page (man inxi) to see what options are available. ------------------------------------------------------------------------------ Test: core tools: Perl version: 5.016003 Current shell: Default shell: bash sh links to: /usr/bin/bash Package manager: rpm ------------------------------------------------------------------------------ Test: required system directories: /proc: ........................................................... Present /sys: ............................................................ Present All required system directories are present ------------------------------------------------------------------------------ Test: recommended system programs: Note: IPMI sensors are generally only found on servers. To access that data, you only need one of the ipmi items. blockdev: --admin -p/-P (filesystem blocksize).................... Present bt-adapter: -E bluetooth data (if no hciconfig)................... Missing dig: -i wlan IP................................................... Present dmidecode: -M if no sys machine data; -m.......................... Present doas: -Dx hddtemp-user; -o file-user (alt for sudo)............... Missing fdisk: -D partition scheme (fallback)............................. Present file: -o unmounted file system (if no lsblk)...................... Present fruid_print: -M machine data, Elbrus only......................... Missing hciconfig: -E bluetooth data (deprecated, good report)............ Present hddtemp: -Dx show hdd temp, if no drivetemp module................ Present ifconfig: -i ip LAN (deprecated).................................. Present ip: -i ip LAN..................................................... Present ipmitool: -s IPMI sensors (servers)............................... Present ipmi-sensors: -s IPMI sensors (servers)........................... Present lsblk: -L LUKS/bcache; -o unmounted file system (best option)..... Present lsusb: -A usb audio; -J (optional); -N usb networking............. Present lvs: -L LVM data.................................................. Missing mdadm: -Ra advanced mdraid data................................... Missing modinfo: Ax; -Nx module version................................... Present runlevel: -I fallback to Perl..................................... Present sensors: -s sensors output........................................ Present smartctl: -Da advanced data....................................... Missing strings: -I sysvinit version...................................... Present sudo: -Dx hddtemp-user; -o file-user (try doas!).................. Present tree: --debugger 20,21 /sys tree.................................. Missing upower: -sx attached device battery info.......................... Present uptime: -I uptime................................................. Present The following recommended system programs are missing: Program: bt-adapter ~ Install package: bluez-tools Program: doas ~ Install package: doas Program: fruid_print ~ Install package: N/A Program: lvs ~ Install package: lvm2 Program: mdadm ~ Install package: mdadm Program: smartctl ~ Install package: smartmontools Program: tree ~ Install package: tree ------------------------------------------------------------------------------ Test: recommended display information programs: glxinfo: -G (X) glx info.......................................... Present wmctrl: -S active window manager (fallback)....................... Present xdpyinfo: -G (X) Screen resolution, dpi; -Ga Screen size.......... Present xprop: -S (X) desktop data........................................ Present xrandr: -G (X) monitors(s) resolution; -Ga monitor data........... Present All recom","date":"2022-10-21","objectID":"/%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%B7%A5%E5%85%B7-inxi/:1:0","tags":["硬件信息获取工具inxi"],"title":"功能强大的硬件信息获取工具-inxi","uri":"/%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84%E7%A1%AC%E4%BB%B6%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%E5%B7%A5%E5%85%B7-inxi/"},{"categories":["工具"],"content":"VSFTP不同用户拥有不同权限 ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:0:1","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"安装篇 操作系统环境 centos 7.9 mini 安装vsftp服务 yum install –y vsftpd ftp –安装 systemctl start vsftpd.service –启动 systemctl enable vsftpd.service –开机自启 vi /etc/selinux/conf SELINUX=enforce 改成 SELINUX=disabled getenforce - 查看是否为Disabled ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:1:0","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"实现篇 ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:0","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"1.要实现的功能 admin_root：/home/download/下的所有文件夹及文件具有上传、下载、删除权限 admin_001：/home/download/admin_001/下的文件具有上传、下载、删除权限 download_root：/home/download/下的所有文件夹及文件具有下载权限 download_001：/home/download/admin_001/下的文件具有下载权限 ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:1","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"2.首先创建一个本地系统用户abcde并指定其家目录，并建立相应的子目录 useradd -d /home/download abcde -s /sbin/nologin mkdir -p /home/download/admin_001 chown -R abcde: /home/download chmod 755 /home/download chmod 755 /home/download/* ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:2","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"3.创建用户数据文件：（一行账号一行密码，不要有空行，不要有空格） 所有密码此处示例设为123456。 vim /etc/vsftpd/userlist.txt admin_root 123456 admin_001 123456 download_root 123456 download_001 123456 然后生成数据文件 db_load：一般系统都有安装，db4，db4-devel，db4-utils ，如果没有的话可以安装： yum -y install db4* db_load -T -t hash -f /etc/vsftpd/userlist.txt /etc/vsftpd/userlist.db 4、修改pam配置 vim /etc/pam.d/vsftpd 将原来的全部注释掉，加入 auth sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/userlist account sufficient /lib64/security/pam_userdb.so db=/etc/vsftpd/userlist 注意：db=/etc/vsftpd/userlist 后面的.db必须去掉，默认会自动匹配*.db文件， 这里只需要给数据文件名，就行了。 64位机需要使用lib64（这里折腾了好久，有的是lib有的是lib64）; ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:3","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"5、创建本地系统用户abcde对应的虚拟账户 虚拟用户需要通过本地系统用户来实现各种操作,因此要放在系统用户的同名文件夹下。 mkdir -p /etc/vfstpd/abcde cd /etc/vfstpd/abcde 每一个虚拟用户都要有一个同名的文件，文件里记载其权限以及可操作的目录； 本例如下执行，两个»和«之间不要有空格 创建有上传下载权限的用户 cat \u003e\u003eadmin_root\u003c\u003cEOF anon_world_readable_only=NO write_enable=YES anon_mkdir_write_enable=YES anon_upload_enable=YES anon_other_write_enable=YES local_root=/home/download EOF cat \u003e\u003eadmin_001\u003c\u003cEOF anon_world_readable_only=NO write_enable=YES anon_mkdir_write_enable=YES anon_upload_enable=YES anon_other_write_enable=YES local_root=/home/download/admin_001 EOF 创建只有下载权限的用户 cat \u003e\u003edownload_root\u003c\u003cEOF anon_world_readable_only=NO local_root=/home/download EOF cat \u003e\u003edownload_001\u003c\u003cEOF anon_world_readable_only=NO local_root=/home/download/admin_001 EOF ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:4","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"6、设置配置文件vsftpd.conf vim /etc/vsftpd/vsftpd.conf 修改内容如下： listen=YES connect_from_port_20=YES anonymous_enable=NO local_enable=YES write_enable=NO anon_upload_enable=NO anon_mkdir_write_enable=NO anon_other_write_enable=NO chroot_local_user=YES chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_list guest_enable=YES guest_username=abcde virtual_use_local_privs=YES allow_writeable_chroot=YES pam_service_name=vsftpd user_config_dir=/etc/vsftpd/abcde local_umask=022 xferlog_enable=YES xferlog_file=/var/log/vsftpd.log pasv_promiscuous=YES touch /etc/vsftp/chroot_list 里面啥也不写。 ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:5","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"7、重新启动vsftpd service vsftpd restart ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:6","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"8.测试 所有用户只能进入自己家目录不能进入上一级目录； admin_root对于/home/download下的所有文件夹具有上传、下载、删除权限； admin_001对于/home/download/下的同名文件夹具有上传、删除权限，无其他权限； download_root对于/home/download下的所有文件夹具有下载权限，不能上传或删除任何内容，不能对其他任何文件夹操作； download_001对于/home/download/下的admin_001文件夹分别具有下载权限，不能上传或删除任何内容，不能对其他任何文件夹操作。 ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:7","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"9.日常维护 （1）更新帐号，先修改userlist.txt，再执行db_load db_load -T -t hash -f /etc/vsftpd/userlist.txt /etc/vsftpd/userlist.db （2）更新/etc/vsftpd/abcde/下不同用户对应的权限 （3）重启vsftpd systemctl start vsftpd.service ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:8","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"10.加密连接 生成证书 openssl req -x509 -nodes -days 365 -newkey rsa:1024 \\ -keyout /etc/vsftpd/vsftpd.pem \\ -out /etc/vsftpd/vsftpd.pem 其中\"-days 365\"声明证书的有效期是一年。 接下来的过程需要你输入一些相关的国家，地区，位置，组织名称，common name等信息。 回答这些信息以后系统会将生成完的证书vsftpd.pem文件保存在/etc/vsftpd目录下。 修改/etc/vsftpd/vsftpd.conf文件,增加以下内容 ssl_enable=YES allow_anon_ssl=NO force_local_data_ssl=NO force_local_logins_ssl=NO ssl_tlsv1=YES ssl_sslv2=NO ssl_sslv3=NO rsa_cert_file=/etc/vsftpd/vsftpd.pem 如果设置force_local_logins_ssl=YES，那么会强制用户登录时采用支持TLS/SSL认证的ftp客户端。如果设置为NO的话，则用户可以选择使用ssl加密或者不加密。 此时选择不加密登录会有失败提示 Non-anonymous sessions must use encryption. 重启服务 systemctl restart vsftpd 修改为其他端口 listen_port=10021 ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:9","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["工具"],"content":"vsftpd 425 Security: Bad IP connecting解决方法 问题分析: FTP客户端软件连接vsftpd服务报此错误，大概原因是在连接中变换了IP地址。 问题解决 服务端添加： vi /etc/vsftpd/vsftpd.conf pasv_promiscuous=YES 重启服务 systemctl restart vsftpd pasv_promiscuous选项参数说明 此选项激活时，将关闭PASV模式的安全检查。该检查确保数据连接和控制连接是来自同一个IP地址。小心打开此选项。此选项唯一合理的用法是存在于由安全隧道方案构成的组织中。默认值为NO。 合理的用法是：在一些安全隧道配置环境下，或者更好地支持FXP时(才启用它)。 FTP模式与数据端口 FTP 分为两类，PORT FTP和PASV FTP，PORT FTP是一般形式的FTP。这两种FTP在建立控制连接时操作是一样的，都是由客户端首先和FTP服务器的控制端口(默认值为21)建立控制链接，并通过此链接进行传输操作指令。它们的区别在于使用数据传输端口(ftp- data)的方式。PORT FTP由FTP服务器指定数据传输所使用的端口，默认值为20。PASV FTP由FTP客户端决定数据传输的端口。 PASV FTP这种做法，主要是考虑到存在防火墙的环境下，由客户端与服务器进行沟通(客户端向服务器发出数据传输请求中包含了数据传输端口)，决定两者之间的数据传输端口更为方便一些。 ","date":"2022-10-15","objectID":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/:2:10","tags":["vsftp"],"title":"VSFTP不同用户拥有不同权限","uri":"/vsftp%E4%B8%8D%E5%90%8C%E7%94%A8%E6%88%B7%E6%8B%A5%E6%9C%89%E4%B8%8D%E5%90%8C%E6%9D%83%E9%99%90/"},{"categories":["linux"],"content":"Linux小技巧汇总 ","date":"2022-10-08","objectID":"/linux%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/:0:1","tags":["linux小技巧"],"title":"linux小技巧汇总","uri":"/linux%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"},{"categories":["linux"],"content":"1.超时不操作自动退出登录TMOUT vi /etc/profile 最后一行加上 TMOUT=90 退出当前用户使配置生效 exit 重新登录 查看是否生效 set | grep -i tmout TMOUT=90 生效了！！！不操作等待90s会自动退出当前用户！！ 如何取消呢？ 只要将/etc/profile文件中TMOUT=90删除，然后退出使之生效。再次测试即可。 ","date":"2022-10-08","objectID":"/linux%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/:0:2","tags":["linux小技巧"],"title":"linux小技巧汇总","uri":"/linux%E5%B0%8F%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB/"},{"categories":["工具"],"content":"将时间戳转换为指定格式 ","date":"2022-09-15","objectID":"/%E4%BD%BF%E7%94%A8sed%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E7%BD%91%E5%9D%80/:0:1","tags":["sed"],"title":"使用sed批量修改网址","uri":"/%E4%BD%BF%E7%94%A8sed%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E7%BD%91%E5%9D%80/"},{"categories":["工具"],"content":"文本如下 https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article1.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article2.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article3.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article4.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article5.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article6.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article7.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article8.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article9.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article10.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article11.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article12.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/article13.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/animal.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/blue.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/cat.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/coffee.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/finch.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/lighthouse.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/nature.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/soda-water.jpg https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img/swan.jpg 将https://fastly.jsdelivr.net都修改为https://qq.com sed -i -e \"s/https:\\/\\/fastly.jsdelivr.net/https:\\/\\/qq.com/\" img.txt 结果如下： https://qq.com/gh/Smithkenny/Myimage/img/article1.jpg https://qq.com/gh/Smithkenny/Myimage/img/article2.jpg https://qq.com/gh/Smithkenny/Myimage/img/article3.jpg https://qq.com/gh/Smithkenny/Myimage/img/article4.jpg https://qq.com/gh/Smithkenny/Myimage/img/article5.jpg https://qq.com/gh/Smithkenny/Myimage/img/article6.jpg https://qq.com/gh/Smithkenny/Myimage/img/article7.jpg https://qq.com/gh/Smithkenny/Myimage/img/article8.jpg https://qq.com/gh/Smithkenny/Myimage/img/article9.jpg https://qq.com/gh/Smithkenny/Myimage/img/article10.jpg https://qq.com/gh/Smithkenny/Myimage/img/article11.jpg https://qq.com/gh/Smithkenny/Myimage/img/article12.jpg https://qq.com/gh/Smithkenny/Myimage/img/article13.jpg https://qq.com/gh/Smithkenny/Myimage/img/animal.jpg https://qq.com/gh/Smithkenny/Myimage/img/blue.jpg https://qq.com/gh/Smithkenny/Myimage/img/cat.jpg https://qq.com/gh/Smithkenny/Myimage/img/coffee.jpg https://qq.com/gh/Smithkenny/Myimage/img/finch.jpg https://qq.com/gh/Smithkenny/Myimage/img/lighthouse.jpg https://qq.com/gh/Smithkenny/Myimage/img/nature.jpg https://qq.com/gh/Smithkenny/Myimage/img/soda-water.jpg https://qq.com/gh/Smithkenny/Myimage/img/swan.jpg ","date":"2022-09-15","objectID":"/%E4%BD%BF%E7%94%A8sed%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E7%BD%91%E5%9D%80/:0:2","tags":["sed"],"title":"使用sed批量修改网址","uri":"/%E4%BD%BF%E7%94%A8sed%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E7%BD%91%E5%9D%80/"},{"categories":["编程"],"content":"将时间戳转换为指定格式 import time print(time.time()) # 生成当前日期的时间戳 1662602249.6098158 print(time.actime(1662602249.6098158)) #将时间戳转换成指定格式显示 ","date":"2022-09-08","objectID":"/%E4%BD%BF%E7%94%A8python%E5%AE%9E%E7%8E%B0unix%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2/:0:1","tags":["python"],"title":"使用python实现unix时间戳转换","uri":"/%E4%BD%BF%E7%94%A8python%E5%AE%9E%E7%8E%B0unix%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2/"},{"categories":["编程"],"content":"其他转换参考 https://www.cnblogs.com/pal-duan/p/10568829.html ","date":"2022-09-08","objectID":"/%E4%BD%BF%E7%94%A8python%E5%AE%9E%E7%8E%B0unix%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2/:0:2","tags":["python"],"title":"使用python实现unix时间戳转换","uri":"/%E4%BD%BF%E7%94%A8python%E5%AE%9E%E7%8E%B0unix%E6%97%B6%E9%97%B4%E6%88%B3%E8%BD%AC%E6%8D%A2/"},{"categories":["linux"],"content":"准备工作 k8s主机名 IP地址 系统版本号 k8s组件版本 CKS-master 10.4.7.180 ubuntu 20.04 1.24.4 CKS-node1 10.4.7.181 ubuntu 20.04 1.24.4 CKS-node2 10.4.7.182 ubuntu 20.04 1.24.4 ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:1","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"配置前准备 # 开root用户设置密码 sudo passwd root # 切换root用户 su - root # 更新 apt update # 安装ssh apt install ssh -y # 允许root用户远程登录 PermitRootLogin yes UseDNS no # 重启 systemctl restart ssh ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:2","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"配置域名 # 需要对应的机器执行如下命令 hostnamectl set-hostname CKS-master hostnamectl set-hostname CKS-node1 hostnamectl set-hostname CKS-node2 ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:3","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"域名解析 echo -e \"10.4.7.180 CKS-master\\n10.4.7.181 CKS-node1\\n10.4.7.182 CKS-node2\" \u003e\u003e /etc/hosts # 拷贝到远程集群机器 scp /etc/hosts root@10.4.7.181:/etc/ scp /etc/hosts root@10.4.7.182:/etc/ ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:4","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"初始化部分 # 关闭防火墙 systemctl stop ufw.service \u0026\u0026 systemctl disable ufw.service iptables -F iptables-save # 关闭swap swapoff -a sed -ri 's/.*swap.*/#\u0026/' /etc/fstab ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:5","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"vnc服务搭建（选做） # 安装vnc远程服务 apt install xfce4 xfce4-goodies -y # 选lightdm apt install tightvncserver -y # 设置远程密码 123qwe. # 开启远程发现空白 vncserver # 更改配置文件 mv .vnc/xstartup .vnc/xstartup.bak nano .vnc/xstartup #!/bin/bash xrdb $HOME/.Xresources startxfce4 \u0026 # 给权限 chmod +x .vnc/xstartup # 杀进程 vncserver -kill :2 # 再次启动远程 vncserver # 测试：用vncview连接 ip:2 ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:6","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"安装containerd ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"运行时Runc安装 # 下载二进制包 https://github.com/opencontainers/runc/releases/download/ wget https://github.com/opencontainers/runc/releases/download/v1.1.3/runc.amd64 # 执行Path和权限设置 mv runc.amd64 /usr/local/sbin/runc chmod +x /usr/local/sbin/runc ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:1","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"安装前准备 # 添加加载内核模块 cat \u003c\u003c EOF | sudo tee /etc/modules-load.d/containerd.conf overlay br_netfilter EOF # 加载内核模块 modprobe overlay modprobe br_netfilter #设置内核参数 cat \u003c\u003c EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward = 1 net.bridge.bridge-nf-call-ip6tables = 1 EOF # 应用内核参数 sysctl --system ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:2","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"开始安装 # 下载二进制包 https://github.com/containerd/containerd/releases/ wget https://github.com/containerd/containerd/releases/download/v1.6.8/containerd-1.6.8-linux-amd64.tar.gz # 解压 tar -zxvf containerd-1.6.8-linux-amd64.tar.gz # 执行文件放置系统Path mv ./bin/* /usr/local/bin/ # systemd 服务启动脚本文件配置 cat \u003e /lib/systemd/system/containerd.service \u003c\u003c EOF # Copyright The containerd Authors. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. [Unit] Description=containerd container runtime Documentation=https://containerd.io After=network.target local-fs.target [Service] ExecStartPre=-/sbin/modprobe overlay ExecStart=/usr/local/bin/containerd Type=notify Delegate=yes KillMode=process Restart=always RestartSec=5 # Having non-zero Limit*s causes performance problems due to accounting overhead # in the kernel. We recommend using cgroups to do container-local accounting. LimitNPROC=infinity LimitCORE=infinity LimitNOFILE=infinity # Comment TasksMax if your systemd version does not supports it. # Only systemd 226 and above support this version. TasksMax=infinity OOMScoreAdjust=-999 [Install] WantedBy=multi-user.target EOF ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:3","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"检测版本 runc -v ctr -v ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:4","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"启动、关闭服务及查看服务状态 systemctl start containerd systemctl restart containerd systemctl status containerd systemctl enable containerd ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:5","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"更换国内镜像仓库 mkdir -p /etc/containerd/ containerd config default | sudo tee /etc/containerd/config.toml 将 sandbox_image = \"k8s.gcr.io/pause:3.6\" 改为 sandbox_image = \"registry.aliyuncs.com/google_containers/pause:3.6\" 将 systemd_cgroup = false 改为 systemd_cgroup = true 重启containerd systemctl restart containerd ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:6","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"安装cni插件(选做) wget https://github.com/containernetworking/plugins/releases/download/v1.1.1/cni-plugins-linux-amd64-v1.1.1.tgz mkdir -p /opt/cni/bin tar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.1.1.tgz ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:7","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"安装三件套kubectl kubelet kubeadm apt-get update \u0026\u0026 apt-get install -y apt-transport-https curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - cat \u003c\u003cEOF \u003e/etc/apt/sources.list.d/kubernetes.list deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main EOF apt-get update # 查看可用版本 apt-cache madison kubelet apt-get install -y kubelet kubeadm kubectl systemctl enable kubelet # tab补全 apt-get install bash-completion source \u003c(kubectl completion bash) source \u003c(kubeadm completion bash) # 加到.bashrc 里 nano .bashrc source \u003c(kubeadm completion bash) source \u003c(kubectl completion bash) # 给crictl添加tab补全 source \u003c(crictl completion bash) # 加到.bashrc 里 nano .bashrc source \u003c(crictl completion bash) ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"运行crictl images 时报错 WARN[0000] image connect using default endpoints: [unix:///var/run/dockershim.sock unix:///run/containerd/containerd.sock unix:///run/crio/crio.sock unix:///var/run/cri-dockerd.sock]. As the default settings are now deprecated, you should set the endpoint instead. ERRO[0000] unable to determine image API version: rpc error: code = Unavailable desc = connection error: desc = \"transport: Error while dialing dial unix /var/run/dockershim.sock: connect: no such file or directory\" E0820 17:31:44.920882 5408 remote_image.go:121] \"ListImages with filter from image service failed\" err=\"rpc error: code = Unimplemented desc = unknown service runtime.v1alpha2.ImageService\" filter=\"\u0026ImageFilter{Image:\u0026ImageSpec{Image:,Annotations:map[string]string{},},}\" FATA[0000] listing images: rpc error: code = Unimplemented desc = unknown service runtime.v1alpha2.ImageService ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"排错 ll /run/containerd/ srw-rw---- 1 root root 0 Aug 20 17:20 containerd.sock= crictl config runtime-endpoint unix:///run/containerd/containerd.sock # 更改配置 nano /etc/crictl.yaml runtime-endpoint: \"unix:///run/containerd/containerd.sock\" image-endpoint: \"unix:///run/containerd/containerd.sock\" timeout: 10 # 重新加载 systemctl daemon-reload # 发现还是报错 E0820 17:37:56.265740 5708 remote_image.go:121] \"ListImages with filter from image service failed\" err=\"rpc error: code = Unimplemented desc = unknown service runtime.v1alpha2.ImageService\" filter=\"\u0026ImageFilter{Image:\u0026ImageSpec{Image:,Annotations:map[string]string{},},}\" FATA[0000] listing images: rpc error: code = Unimplemented desc = unknown service runtime.v1alpha2.ImageService # 这是因为还需要手动设置runtime_type nano /etc/containerd/config.toml [plugins.\"io.containerd.grpc.v1.cri\".containerd.default_runtime] 下的 runtime_type = \"\" 改成 runtime_type = \"io.containerd.runtime.v1.linux\" # 重启containerd systemctl daemon-reload systemctl restart containerd # 正常了 root@cks-master:~# crictl images IMAGE TAG IMAGE ID SIZE ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:2","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"集群初始化（cks-master上操作） kubeadm config print init-defaults \u003e init.yaml nano init.yaml advertiseAddress: 10.4.7.180 name: cks-master imageRepository: registry.aliyuncs.com/google_containers kubernetesVersion: 1.24.4 kubeadm init --config=init.yaml 各个节点加入集群 kubeadm join 10.4.7.180:6443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:96f4398d1e19fbaed92c0401a2d38031f89470dc1faf84669306c6d85ba8cc45 master 节点上输入以下命令，用kubectl 控制集群。 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 安装cni插件（calico） https://projectcalico.docs.tigera.io/getting-started/kubernetes/self-managed-onprem/onpremises # 小于50个node用这个连接 curl https://raw.githubusercontent.com/projectcalico/calico/v3.24.0/manifests/calico.yaml -O 更改calico.yaml 文件 nano 用ctrl+ w搜索。 - name: CALICO_IPV4POOL_CIDR value: \"10.96.0.0/12\" 开始创建 kubectl apply -f calico.yaml 等待慢慢创建pod kubectl get po -A 都running后集群搭建成功 root@cks-master:~# kubectl get po -A -w NAMESPACE NAME READY STATUS RESTARTS AGE kube-system calico-kube-controllers-5b97f5d8cf-glx5x 1/1 Running 0 15m kube-system calico-node-87vt9 1/1 Running 0 15m kube-system calico-node-dd8nk 1/1 Running 0 15m kube-system calico-node-jgmfk 1/1 Running 0 15m kube-system coredns-74586cf9b6-46xtt 1/1 Running 0 27m kube-system coredns-74586cf9b6-7jkkd 1/1 Running 0 27m kube-system etcd-cks-master 1/1 Running 0 27m kube-system kube-apiserver-cks-master 1/1 Running 0 27m kube-system kube-controller-manager-cks-master 1/1 Running 0 27m kube-system kube-proxy-dhgbc 1/1 Running 0 24m kube-system kube-proxy-pvkgx 1/1 Running 0 27m kube-system kube-proxy-zckg5 1/1 Running 0 24m kube-system kube-scheduler-cks-master 1/1 Running 0 27m 由于coredns都在被分配在同一个节点上，没冗余，需要重新分配在不同节点上。 root@cks-master:~# kubectl get po -A -owide | grep coredns kube-system coredns-74586cf9b6-46xtt 1/1 Running 0 30m 10.106.109.130 cks-node2 \u003cnone\u003e \u003cnone\u003e kube-system coredns-74586cf9b6-7jkkd 1/1 Running 0 30m 10.106.109.131 cks-node2 \u003cnone\u003e \u003cnone\u003e 重新分配coredns root@cks-master:~# kubectl -n kube-system rollout restart deployment coredns root@cks-master:~# kubectl get po -A -owide -w | grep coredns kube-system coredns-75ffbc4979-gjxjn 1/1 Running 0 2m37s 10.106.109.132 cks-node2 \u003cnone\u003e \u003cnone\u003e kube-system coredns-75ffbc4979-pbfmt 1/1 Running 0 2m37s 10.104.127.129 cks-node1 \u003cnone\u003e \u003cnone\u003e 延长证书有效期 证书默认1年后就会过期。可以通过如下方式修改为10年。 $ cd /etc/kubernetes/pki # 查看当前证书有效期 $ for i in $(ls *.crt); do echo \"===== $i =====\"; openssl x509 -in $i -text -noout | grep -A 3 'Validity' ; done $ mkdir backup_key; cp -rp ./* backup_key/ $ git clone https://github.com/yuyicai/update-kube-cert.git $ cd update-kube-cert/ $ bash update-kubeadm-cert.sh all # 重建管理服务 $ kubectl -n kube-system delete po kube-apiserver-k8s-master kube-controller-manager-k8s-master kube-scheduler-k8s-master ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:3","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["linux"],"content":"部署dashboard（k8s 可视化页面） github上搜索dashboard https://github.com/kubernetes/dashboard/blob/master/docs/user/installation.md 下载默认配置文件 https://raw.githubusercontent.com/kubernetes/dashboard/v2.6.1/aio/deploy/recommended.yaml 不用更改配置直接部署,等待部署完成。 kubectl apply -f recommended.yaml 默认部署后dashboard是ClusterIP 类型，只允许集群内部访问。 root@cks-master:~# kubectl -n kubernetes-dashboard get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE dashboard-metrics-scraper ClusterIP 10.96.205.151 \u003cnone\u003e 8000/TCP 14m kubernetes-dashboard ClusterIP 10.110.3.32 \u003cnone\u003e 443/TCP 14m 更改类型为NodePort，暴露端口，可以在集群外部访问。 root@cks-master:~# kubectl -n kubernetes-dashboard edit svc kubernetes-dashboard ports: - port: 443 protocol: TCP targetPort: 8443 nodePort: 30003 selector: k8s-app: kubernetes-dashboard sessionAffinity: None type: Nodeport 保存退出会自动重启pod 此时可以用ip+端口号形式访问dashboard. root@cks-master:~# kubectl -n kubernetes-dashboard get svc -w NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE dashboard-metrics-scraper ClusterIP 10.96.205.151 \u003cnone\u003e 8000/TCP 46m kubernetes-dashboard NodePort 10.110.3.32 \u003cnone\u003e 443:30003/TCP 46m https://10.4.7.180:30003 然后使用token来登录 登录前根据官方文档要先创建用户 官网说明 https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md admin.yaml apiVersion: v1 kind: ServiceAccount metadata: name: admin-user namespace: kubernetes-dashboard --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: admin-user roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: cluster-admin subjects: - kind: ServiceAccount name: admin-user namespace: kubernetes-dashboard 创建用户 kubectl apply -f admin.yaml 查看 root@cks-master:~# kubectl -n kubernetes-dashboard get sa NAME SECRETS AGE admin-user 0 66s default 0 56m kubernetes-dashboard 0 56m # 1.24版本已经默认不支持自动创建token，需要手动创建 root@cks-master:~# kubectl -n kubernetes-dashboard describe sa admin-user Name: admin-user Namespace: kubernetes-dashboard Labels: \u003cnone\u003e Annotations: \u003cnone\u003e Image pull secrets: \u003cnone\u003e Mountable secrets: \u003cnone\u003e Tokens: \u003cnone\u003e Events: \u003cnone\u003e 手动创建token root@cks-master:~# kubectl -n kubernetes-dashboard create token admin-user eyJhbGciOiJSUzI1NiIsImtpZCI6ImVlLTUwa0JWcm5seXlfemJ2Ui15MnpuTXJQVXctLXVPWFBsc3IzQl92dTAifQ.eyJhdWQiOlsiaHR0cHM6Ly9rdWJlcm5ldGVzLmRlZmF1bHQuc3ZjLmNsdXN0ZXIubG9jYWwiXSwiZXhwIjoxNjYxMDA4NzkzLCJpYXQiOjE2NjEwMDUxOTMsImlzcyI6Imh0dHBzOi8va3ViZXJuZXRlcy5kZWZhdWx0LnN2Yy5jbHVzdGVyLmxvY2FsIiwia3ViZXJuZXRlcy5pbyI6eyJuYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsInNlcnZpY2VhY2NvdW50Ijp7Im5hbWUiOiJhZG1pbi11c2VyIiwidWlkIjoiNmE3YWU1ODAtNDhiNi00NGVmLWFmNzUtNjY2MTQzOGUzMTcyIn19LCJuYmYiOjE2NjEwMDUxOTMsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDprdWJlcm5ldGVzLWRhc2hib2FyZDphZG1pbi11c2VyIn0.kvcfZmYX_CbX6_qaV1GQrT6Z7FCjGwOvG40OZ1cMEUhNQdV9G5XuCjSMJ4FrnKsiNOcSLv6_wdwWMZpWIgvbWYbBJQQ7Q-0Djie_iPzbGbJKbEvEsaNMLqIb7liiM52nKl0TJJweQpIoUHHWf0oRiGDjSkms5QVqDmlddnr5i8z2NotwW7FyIfml1E_OZFCQ-vHnVlo8ONGflkJyAutqGxRghBOBMuInMKSXfpk3AaXf6cjtButHRVqp_jDgErVVkKqtRJrqSHoDwMBV7NRn__fqdrfCGiEVKYlucMdv78TgKPsK2313OE3Arbrf0q_prP3Cs6VAILHETGdmhNHFlA 使用token登录dashboard 每次登录都需要重新创建token k8s 不能干什么？ 修改内核的应用 不建议部署数据库,很容易丢数据。 ","date":"2022-08-22","objectID":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:4","tags":["cks"],"title":"CKS初始环境搭建","uri":"/cks%E5%88%9D%E5%A7%8B%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"python多线程使用 创建线程，入口函数带参数 import threading import time print(\"*******主线程开始**********\") def f1(s): print(\"***********f1start***********\") time.sleep(s) print(\"***********f1end***********\") def f2(s): print(\"***********f2start***********\") time.sleep(s) print(\"***********f2end***********\") #创建线程 # target 指定这个先乘执行那个函数中的代码，只写函数名即可，不要写括号。 # args 后面指定的是一个元组， th1 = threading.Thread(target=f1, args=(2,)) th2 = threading.Thread(target=f2, args=(3,)) th1.start() th2.start() print(\"*******主线程结束**********\") 另外一种引入包的方式 from threading import Thread import time print(\"*******主线程开始**********\") def f1(s): print(\"***********f1start***********\") time.sleep(s) print(\"***********f1end***********\") def f2(s): print(\"***********f2start***********\") time.sleep(s) print(\"***********f2end***********\") #创建线程 # target 指定这个先乘执行那个函数中的代码，只写函数名即可，不要写括号。 # args 后面指定的是一个元组， th1 = Thread(target=f1, args=(2,)) th2 = Thread(target=f2, args=(3,)) th1.start() th2.start() print(\"*******主线程结束**********\") 设置等待 # 设置主线程等待子线程执行结束之后在执行 from threading import Thread import time print(\"*******主线程开始**********\") def f1(s): print(\"***********f1start***********\") time.sleep(s) print(\"***********f1end***********\") def f2(s): print(\"***********f2start***********\") time.sleep(s) print(\"***********f2end***********\") #创建线程 # target 指定这个先乘执行那个函数中的代码，只写函数名即可，不要写括号。 # args 后面指定的是一个元组， th1 = Thread(target=f1, args=(2,)) th2 = Thread(target=f2, args=(3,)) th1.start() th2.start() # 设置等待 th1.join() th2.join() print(\"*******主线程结束**********\") 共享内存 给线程上锁。 需求:用户zhangsan打车使用支付宝付钱，司机zhangsan收到钱。 分析：用户zhangsan付钱时，线程上锁，付完钱解锁。司机zhangsan账户线程上锁，收到前后解锁。 from threading import Thread, Lock from time import sleep # 存储支付宝余额账号 zhifubao = { 'zhangsan': 10000, 'liming': 5000, 'wanghong': 3000, 'zhaolei': 5000 } # 申请一把锁 zhifu_lock = Lock() # 线程1 ：嘀嘀打车处理，参数是用户账户和扣款金额 def thread1_didi_pay(account, amount): print('* t1: 即将开始操作') # 上锁 zhifu_lock.acquire() balance = zhifubao[account] # 下面的sleep(2)表示一些处理过程需要花上2秒钟 print('* t1: 完成交易需要2s钟') sleep(2) print('* t1: deduct') zhifubao[account] = balance - amount # 释放锁 zhifu_lock.release() # 线程2： 余额宝可以专区利息，参数是用户账户和扣款金额 def thread2_yue_pay(account,amount): print('* t2: 即将开始操作') # 上锁 zhifu_lock.acquire() balance = zhifubao[account] # 下面的sleep(2)表示一些处理过程需要花上2秒钟 print('* t2: 完成交易需要2s钟') sleep(2) print('* t2: deduct') zhifubao[account] = balance + amount # 释放锁 zhifu_lock.release() # 分别创建两个线程 t1 = Thread(target=thread1_didi_pay, args=('zhangsan', 2000)) t2 = Thread(target=thread2_yue_pay, args=('zhangsan', 2000)) # 开始线程 t1.start() t2.start() # 设置等待 t1.join() t2.join() # 输出账户余额 print(\"__________________________\") print(zhifubao[\"zhangsan\"]) ","date":"2022-08-21","objectID":"/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","tags":["python"],"title":"python多线程","uri":"/python%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["linux"],"content":"linux中的隔离技术 隔离的意义在于处于不同命名空间下的进程不能看到对方的信息。命名空间在Liunx内核中，不是一块分配，你可以定制隔离程度，比如只隔离网络，但不隔离进程ID空间。下面是命名空间可以隔离的七种类型。 名称 内核版本 隔离内容 UTS 3.0 主机名和域名 MNT 3.8 挂载点（文件系统） IPC 3.0 信号量、消息队列和共享内存 PID 3.8 进程编号 NET 3.0 网络设备、网络栈、端口等 USER 3.8 用户和用户组 Cgroup 4.6 以根的形式呈现出来 3.10.0内核支持6种类型的namespace [root@localhost ~]# ll /proc/$$/ns total 0 lrwxrwxrwx 1 root root 0 Oct 16 12:50 ipc -\u003e ipc:[4026531839] lrwxrwxrwx 1 root root 0 Oct 16 12:50 mnt -\u003e mnt:[4026531840] lrwxrwxrwx 1 root root 0 Oct 16 12:50 net -\u003e net:[4026531956] lrwxrwxrwx 1 root root 0 Oct 16 12:50 pid -\u003e pid:[4026531836] lrwxrwxrwx 1 root root 0 Oct 16 12:50 user -\u003e user:[4026531837] lrwxrwxrwx 1 root root 0 Oct 16 12:50 uts -\u003e uts:[4026531838] $$代表Shell本身的PID（ProcessID），即当前进程的PID。 而ubuntu 5.4.0内核的支持7种类型的namespace lrwxrwxrwx 1 root root 0 Oct 16 13:03 cgroup -\u003e 'cgroup:[4026531835]' lrwxrwxrwx 1 root root 0 Oct 16 13:03 ipc -\u003e 'ipc:[4026531839]' lrwxrwxrwx 1 root root 0 Oct 16 13:03 mnt -\u003e 'mnt:[4026531840]' lrwxrwxrwx 1 root root 0 Oct 16 13:03 net -\u003e 'net:[4026531992]' lrwxrwxrwx 1 root root 0 Oct 16 13:03 pid -\u003e 'pid:[4026531836]' lrwxrwxrwx 1 root root 0 Oct 16 13:51 pid_for_children -\u003e 'pid:[4026531836]' lrwxrwxrwx 1 root root 0 Oct 16 13:03 user -\u003e 'user:[4026531837]' lrwxrwxrwx 1 root root 0 Oct 16 13:03 uts -\u003e 'uts:[4026531838]' 上述六个文件分别代表对应namespace的文件描述符，中括号内对应其inode number 如果两个进程的inode number一致，说明这两个进程属于同一个namespace 如何创建一个PID namespace # --mount-proc 如何不带这个参数，ps aux 依然会读取主机其他进程 # -f --fork 让/bin/bash命令成为unshare的子进程 # -p --pid 代表pid命名空间 [root@bogon ~]# unshare --mount-proc -fp /bin/bash [root@bogon ~]# ps aux USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.0 115544 1992 pts/1 S 06:59 0:00 /bin/bash root 10 0.0 0.0 155472 1844 pts/1 R+ 06:59 0:00 ps aux REF https://blog.csdn.net/chenleiking/article/details/87915185 ","date":"2022-08-11","objectID":"/linux%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB/:0:0","tags":["linux隔离"],"title":"linux中的隔离技术","uri":"/linux%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB/"},{"categories":["工具"],"content":"shell中的EOF用法 EOF Shell中通常将EOF与«结合使用，表示后续的输入作为子命令或子shell的输入,直到遇到EOF为止，再返回到主shell。可以把EOF换成其他东西，意思是把内容当作标准输入传给程序。 当shell看到«的时候，他就会知道下一个词是一个芬姐符。在该分界符以后的内容都会被当作输入，直到shell又看到该分界符（位于单独的一行）。这个分界符可以是你所定义的任何字符串。 例子：自动登录mysql,查询mysql库中user表的所有内容。 mysql -uroot -p1qaz9ol. \u003c\u003cEoF use mysql; select * from user \\G; exit EOF 特殊用法： :\u003c\u003cCOMMENTBLOCK shell 脚本代码段 COMMENTBLOCK 用来注释整段脚本代码。:是shell中的空语句。其中COMMENTBLOCK 可以换成任何字符。 实例： #!/bin/bash echo start :\u003c\u003cCOMMENTBLOCK echo echo \"this is a test\" echo COMMENTBLOCK echo end 执行结果，中间部分不会执行。 start end cat 和eof结合使用具有追加功能 使用cat 和EOF多行输入 cat \u003e\u003e /root/test.txt \u003c\u003cEOF 123123123 hello world! EOF 以上的脚本命令是，在test.txt文件后面加上三行代码。 ","date":"2022-08-11","objectID":"/shell%E4%B8%AD%E7%9A%84eof%E7%94%A8%E6%B3%95/:0:0","tags":["shell"],"title":"shell中的EOF用法","uri":"/shell%E4%B8%AD%E7%9A%84eof%E7%94%A8%E6%B3%95/"},{"categories":["linux"],"content":"linux中环境变量 针对当前会话（重启失效） PATH=$PATH:/home/test/mysql/bin echo $PATH 针对当前用户有效（重启失效） vim ~/.bash_profile #更改，原行 PATH=$PATH:$HOME/bin， 改为下面的 PATH=$PATH:$HOME/bin:/home/test/mysql/bin #保存退出 source ~/.bash_profile #或者 . ~/.bash_profile #使之生效 /etc/profile/(永久生效) vim /etc/profile #在文档最后新增 MYSQL_HOME=/home/test/mysql export PATH=$PATH:$MYSQL_HOME/bin #保存退出 source ~/.bash_profile #或者 . ~/.bash_profile #使之生效 /etc/profile.d/ (永久生效)(推荐) vim /etc/profile.d/mysql.sh #添加如下内容 MYSQL_HOME=/home/test/mysql export PATH=$PATH:$MYSQL_HOME/bin #保存退出 source /etc/profile #或者 . /etc/profile #使之生效 Tips: 推荐原因：只需要更改自己的脚本，增加或删除就可以使环境变量发生改变，不影响系统文件。 ","date":"2022-08-10","objectID":"/linux%E4%B8%AD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/:0:0","tags":["环境变量"],"title":"linux中环境变量","uri":"/linux%E4%B8%AD%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"categories":["工具"],"content":"shell小练习 job1:检索本机的IP、NETMASK、MAC地址、广播地址 IP: 172.20.10.3 NetMask: 255.255.255.240 Broadcast: 172.20.10.15 MAC Address: 00:0c:29:8d:49:ea job2:将系统中所有普通用户的用户名、密码和默认shell保存到一个文件中，要求用户名密码和默认shell之间用tab分隔 ayitula x /bin/bash job3: 虚拟机中添加一块硬盘，盘号为sdb。主分区sdb3，543M，ext4格式。其他空间都分给拓展分区sdb4。逻辑分区sdb5，2G，逻辑分区sdb6，3G。 创建一个卷组，PE为16M，创建逻辑卷大小为2.5G，格式为xfs。 主分区sdb3自动挂载到/data/data1上，逻辑卷挂载到/data/data2上。 最后分别验证并输出挂载结果。 job4:编写脚本，清空job3内的所有配置，包括还原/etc/fstab文件。 job5:模拟登录系统。输入用户名、密码登录系统。 终端提示信息： Centos Linux 8 (Core) Kernal 5.4.0-113-generic on an x86_64 588c34fafcd5 login: smith Password: job6： 内存使用率统计，要求打印内存使用率。 内存使用率公式： 使用量/总量*100% job7: 实现一个四则运算计算器。要求用户传输三个参数，num1 算数运算符 num2 。运算输出结果。 job8: 写一个监控CPU 平均负载值的脚本。收集cpu load 平均负载值到数组，打印输出对应的负载值。 输出样式 CPU 1min平均负载为: 0.10 CPU 5min平均负载为: 0.16 CPU 15min平均负载为: 0.08 ","date":"2022-08-09","objectID":"/shell%E5%B0%8F%E7%BB%83%E4%B9%A0/:0:0","tags":["shell"],"title":"shell小练习","uri":"/shell%E5%B0%8F%E7%BB%83%E4%B9%A0/"},{"categories":["工具"],"content":"shell小练习答案 job1:检索本机的IP、NETMASK、MAC地址、广播地址 IP: 172.20.10.3 NetMask: 255.255.255.240 Broadcast: 172.20.10.15 MAC Address: 00:0c:29:8d:49:ea ifconfig eth0 | grep inet | tr -s \" \" | cut -d \" \" -f 3 | xargs echo \"IP: \" ifconfig eth0 | grep inet | tr -s \" \" | cut -d \" \" -f 5 | xargs echo \"NetMask: \" ifconfig eth0 | grep inet | tr -s \" \" | cut -d \" \" -f 7 | xargs echo \"Broadcast: \" ifconfig eth0 | grep ether | tr -s \" \" | cut -d \" \" -f 3 | xargs echo \"MAC Address: \" job2:将系统中所有普通用户的用户名、密码和默认shell保存到一个文件中，要求用户名密码和默认shell之间用tab分隔 ayitula x /bin/bash cat 1.txt | grep -i bash | grep -v \"root\" | cut -d \":\" -f 1,2,7 | tr -s \":\" \"\\t\" \u003e res # 1.txt 文本 root❌0:0:root:/root:/bin/bash bin❌1:1:bin:/bin:/sbin/nologin daemon❌2:2:daemon:/sbin:/sbin/nologin adm❌3:4:adm:/var/adm:/sbin/nologin lp❌4:7:lp:/var/spool/lpd:/sbin/nologin sync❌5:0:sync:/sbin:/bin/sync shutdown❌6:0:shutdown:/sbin:/sbin/shutdown halt❌7:0:halt:/sbin:/sbin/halt mail❌8:12:mail:/var/spool/mail:/sbin/nologin operator❌11:0:operator:/root:/sbin/nologin games❌12💯games:/usr/games:/sbin/nologin ftp❌14:50:FTP User:/var/ftp:/sbin/nologin nobody❌65534:65534:Kernel Overflow User:/:/sbin/nologin dbus❌81:81:System message bus:/:/sbin/nologin systemd-coredump❌999:997:systemd Core Dumper:/:/sbin/nologin systemd-resolve❌193:193:systemd Resolver:/:/sbin/nologin hello❌1500:1000:this is a test user:/home/hello:/bin/bash job3 disk_partition.sh #!/bin/bash fdisk /dev/sdb \u003c\u003cEOF n p 3 +543M n e 4 n l +2G n l +3G w EOF #2、创建逻辑卷 #2.1 创建物理卷 pvcreate /dev/sdb5 /dev/sdb6 #2.2 创建卷组 vgcreate -s 16M vg100 /dev/sdb{5..6} \u003c\u003cEOF y EOF #2.3 创建逻辑卷 lvcreate -L 2.5G -n lv100 vg100 \u003c\u003cEOF y EOF #3、格式化 mkfs.ext4 /dev/sdb3 mkfs.xfs /dev/vg100/lv100 #4、修改/etc/fstab,实现自动挂载 echo \"/dev/sdb3 /data/data1 ext4 defaults 0 0\" \u003e\u003e /etc/fstab echo \"/dev/vg100/lv100 /data/data2 xfs defaults 0 0\" \u003e\u003e /etc/fstab #5、挂载分区 mkdir -p /data/data{1..2} mount -a #6、验证并输出挂载结果 mount |grep \"/dev/sdb3\" test $? -eq 0\u0026\u0026echo \"/dev/sdb3 挂载成功\" || echo \"/dev/sdb3挂载失败\" ##注意检索的时候，mount输出中LV的表示方式，或者直接检索挂载点/data/data2也可以。 mount |grep \"vg100-lv100\" test $? -eq 0\u0026\u0026echo \"/dev/vg100/lv100 挂载成功\" || echo \"/dev/vg100/lv100挂载失败\" job4 back_init.sh #!/bin/bash umount /data/data1 umount /data/data2 vgremove vg100 \u003c\u003cEOF y y EOF pvremove /dev/sdb5 pvremove /dev/sdb6 fdisk /dev/sdb \u003c\u003cEOF d d d d w EOF sed -i '/^\\/dev\\/sdb3/'d /etc/fstab sed -i '/^\\/dev\\/vg100/'d /etc/fstab Tips: 使用EOF ,表示后续的输入作为子命令或子shell的输入，直到遇到EOF为止。再返回到主shell。 job5小练习答案： #!/bin/bash # #Author: Mr.Lee #Description: 仿真登陆 IP=`ifconfig eth0 | egrep -w \"inet\"| awk '{print $2}'` #清屏 clear #输出提示信息 echo \"Centos Linux 8 (Core)\" echo -e \"Kernal `uname -r` on an `uname -m`\" echo -e \"Web console: https://localhost:9000/ or https://$IP:9090/ \\n\" #交互输入登录名 echo -n \"$HOSTNAME login: \" read account #交互输入密码 read -s -t30 -p \"Password: \" pw echo job6: 分析： 1.获取内存总量 2.获取内存使用量 3.运算输出结果 #!/bin/bash #Author: Mr.lee #Release #Description: 内存使用率计算脚本 #获取内存总量 Mem_total=`free -m | grep Mem | awk '{print $2}'` #获取内存使用的量 Mem_used=`free -m | grep Mem | awk '{print $3}'` #计算输出 #浮点运算中：同优先级的情况下，大数除以小数 尽可能保证精确。先乘后除。 echo \"内存使用率: `echo \"scale=2;$Mem_used*100/$Mem_total\"|bc`%\" job7 : #!/bin/bash #Author: Mr.lee #Release #Description: 四则运算计算器 echo \"$1 $2 $3\" |bc job8 基本思路：截取uptime命令输出结果中最后3个数字，分别代表1min、5min、15min cpu的负载。 普通方法实现 #!/bin/bash #Author: Mr.Lee #Release: #Description: 打印cpu 1min 5min 15min的负载值 one_min=`uptime | tr -s \" \" | cut -d \",\" -f4 | cut -d \":\" -f2` five_min=`uptime | tr -s \" \" | cut -d \",\" -f5` fiveteen_min=`uptime | tr -s \" \" | cut -d \",\" -f6` echo -ne \"CPU 1min平均负载为: \"$one_min echo -ne \"\\nCPU 5min平均负载为: \"$five_min echo -ne \"\\nCPU 15min平均负载为: \"$fiveteen_min echo 使用数组实现 #!/bin/bash #Author: Mr.Lee #Release: #Description: 打印cpu 1min 5min 15min的负载值 cpu_load=(`uptime | tr -s \" \"| cut -d \" \" -f11-13| tr \",\" \" \"`) echo \"CPU 1min平均负载: ${cpu_load[0]}\" echo \"CPU 5min平均负载: ${cpu_load[1]}\" echo \"CPU 15min平均负载: ${cpu_load[2]}\" ","date":"2022-08-09","objectID":"/shell%E5%B0%8F%E7%BB%83%E4%B9%A0%E7%AD%94%E6%A1%88/:0:0","tags":["shell"],"title":"shell小练习答案","uri":"/shell%E5%B0%8F%E7%BB%83%E4%B9%A0%E7%AD%94%E6%A1%88/"},{"categories":["linux"],"content":"CentOS8配置yum源 将源文件备份 cd /etc/yum.repos.d/ \u0026\u0026 mkdir backup \u0026\u0026 mv *repo backup/ 下载yum源文件 curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo 修改yum源里面的地址 sed -i -e \"s|mirrors.cloud.aliyuncs.com|mirrors.aliyun.com|g \" /etc/yum.repos.d/CentOS-* sed -i -e \"s|releasever|releasever-stream|g\" /etc/yum.repos.d/CentOS-* 重新生成缓存 yum clean all \u0026\u0026 yum makecache ","date":"2022-08-08","objectID":"/centos8%E9%85%8D%E7%BD%AEyum%E6%BA%90/:0:0","tags":["centos8"],"title":"CentOS8配置yum源","uri":"/centos8%E9%85%8D%E7%BD%AEyum%E6%BA%90/"},{"categories":["编程"],"content":"豆瓣展示页 ","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:0","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"新建flask项目 使用pycharm新建flask项目，项目名为：douban_flask。 将之前的爬取的movie.db文件放到该项目的根目录下。准备前端页面代码（可以到模板之家下载[http://www.cssmoban.com/cssthemes/9296.shtml]） ","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:1","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"前端代码 下载后解压缩放到static目录下.static目录用于存放网页相关代码。 目录结构如下： douban_flask - static - assets - css - img - js - vendor - templates - test echarts.min.js index.html movie.html score.html team.html temp.html word.html - venv app.py movie.db testCloud.py 新建模板目录templates，在此目录下新建主页文件index.html.可以把temp.html中的内容复制一份到index.html。 ","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:2","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"flask路由 开始写路由app.py Tips:使用flask下render_template模块可以找到templates目录内的html页面。 from flask import Flask, render_template import sqlite3 app = Flask(__name__) @app.route('/') def index(): return render_template(\"index.html\") @app.route('/index') def home(): # return render_template(\"index.html\") return index() @app.route('/movie') def movie(): datalist = [] con = sqlite3.connect(\"movie.db\") cur = con.cursor() sql = \"select * from movie250\" data = cur.execute(sql) for item in data: datalist.append(item) cur.close() con.close() return render_template(\"movie.html\", movies = datalist) # return render_template(\"movie.html\") @app.route('/score') def score(): score = [] # 评分 num = [] # 每个评分所统计出的电影数量 con = sqlite3.connect(\"movie.db\") cur = con.cursor() sql = \"select score,count(score) from movie250 group by score\" data = cur.execute(sql) for item in data: score.append(str(item[0])) num.append(item[1]) cur.close() con.close() return render_template(\"score.html\", score=score, num=num) @app.route('/word') def word(): return render_template(\"word.html\") @app.route('/team') def team(): return render_template(\"team.html\") if __name__ == '__main__': app.run() 开始运行flask(可以开启Debug模式，好处是修改的代码会实时更新。关闭则需要重启运行后更改的代码才会生效。) 注意： 如果页面只显示文字，没有css效果也不显示图片，查看页面源代码。(谷歌浏览器：右键-\u003e检查)查看css样式 路径和图片路径是否正确。路径应该和我们的项目douban_flask目录结构一致。更改后，刷新浏览器再次查看效果。 显示正常后，我们需要展示5个页面，分别是首页、电影、评分、词云、团队。所以将index.html复制4份，分别修改里面的内容，展示对应的数据。对应关系如下： 首页 电影 评分 词云 团队 index.html movie.html score.html word.html team.html ","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:3","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"index 先做主页index.html，仔细观察源码发现网页的每一部分都有注释该模块的功能。由于代码太多，可以将同一种功能的代码折叠起来，使用的功能保留，不用的功能可以删除。最终index.html中代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"\u003e \u003ctitle\u003e豆瓣top250数据可视化\u003c/title\u003e \u003cmeta content=\"\" name=\"descriptison\"\u003e \u003cmeta content=\"\" name=\"keywords\"\u003e \u003c!-- Favicons --\u003e \u003clink href=\"static/assets/img/favicon.png\" rel=\"icon\"\u003e \u003clink href=\"static/assets/img/apple-touch-icon.png\" rel=\"apple-touch-icon\"\u003e \u003c!-- Google Fonts --\u003e \u003clink href=\"https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,600,600i,700,700i,900\" rel=\"stylesheet\"\u003e \u003c!-- Vendor CSS Files --\u003e \u003clink href=\"static/assets/vendor/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/icofont/icofont.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/boxicons/css/boxicons.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/animate.css/animate.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/venobox/venobox.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/aos/aos.css\" rel=\"stylesheet\"\u003e \u003c!-- Template Main CSS File --\u003e \u003clink href=\"static/assets/css/style.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- ======= Top Bar ======= --\u003e \u003c!-- ======= Header ======= --\u003e \u003cheader id=\"header\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"logo float-left\"\u003e \u003ch1 class=\"text-light\"\u003e\u003ca href=\"index\"\u003e\u003cspan\u003e豆瓣电影\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e \u003c!-- Uncomment below if you prefer to use an image logo --\u003e \u003c!-- \u003ca href=\"temp.html\"\u003e\u003cimg src=\"static/assets/img/logo.png\" alt=\"\" class=\"img-fluid\"\u003e\u003c/a\u003e--\u003e \u003c/div\u003e \u003cnav class=\"nav-menu float-right d-none d-lg-block\"\u003e \u003cul\u003e \u003cli class=\"active\"\u003e\u003ca href=\"/index\"\u003e首页 \u003ci class=\"la la-angle-down\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/movie\"\u003e电影\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/score\"\u003e评分\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/word\"\u003e词云\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/team\"\u003e团队\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e\u003c!-- .nav-menu --\u003e \u003c/div\u003e \u003c/header\u003e\u003c!-- End Header --\u003e \u003c!-- ======= Our Team Section ======= --\u003e \u003csection id=\"team\" class=\"team\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"section-title\"\u003e \u003ch2\u003e豆瓣电影top250数据分析\u003c/h2\u003e \u003cp\u003e应用Python爬虫Flask框架、Echarts、WordCloud等技术实现\u003c/p\u003e \u003c/div\u003e \u003c!-- ======= Counts Section ======= --\u003e \u003csection class=\"counts section-bg\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-lg-3 col-md-6 text-center\" data-aos=\"fade-up\"\u003e \u003ca href= \"/movie\"\u003e \u003cdiv class=\"count-box\"\u003e \u003ci class=\"icofont-simple-smile\" style=\"color: #20b38e;\"\u003e\u003c/i\u003e \u003cspan data-toggle=\"counter-up\"\u003e250\u003c/span\u003e \u003cp\u003e经典电影\u003c/p\u003e \u003c/div\u003e \u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-md-6 text-center\" data-aos=\"fade-up\" data-aos-delay=\"200\"\u003e \u003ca href= \"/score\"\u003e \u003cdiv class=\"count-box\"\u003e \u003ci class=\"icofont-document-folder\" style=\"color: #c042ff;\"\u003e\u003c/i\u003e \u003cspan data-toggle=\"counter-up\"\u003e1\u003c/span\u003e \u003cp\u003e评分统计\u003c/p\u003e \u003c/div\u003e \u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-md-6 text-center\" data-aos=\"fade-up\" data-aos-delay=\"400\"\u003e \u003ca href= \"/word\"\u003e \u003cdiv class=\"count-box\"\u003e \u003ci class=\"icofont-live-support\" style=\"color: #46d1ff;\"\u003e\u003c/i\u003e \u003cspan data-toggle=\"counter-up\"\u003e5693\u003c/span\u003e \u003cp\u003e词汇统计\u003c/p\u003e \u003c/div\u003e \u003c/a\u003e \u003c/div\u003e \u003cdiv class=\"col-lg-3 col-md-6 text-center\" data-aos=\"fade-up\" data-aos-delay=\"600\"\u003e \u003ca href= \"/team\"\u003e \u003cdiv class=\"count-box\"\u003e \u003ci class=\"icofont-users-alt-5\" style=\"color: #ffb459;\"\u003e\u003c/i\u003e \u003cspan data-toggle=\"counter-up\"\u003e4\u003c/span\u003e \u003cp\u003e团队成员\u003c/p\u003e \u003c/div\u003e \u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/section\u003e\u003c!-- End Counts Section --\u003e \u003c/div\u003e \u003c/section\u003e\u003c!-- End Our Team Section --\u003e \u003c!-- ======= Footer ======= --\u003e \u003cfooter id=\"footer\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"copyright\"\u003e \u0026copy; Copyright \u003cstrong\u003e\u003cspan\u003eMr.Lee\u003c/span\u003e\u003c/strong\u003e. All Rights Reserved \u003c/div\u003e \u003cdiv class=\"credits\"\u003e \u003c/div\u003e \u003c/div\u003e \u003c/footer\u003e\u003c!-- End Footer --\u003e \u003ca href=\"#\" class=\"back-to-top\"\u003e\u003ci class=\"icofont-simple-up\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c!-- Vendor JS Files --\u003e \u003cscript src=\"static/assets/vendor/jquery/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/bootstrap/js/bootstrap.bundle.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/jquery.easing/jquery.easing.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:4","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"movie movie.html电影页面需要连接之前准备好的数据库movie.db，读取里面的sql语句，并以表格的形式显示出来。 这里使用sqlite3模块来连接数据库。 实现功能代码见app.py中movie()函数 movie.html网页源码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"\u003e \u003ctitle\u003e豆瓣top250数据可视化\u003c/title\u003e \u003cmeta content=\"\" name=\"descriptison\"\u003e \u003cmeta content=\"\" name=\"keywords\"\u003e \u003c!-- Favicons --\u003e \u003clink href=\"static/assets/img/favicon.png\" rel=\"icon\"\u003e \u003clink href=\"static/assets/img/apple-touch-icon.png\" rel=\"apple-touch-icon\"\u003e \u003c!-- Google Fonts --\u003e \u003clink href=\"https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,600,600i,700,700i,900\" rel=\"stylesheet\"\u003e \u003c!-- Vendor CSS Files --\u003e \u003clink href=\"static/assets/vendor/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/icofont/icofont.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/boxicons/css/boxicons.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/animate.css/animate.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/venobox/venobox.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/aos/aos.css\" rel=\"stylesheet\"\u003e \u003c!-- Template Main CSS File --\u003e \u003clink href=\"static/assets/css/style.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- ======= Top Bar ======= --\u003e \u003c!-- ======= Header ======= --\u003e \u003cheader id=\"header\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"logo float-left\"\u003e \u003ch1 class=\"text-light\"\u003e\u003ca href=\"index\"\u003e\u003cspan\u003e豆瓣电影\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e \u003c!-- Uncomment below if you prefer to use an image logo --\u003e \u003c!-- \u003ca href=\"temp.html\"\u003e\u003cimg src=\"static/assets/img/logo.png\" alt=\"\" class=\"img-fluid\"\u003e\u003c/a\u003e--\u003e \u003c/div\u003e \u003cnav class=\"nav-menu float-right d-none d-lg-block\"\u003e \u003cul\u003e \u003cli class=\"active\"\u003e\u003ca href=\"/index\"\u003e首页 \u003ci class=\"la la-angle-down\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/movie\"\u003e电影\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/score\"\u003e评分\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/word\"\u003e词云\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/team\"\u003e团队\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e\u003c!-- .nav-menu --\u003e \u003c/div\u003e \u003c/header\u003e\u003c!-- End Header --\u003e \u003c!-- ======= Our Team Section ======= --\u003e \u003csection id=\"team\" class=\"team\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"section-title\"\u003e \u003ch2\u003e豆瓣电影top250电影\u003c/h2\u003e \u003c/div\u003e \u003c!-- ======= Counts Section ======= --\u003e \u003csection class=\"counts section-bg\"\u003e \u003cdiv class=\"container\"\u003e \u003ctable class=\"table table-striped\"\u003e \u003ctr\u003e \u003ctd\u003e排名\u003c/td\u003e \u003ctd\u003e电影名称\u003c/td\u003e \u003ctd\u003e外国名称\u003c/td\u003e \u003ctd\u003e评分\u003c/td\u003e \u003ctd\u003e评价人数\u003c/td\u003e \u003ctd\u003e一句话描述\u003c/td\u003e \u003ctd\u003e其他信息\u003c/td\u003e \u003c/tr\u003e {% for movie in movies %} \u003ctr\u003e \u003ctd\u003e{{ movie[0] }}\u003c/td\u003e \u003ctd\u003e \u003ca href=\"{{ movie[1] }}\"\u003e {{movie[3]}} \u003c/a\u003e \u003c/td\u003e \u003ctd\u003e{{ movie[4] }}\u003c/td\u003e \u003ctd\u003e{{ movie[5] }}\u003c/td\u003e \u003ctd\u003e{{ movie[6] }}\u003c/td\u003e \u003ctd\u003e{{ movie[7] }}\u003c/td\u003e \u003ctd\u003e{{ movie[8] }}\u003c/td\u003e \u003c/tr\u003e {% endfor %} \u003c/table\u003e \u003c/div\u003e \u003c/section\u003e\u003c!-- End Counts Section --\u003e \u003c/div\u003e \u003c/section\u003e\u003c!-- End Our Team Section --\u003e \u003c!-- ======= Footer ======= --\u003e \u003cfooter id=\"footer\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"copyright\"\u003e \u0026copy; Copyright \u003cstrong\u003e\u003cspan\u003eMr.Lee\u003c/span\u003e\u003c/strong\u003e. All Rights Reserved \u003c/div\u003e \u003cdiv class=\"credits\"\u003e \u003c/div\u003e \u003c/div\u003e \u003c/footer\u003e\u003c!-- End Footer --\u003e \u003ca href=\"#\" class=\"back-to-top\"\u003e\u003ci class=\"icofont-simple-up\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c!-- Vendor JS Files --\u003e \u003cscript src=\"static/assets/vendor/jquery/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/bootstrap/js/bootstrap.bundle.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/jquery.easing/jquery.easing.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/php-email-form/validate.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/jquery-sticky/jquery.sticky.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/venobox/venobox.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/waypoints/jquery.waypoints.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/counterup/counterup.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/isotope-layout/isotope.pkgd.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/aos/aos.js\"\u003e\u003c/script\u003e \u003c!-- Template Main JS File --\u003e \u003cscript src=\"static/assets/js/main.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:5","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"score score.html评分，这里获取数据和电影页面类似，也是需要读取数据库，不过最终是以柱形图的形式展示出来。使用Echarts技术来实现。 实现功能代码见app.py中score()函数 score.html源码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"\u003e \u003cscript src=\"static/assets/js/echarts.min.js\"\u003e\u003c/script\u003e \u003ctitle\u003e豆瓣top250数据可视化\u003c/title\u003e \u003cmeta content=\"\" name=\"descriptison\"\u003e \u003cmeta content=\"\" name=\"keywords\"\u003e \u003c!-- Favicons --\u003e \u003clink href=\"static/assets/img/favicon.png\" rel=\"icon\"\u003e \u003clink href=\"static/assets/img/apple-touch-icon.png\" rel=\"apple-touch-icon\"\u003e \u003c!-- Google Fonts --\u003e \u003clink href=\"https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,600,600i,700,700i,900\" rel=\"stylesheet\"\u003e \u003c!-- Vendor CSS Files --\u003e \u003clink href=\"static/assets/vendor/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/icofont/icofont.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/boxicons/css/boxicons.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/animate.css/animate.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/venobox/venobox.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/aos/aos.css\" rel=\"stylesheet\"\u003e \u003c!-- Template Main CSS File --\u003e \u003clink href=\"static/assets/css/style.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- ======= Top Bar ======= --\u003e \u003c!-- ======= Header ======= --\u003e \u003cheader id=\"header\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"logo float-left\"\u003e \u003ch1 class=\"text-light\"\u003e\u003ca href=\"index\"\u003e\u003cspan\u003e豆瓣电影\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e \u003c!-- Uncomment below if you prefer to use an image logo --\u003e \u003c!-- \u003ca href=\"temp.html\"\u003e\u003cimg src=\"static/assets/img/logo.png\" alt=\"\" class=\"img-fluid\"\u003e\u003c/a\u003e--\u003e \u003c/div\u003e \u003cnav class=\"nav-menu float-right d-none d-lg-block\"\u003e \u003cul\u003e \u003cli class=\"active\"\u003e\u003ca href=\"/index\"\u003e首页 \u003ci class=\"la la-angle-down\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/movie\"\u003e电影\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/score\"\u003e评分\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/word\"\u003e词云\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/team\"\u003e团队\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e\u003c!-- .nav-menu --\u003e \u003c/div\u003e \u003c/header\u003e\u003c!-- End Header --\u003e \u003c!-- ======= Our Team Section ======= --\u003e \u003csection id=\"team\" class=\"team\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"section-title\"\u003e \u003ch2\u003e豆瓣电影top250评分分布图\u003c/h2\u003e \u003cp\u003e应用Python爬虫Flask框架、Echarts、WordCloud等技术实现\u003c/p\u003e \u003c/div\u003e \u003c!-- ======= Counts Section ======= --\u003e \u003csection class=\"counts section-bg\"\u003e \u003cdiv class=\"container\"\u003e \u003c!-- 为 ECharts 准备一个定义了宽高的 DOM --\u003e \u003cdiv id=\"main\" style=\"width: 100%;height: 300px;\"\u003e\u003c/div\u003e \u003c/div\u003e \u003c/section\u003e\u003c!-- End Counts Section --\u003e \u003c/div\u003e \u003c/section\u003e\u003c!-- End Our Team Section --\u003e \u003c!-----Echarts-----------\u003e \u003cscript type=\"text/javascript\"\u003e var dom = document.getElementById('main'); var myChart = echarts.init(dom, null, { renderer: 'canvas', useDirtyRect: false }); var app = {}; var option; option = { title:{ text:'电影评分表' }, color:['#3398DB'], tooltip: { trigger:'axis', axisPointer:{ type:'shadow' } }, grid:{ left:'3%', right:'4%', bottom:'3%', containLabel:true }, xAxis: { type: 'category', data: {{ score|tojson }} \u003c!----['mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun','999']-----\u003e }, yAxis: { type: 'value' }, series: [ { data: {{ num }}, \u003c!---[120, 20, 150, 80, 70, 110, 130,200],-----\u003e barWidth:'60%', type: 'bar' } ] }; if (option \u0026\u0026 typeof option === 'object') { myChart.setOption(option); } window.addEventListener('resize', myChart.resize); \u003c/script\u003e \u003c!-- ======= Footer ======= --\u003e \u003ca href=\"#\" class=\"back-to-top\"\u003e\u003ci class=\"icofont-simple-up\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c!-- Vendor JS Files --\u003e \u003cscript src=\"static/assets/vendor/jquery/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/bootstrap/js/bootstrap.bundle.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/jquery.easing/jquery.easing.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/php-email-form/validate.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/jquery-sticky/jquery.sticky.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/venobox/venobox.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/waypoints/jquery.waypoints.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/co","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:6","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"word word.html词云。使用WordCloud技术，生成一张带有出现频率较高的词汇的图片。原图片是白底的树，根据它来生成词汇树。 word.html源码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"\u003e \u003ctitle\u003e豆瓣top250数据可视化\u003c/title\u003e \u003cmeta content=\"\" name=\"descriptison\"\u003e \u003cmeta content=\"\" name=\"keywords\"\u003e \u003c!-- Favicons --\u003e \u003clink href=\"static/assets/img/favicon.png\" rel=\"icon\"\u003e \u003clink href=\"static/assets/img/apple-touch-icon.png\" rel=\"apple-touch-icon\"\u003e \u003c!-- Google Fonts --\u003e \u003clink href=\"https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,600,600i,700,700i,900\" rel=\"stylesheet\"\u003e \u003c!-- Vendor CSS Files --\u003e \u003clink href=\"static/assets/vendor/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/icofont/icofont.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/boxicons/css/boxicons.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/animate.css/animate.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/venobox/venobox.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/aos/aos.css\" rel=\"stylesheet\"\u003e \u003c!-- Template Main CSS File --\u003e \u003clink href=\"static/assets/css/style.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- ======= Header ======= --\u003e \u003cheader id=\"header\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"logo float-left\"\u003e \u003ch1 class=\"text-light\"\u003e\u003ca href=\"index\"\u003e\u003cspan\u003e豆瓣电影\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e \u003c!-- Uncomment below if you prefer to use an image logo --\u003e \u003c!-- \u003ca href=\"temp.html\"\u003e\u003cimg src=\"static/assets/img/logo.png\" alt=\"\" class=\"img-fluid\"\u003e\u003c/a\u003e--\u003e \u003c/div\u003e \u003cnav class=\"nav-menu float-right d-none d-lg-block\"\u003e \u003cul\u003e \u003cli class=\"active\"\u003e\u003ca href=\"/index\"\u003e首页 \u003ci class=\"la la-angle-down\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/movie\"\u003e电影\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/score\"\u003e评分\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/word\"\u003e词云\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/team\"\u003e团队\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e\u003c!-- .nav-menu --\u003e \u003c/div\u003e \u003c/header\u003e\u003c!-- End Header --\u003e \u003c!-- ======= About Us Section ======= --\u003e \u003csection id=\"about\" class=\"about\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"row no-gutters\"\u003e \u003cdiv class=\"col-lg-6 video-box\"\u003e \u003cimg src=\"static/assets/img/word.png\" class=\"img-fluid\" alt=\"\"\u003e \u003c/div\u003e \u003cdiv class=\"col-lg-6 d-flex flex-column justify-content-center about-content\"\u003e \u003cdiv class=\"section-title\"\u003e \u003ch2\u003e词频统计\u003c/h2\u003e \u003cp\u003e根据250部电影的一句话描述，提炼出词云树，可以让我们更加清晰的了解人们对于经典电影的理解\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"icon-box\" data-aos=\"fade-up\" data-aos-delay=\"100\"\u003e \u003cdiv class=\"icon\"\u003e\u003ci class=\"bx bx-gift\"\u003e\u003c/i\u003e\u003c/div\u003e \u003ch4 class=\"title\"\u003e\u003ca href=\"\"\u003e关于电影\u003c/a\u003e\u003c/h4\u003e \u003cp class=\"description\"\u003e不知道你从中领悟到了什么\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/section\u003e\u003c!-- End About Us Section --\u003e \u003ca href=\"#\" class=\"back-to-top\"\u003e\u003ci class=\"icofont-simple-up\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c!-- Vendor JS Files --\u003e \u003cscript src=\"static/assets/vendor/jquery/jquery.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/bootstrap/js/bootstrap.bundle.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/jquery.easing/jquery.easing.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/php-email-form/validate.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/jquery-sticky/jquery.sticky.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/venobox/venobox.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/waypoints/jquery.waypoints.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/counterup/counterup.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/isotope-layout/isotope.pkgd.min.js\"\u003e\u003c/script\u003e \u003cscript src=\"static/assets/vendor/aos/aos.js\"\u003e\u003c/script\u003e \u003c!-- Template Main JS File --\u003e \u003cscript src=\"static/assets/js/main.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:7","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"team team.html团队。介绍团队成员。 team.html源码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003cmeta content=\"width=device-width, initial-scale=1.0\" name=\"viewport\"\u003e \u003ctitle\u003e豆瓣top250数据可视化\u003c/title\u003e \u003cmeta content=\"\" name=\"descriptison\"\u003e \u003cmeta content=\"\" name=\"keywords\"\u003e \u003c!-- Favicons --\u003e \u003clink href=\"static/assets/img/favicon.png\" rel=\"icon\"\u003e \u003clink href=\"static/assets/img/apple-touch-icon.png\" rel=\"apple-touch-icon\"\u003e \u003c!-- Google Fonts --\u003e \u003clink href=\"https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,600,600i,700,700i,900\" rel=\"stylesheet\"\u003e \u003c!-- Vendor CSS Files --\u003e \u003clink href=\"static/assets/vendor/bootstrap/css/bootstrap.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/icofont/icofont.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/boxicons/css/boxicons.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/animate.css/animate.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/venobox/venobox.css\" rel=\"stylesheet\"\u003e \u003clink href=\"static/assets/vendor/aos/aos.css\" rel=\"stylesheet\"\u003e \u003c!-- Template Main CSS File --\u003e \u003clink href=\"static/assets/css/style.css\" rel=\"stylesheet\"\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- ======= Top Bar ======= --\u003e \u003c!-- ======= Header ======= --\u003e \u003cheader id=\"header\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"logo float-left\"\u003e \u003ch1 class=\"text-light\"\u003e\u003ca href=\"index\"\u003e\u003cspan\u003e豆瓣电影\u003c/span\u003e\u003c/a\u003e\u003c/h1\u003e \u003c!-- Uncomment below if you prefer to use an image logo --\u003e \u003c!-- \u003ca href=\"temp.html\"\u003e\u003cimg src=\"static/assets/img/logo.png\" alt=\"\" class=\"img-fluid\"\u003e\u003c/a\u003e--\u003e \u003c/div\u003e \u003cnav class=\"nav-menu float-right d-none d-lg-block\"\u003e \u003cul\u003e \u003cli class=\"active\"\u003e\u003ca href=\"/index\"\u003e首页 \u003ci class=\"la la-angle-down\"\u003e\u003c/i\u003e\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/movie\"\u003e电影\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/score\"\u003e评分\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/word\"\u003e词云\u003c/a\u003e\u003c/li\u003e \u003cli\u003e\u003ca href=\"/team\"\u003e团队\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/nav\u003e\u003c!-- .nav-menu --\u003e \u003c/div\u003e \u003c/header\u003e\u003c!-- End Header --\u003e \u003c!-- ======= Our Team Section ======= --\u003e \u003csection id=\"team\" class=\"team\"\u003e \u003cdiv class=\"container\"\u003e \u003cdiv class=\"section-title\"\u003e \u003ch2\u003eOur Team\u003c/h2\u003e \u003cp\u003eMagnam dolores commodi suscipit. Necessitatibus eius consequatur ex aliquid fuga eum quidem.\u003c/p\u003e \u003c/div\u003e \u003cdiv class=\"row\"\u003e \u003cdiv class=\"col-xl-3 col-lg-4 col-md-6\" data-aos=\"fade-up\"\u003e \u003cdiv class=\"member\"\u003e \u003cdiv class=\"pic\"\u003e\u003cimg src=\"static/assets/img/team/team-1.jpg\" class=\"img-fluid\" alt=\"\"\u003e\u003c/div\u003e \u003cdiv class=\"member-info\"\u003e \u003ch4\u003eWalter White\u003c/h4\u003e \u003cspan\u003eChief Executive Officer\u003c/span\u003e \u003cdiv class=\"social\"\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-twitter\"\u003e\u003c/i\u003e\u003c/a\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-facebook\"\u003e\u003c/i\u003e\u003c/a\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-instagram\"\u003e\u003c/i\u003e\u003c/a\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-linkedin\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"col-xl-3 col-lg-4 col-md-6\" data-aos=\"fade-up\" data-aos-delay=\"100\"\u003e \u003cdiv class=\"member\"\u003e \u003cdiv class=\"pic\"\u003e\u003cimg src=\"static/assets/img/team/team-2.jpg\" class=\"img-fluid\" alt=\"\"\u003e\u003c/div\u003e \u003cdiv class=\"member-info\"\u003e \u003ch4\u003eSarah Jhonson\u003c/h4\u003e \u003cspan\u003eProduct Manager\u003c/span\u003e \u003cdiv class=\"social\"\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-twitter\"\u003e\u003c/i\u003e\u003c/a\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-facebook\"\u003e\u003c/i\u003e\u003c/a\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-instagram\"\u003e\u003c/i\u003e\u003c/a\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-linkedin\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"col-xl-3 col-lg-4 col-md-6\" data-aos=\"fade-up\" data-aos-delay=\"200\"\u003e \u003cdiv class=\"member\"\u003e \u003cdiv class=\"pic\"\u003e\u003cimg src=\"static/assets/img/team/team-3.jpg\" class=\"img-fluid\" alt=\"\"\u003e\u003c/div\u003e \u003cdiv class=\"member-info\"\u003e \u003ch4\u003eWilliam Anderson\u003c/h4\u003e \u003cspan\u003eCTO\u003c/span\u003e \u003cdiv class=\"social\"\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-twitter\"\u003e\u003c/i\u003e\u003c/a\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-facebook\"\u003e\u003c/i\u003e\u003c/a\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-instagram\"\u003e\u003c/i\u003e\u003c/a\u003e \u003ca href=\"\"\u003e\u003ci class=\"icofont-linkedin\"\u003e\u003c/i\u003e\u003c/a\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"col-xl-3 col-lg-4 col-md-6\" data-aos=\"fade-up\" data-aos-delay=\"300\"\u003e \u003cdiv class=\"member\"\u003e \u003cdiv class=\"pic\"\u003e\u003cimg src=\"static/assets/img/team/team-4.jpg\" class=\"img-fluid\" alt=\"\"\u003e\u003c/div\u003e \u003cdiv class=\"member-info\"\u003e \u003ch4\u003eAmanda Jepson\u003c/h4\u003e \u003cspan\u003eAccountant\u003c/span\u003e \u003cdiv class=\"social\"\u003e \u003ca href=\"\"\u003e\u003c","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:8","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"关于Echarts 使用前先下载源码 地址 只需要这一个文件（echarts.min.js） 将文件(echarts.min.js)复制到项目test目录内 Echarts官方网站: https://echarts.apache.org/examples/zh/index.html#chart-type-line 可以根据官方示例更改代码实现想要的结果，最后可以下载示例。 示例网址[https://echarts.apache.org/examples/zh/editor.html?c=bar-background] 下载后将代码复制一份到score.html中。 ","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:9","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"关于wordcloud 在项目根目录内创建文件testCloud.py文件，实现词云页面所需要的词云树。 需要安装几个第三方的库 jieba: 分词 matplotlib： 绘图、数据可视化 wordcloud：词云 numpy：矩阵运算 sqlite3：数据库 PIL：图形处理库 代码如下： from tkinter import Image import jieba # 分词 from matplotlib import pyplot as plt # 绘图，数据可视化 from wordcloud import WordCloud # 词云 import numpy as np # 矩阵运算 import sqlite3 # 数据库 from PIL import Image # 准备词云所需的文字（词） con = sqlite3.connect('douban_flask\\movie.db') cur = con.cursor() sql = 'select instroduction from movie250' data = cur.execute(sql) text = \"\" for item in data: text = text + item[0] # print(item[0]) # print(text) cur.close() con.close() # 分词 cut = jieba.cut(text) string = ' '.join(cut) print(len(string)) img = Image.open(r'D:\\code2022\\auto-work\\douban_flask\\static\\assets\\img\\tree.png') # 打开遮罩图片 img_array = np.array(img) wc = WordCloud( background_color = 'white', mask = img_array, font_path = \"msyh.ttc\" # C:\\Windows\\Fonts 字体所在位置。 ) wc.generate_from_text(string) # 绘制图片 fig = plt.figure(1) plt.imshow(wc) plt.axis('off') # 是否显示坐标轴 # plt.show() # 显示生成的词云图片 # 输出词云图片到文件 plt.savefig(r'D:\\code2022\\auto-work\\douban_flask\\static\\assets\\img\\word.png',dpi=500) ","date":"2022-08-07","objectID":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/:1:10","tags":["python"],"title":"豆瓣电影top250展示页","uri":"/%E8%B1%86%E7%93%A3%E5%B1%95%E7%A4%BA%E9%A1%B5/"},{"categories":["编程"],"content":"数据可视化 ","date":"2022-07-21","objectID":"/flask%E5%85%A5%E9%97%A8/:1:0","tags":["flask"],"title":"Flask入门","uri":"/flask%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"关于Flask Flask作为web框架，它的作用主要是开发web应用程序。 ","date":"2022-07-21","objectID":"/flask%E5%85%A5%E9%97%A8/:1:1","tags":["flask"],"title":"Flask入门","uri":"/flask%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"Flask基础的操作 浏览器打印hello world! from flask import Flask # flask类接收一个参数__name__ app = Flask(__name__) # 路由解析，通过用户范文的路径，匹配相应的函数。 @app.route('/') def hello_world(): return 'hello world!' # debug模式开启,更改代码后，浏览器实时显示。 # Flask应用程序实例的run方法启动web服务器 if __name__ == '__main__': app.run() 运行代码 访问网址：http://127.0.0.1:5000屏幕打印hello world! FLASK_APP = app.py FLASK_ENV = development FLASK_DEBUG = 0 In folder D:/code2022/auto-work/demo D:\\pccharmcode\\venv\\Scripts\\python.exe -m flask run * Running on http://127.0.0.1:5000 (Press CTRL+C to quit) * Serving Flask app 'app.py' (lazy loading) * Environment: development * Debug mode: off 访问/index路径 from flask import Flask # flask类接收一个参数__name__ app = Flask(__name__) # 路由解析，通过用户范文的路径，匹配相应的函数。 # 装饰起的作用是将路由映射到视图函数hello @app.route(\"/index\") def hello(): return \"你好\" # debug模式开启,更改代码后，浏览器实时显示。 # Flask应用程序实例的run方法启动web服务器 if __name__ == '__main__': app.run() 通过访问路径，获取用户的字符串参数 from flask import Flask # flask类接收一个参数__name__ app = Flask(__name__) # 路由解析，通过用户范文的路径，匹配相应的函数。 @app.route(\"/user/\u003cname\u003e\") def welcom(name): return \"你好,%s\"% name # debug模式开启,更改代码后，浏览器实时显示。 # Flask应用程序实例的run方法启动web服务器 if __name__ == '__main__': app.run() 通过访问路径，获取用户的整形参数 from flask import Flask # flask类接收一个参数__name__ app = Flask(__name__) # 路由解析，通过用户范文的路径，匹配相应的函数。 @app.route(\"/user/\u003cint:id\u003e\") def welcom2(id): return \"你好,%d 号的会员\"% id # debug模式开启,更改代码后，浏览器实时显示。 # Flask应用程序实例的run方法启动web服务器 if __name__ == '__main__': app.run() # 路由路径不能重复，用户通过唯一路径来访问特定的函数。 返回用户渲染后的网页文件 from flask import Flask, render_template, request # flask类接收一个参数__name__ app = Flask(__name__) # 路由解析，通过用户范文的路径，匹配相应的函数。 @app.route(\"/\") def index2(): return render_template(\"index.html\") # debug模式开启,更改代码后，浏览器实时显示。 # Flask应用程序实例的run方法启动web服务器 if __name__ == '__main__': app.run() # 路由路径不能重复，用户通过唯一路径来访问特定的函数。 向页面传递一些变量 from flask import Flask, render_template, request import datetime # flask类接收一个参数__name__ app = Flask(__name__) # 路由解析，通过用户范文的路径，匹配相应的函数。 @app.route(\"/\") def index2(): time = datetime.date.today() # 普通变量 name = [\"小张\", \"小王\", \"小赵\"] # 列表类型 task = {\"任务\": \"打扫卫生\", \"时间\": \"3小时\"} # 字典类型 return render_template(\"index.html\", var = time, list = name, task = task) # debug模式开启,更改代码后，浏览器实时显示。 # Flask应用程序实例的run方法启动web服务器 if __name__ == '__main__': app.run() # 路由路径不能重复，用户通过唯一路径来访问特定的函数。 表单提交 至少需要2个页面，提交界面和结果界面。 from flask import Flask, render_template, request import datetime # flask类接收一个参数__name__ app = Flask(__name__) # 路由解析，通过用户范文的路径，匹配相应的函数。 @app.route('/test/register') def register(): return render_template(\"test/register.html\") # debug模式开启,更改代码后，浏览器实时显示。 # Flask应用程序实例的run方法启动web服务器 if __name__ == '__main__': app.run() # 路由路径不能重复，用户通过唯一路径来访问特定的函数。 接收表单提交的路由，需要指定methods为post from flask import Flask, render_template, request import datetime # flask类接收一个参数__name__ app = Flask(__name__) # 路由解析，通过用户范文的路径，匹配相应的函数。 @app.route('/result', methods=['POST','GET']) def result(): if request.method == 'POST': result = request.form return render_template(\"test/result.html\", result=result) # debug模式开启,更改代码后，浏览器实时显示。 # Flask应用程序实例的run方法启动web服务器 if __name__ == '__main__': app.run() # 路由路径不能重复，用户通过唯一路径来访问特定的函数。 ","date":"2022-07-21","objectID":"/flask%E5%85%A5%E9%97%A8/:1:2","tags":["flask"],"title":"Flask入门","uri":"/flask%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"sqlite3使用 连接数据库 import sqlite3 conn = sqlite3.connect(\"test.db\") # 打开或创建数据库文件 print(\"Opened database successfully\") c = conn.cursor() # 获取游标 sql = \"\" c.execute(sql) # 执行sql语句 conn.commit() # 提交数据库操作 conn.close() # 关闭数据库连接 print(\"ok\") 创建数据表 import sqlite3 conn = sqlite3.connect(\"test.db\") # 打开或创建数据库文件 print(\"成功打开数据\") c = conn.cursor() # 获取游标 sql = ''' create table company (id int primary key not null, name text not null, age int not null, address char(50), salary real ); ''' c.execute(sql) # 执行sql语句 conn.commit() # 提交数据库操作 conn.close() # 关闭数据库连接 print(\"建表成功\") 使用pycharm连接数据库 见 插入数据 import sqlite3 conn = sqlite3.connect(\"test.db\") # 打开或创建数据库文件 print(\"成功打开数据\") c = conn.cursor() # 获取游标 sql1 = ''' insert into company(id, name,age,address, salary) values(1,'张三',32,\"成都\",8000); ''' sql2 = ''' insert into company(id, name,age,address, salary) values(2,'李四',30,\"重庆\",15000); ''' c.execute(sql1) # 执行sql语句 c.execute(sql2) # 执行sql语句 conn.commit() # 提交数据库操作 conn.close() # 关闭数据库连接 print(\"插入数据完毕\") 查询数据 import sqlite3 conn = sqlite3.connect(\"test.db\") # 打开或创建数据库文件 print(\"成功打开数据\") c = conn.cursor() # 获取游标 sql = \"select id, name, address, salary from company\" cursor = c.execute(sql) # 执行sql语句 for row in cursor: print(\"id = \", row[0]) print(\"name = \", row[1]) print(\"address = \", row[2]) print(\"salary = \", row[3], \"\\n\") conn.close() # 关闭数据库连接 print(\"查询完毕\") ","date":"2022-07-20","objectID":"/sqlite3%E4%BD%BF%E7%94%A8/:1:0","tags":["sqlite3"],"title":"sqlite3使用","uri":"/sqlite3%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"BeautifulSoup4将复杂的HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种 Tag NavigableString BeautifulSoup Comment ","date":"2022-07-17","objectID":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/:0:0","tags":["python"],"title":"Bs4-正则表达式-Re模块","uri":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"全局代码 from bs4 import BeautifulSoup file = open(r\"D:\\code2022\\auto-work\\douban\\test\\baidu.html\",\"rb\") html = file.read().decode('utf-8') bs = BeautifulSoup(html,\"html.parser\") print(bs.title) # \u003ctitle\u003e百度一下，你就知道\u003c/title\u003e print(bs.a) print(bs.head) print(type(bs.head)) # \u003cclass 'bs4.element.Tag'\u003e ","date":"2022-07-17","objectID":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/:0:1","tags":["python"],"title":"Bs4-正则表达式-Re模块","uri":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"Tag 标签及其内容 拿到它所找到的第一个内容 NavigableString 标签里的内容（字符串） print(bs.title.string) # 百度一下，你就知道 print(type(bs.title.string)) # \u003cclass 'bs4.element.NavigableString'\u003e BeautifulSoup 表示整个文档 print(bs.a.attrs) print(type(bs)) # \u003cclass 'bs4.BeautifulSoup'\u003e Comment 是一个特殊的NavigableString，输出的内容不包含注释符号。 print(bs.name) # [document] print(bs) print(bs.a.string) print(type(bs.a.string)) 文档的遍历,遍历文档树。 print(bs.head.contents) print(bs.head.contents[1]) # 更多内容，搜索文档。 ","date":"2022-07-17","objectID":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/:0:2","tags":["python"],"title":"Bs4-正则表达式-Re模块","uri":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"文档的搜索 find_all() # 字符串过滤：会查找与字符串完全匹配的内容 t_list = bs.find_all(\"a\") import re # 正则表达式搜索：使用search() 方法来匹配内容 t_list = bs.find_all(re.compile(\"a\")) # 方法： 传入一个函数（方法），根据函数的要求来搜索(了解) def name_is_exits(tag): return tag.has_attr(\"name\") t_list = bs.find_all(name_is_exits) for item in t_list: print(item) print(t_list) kwargs 参数 t_list = bs.find_all(id=\"head\") t_list = bs.find_all(href=\"http://news.baidu.com\") t_list = bs.find_all(class_=True) for item in t_list: print(item) text参数 t_list = bs.find_all(text= \"hao123\") t_list = bs.find_all(text=[\"hao123\",\"地图\",\"贴吧\"]) t_list = bs.find_all(text=re.compile(\"\\d\")) # 应用正则表达式来查找包含特定文本的内容（标签里的字符串） limit 参数 t_list = bs.find_all(\"a\",limit=3) for item in t_list: print(item) css 选择器 t_list = bs.select('title') # 通过标签来查找 for item in t_list: print(item) t_list = bs.select(\".mnav\") # 通过类名查找 for item in t_list: print(item) t_list = bs.select(\"#u1\") # 通过id查找 for item in t_list: print(item) t_list = bs.select(\"a[class='guide-info']\") # 通过属性来查找 for item in t_list: print(item) t_list = bs.select(\"head \u003e title\") # 通过子标签来查找 for item in t_list: print(item) t_list = bs.select(\".mnav ~ .bri\") # 查找mnav下的bri标签 print(t_list[0].get_text()) ","date":"2022-07-17","objectID":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/:0:3","tags":["python"],"title":"Bs4-正则表达式-Re模块","uri":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"正则表达式与Re库 ","date":"2022-07-17","objectID":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/:1:0","tags":["python"],"title":"Bs4-正则表达式-Re模块","uri":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"正则表达式常用操作符（1） 操作符 说明 实例 . 表示任何单个字符 [ ] 字符集，对单个字符给出取值范围 [abc]表示a、b、c,[a-z]表示a到z单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a或b或c的单个字符 * 前一个字符0次或无限次扩展 abc* 表示 ab、abc、abcc、abccc等 + 前一个字符1次或无限次扩展 abc+ 表示 abc、abcc、abccc等 ？ 前一个字符0次或1次扩展 abc? 表示 ab、abc | 左右表达式任意一个 abc | def 表示 abc、 def ","date":"2022-07-17","objectID":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/:1:1","tags":["python"],"title":"Bs4-正则表达式-Re模块","uri":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"正则表达式常用操作符（2） 操作符 说明 实例 {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次（含n） ab{1,2}c表示abc、abbc ^ 匹配字符串开头 ^abc 表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串末尾 () 分组标记，内部只能使用 | 操作符 (abc)表示abc，(abc|def)表示abc、def \\d 数字，等价于[0-9] \\w 单词字符，等价于[A-Za-z0-9_] ","date":"2022-07-17","objectID":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/:1:2","tags":["python"],"title":"Bs4-正则表达式-Re模块","uri":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"Re库主要功能函数 函数 说明 re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象 re.match() 从一个字符串的开始位置起匹配正则表达式，返回match对象 re.findall() 搜索字符串，以列表类型返回全部能匹配的子串 re.split() 将一个字符串按照正则表达式匹配结果进行分割，返回列表类型 re.finditer() 搜索字符串，返回一个匹配结果的迭代类型，每个迭代元素是match对象 re.sub() 在一个字符串中替换所有匹配正则表达式的字串，返回替换后的字符串。 正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位OR(|)它们来指定。如re.l|re.M被设置成|和M标志。 修饰符 描述 re.l 使匹配对大小写不敏感 re.L 做本地化识别（local-aware） re.M 多行匹配，影响^和$ re.S 使.匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响\\w ，\\W， \\b， \\B re.X 该标志通过给与你更灵活的格式以便你将正则表达式写的更易于理解。 正则表达式：字符串模式（判断字符串是否符合一定的标准） import re # 创建模式对象 pat = re.compile(\"AA\") # 此处的AA 是正则表达式，用来去验证其他字符串 m = pat.search(\"CBA\") # search 字符串被校验的内容 m = pat.search(\"ABCAA\") print(m) # \u003cre.Match object; span=(3, 5), match='AA'\u003e m = pat.search(\"ABCAADDCCAAA\") # search 方法进行比对查找 print(m) # \u003cre.Match object; span=(3, 5), match='AA'\u003e # 没有模式对象 m = re.search(\"asd\",\"Aasd\") # 前面的字符串是规则（模板），后面的字符串是被校验的对象。 print(m) # \u003cre.Match object; span=(1, 4), match='asd'\u003e print(re.findall(\"a\",\"ASDaDFGAa\")) # ['a', 'a'] 前面字符串是规则（正则表达式），后面字符串是被校验的字符串 print(re.findall(\"[A-Z]\",\"ASDaDFGAa\")) # ['A', 'S', 'D', 'D', 'F', 'G', 'A'] print(re.findall(\"[A-Z]+\",\"ASDaDFGAa\")) # ['ASD', 'DFGA'] # sub print(re.sub(\"a\",\"A\",\"abcdcasd\")) # 找到a用A替换，在第三个字符串种查找 # 建议用正则表达式中，被比较的字符串前面加上r，不用担心转义字符的问题。 a = r\"\\aabd-\\'\" print(a) # \\aabd-\\' ","date":"2022-07-17","objectID":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/:1:3","tags":["python"],"title":"Bs4-正则表达式-Re模块","uri":"/bs4%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8Fre%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"网页各种测试 http://httpbin.org 获取一个get请求 import urllib.request res = urllib.request.urlopen(\"http://www.baidu.com\") print(res.read().decode('utf-8')) # 对获取到的网页源码进行utf-8解码 获取一个post请求.（模拟用户登录） import urllib.parse # 引入解析库 data = bytes(urllib.parse.urlencode({\"hello\":\"world\"}),encoding='utf-8') res1 = urllib.request.urlopen(\"http://httpbin.org/post\",data=data) print(res1.read().decode(\"utf-8\")) 超时处理 try: res1 = urllib.request.urlopen(\"http://httpbin.org/get\",timeout=0.01) print(res1.read().decode('utf-8')) except urllib.error.URLError as e: print(\"time out!\") 获取基本信息 res2 = urllib.request.urlopen(\"http://baidu.com\") print(res2.status) # 获取状态码 print(res2.getheaders()) # 获取头部信息 print(res2.getheader(\"Server\")) # Apache 直接请求豆瓣网址 url = \"https://douban.com\" req = urllib.request.Request(url=url) response = urllib.request.urlopen(req) print(response.read().decode(\"utf-8\")) 报错信息如下：（说明豆瓣已经识别到是爬虫的请求） raise HTTPError(req.full_url, code, msg, hdrs, fp) urllib.error.HTTPError: HTTP Error 418 如何伪装成浏览器来请求呢？这时候需要在请求头中添加user-agent。user-agent如何获取？浏览器F12-》NETWORK-\u003e点击左侧带有get请求的网址，右侧拉到最下边复制user-agent的值。 构建代码后再次请求，收到返回的数据了。 url = \"https://douban.com\" headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36\" } req = urllib.request.Request(url=url,headers=headers) response = urllib.request.urlopen(req) print(response.read().decode(\"utf-8\")) ","date":"2022-07-17","objectID":"/urllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:0:1","tags":["urllib库"],"title":"urllib库的基本使用","uri":"/urllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"UA伪装 方式一 将常见的UserAgent用列表保存起来 ua_list = [ \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1\", \"Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1\", \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11\", \"Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\", \"Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", \"Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", \"Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5\", \"Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\", \"MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1\", \"Opera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) Presto/2.8.149 Version/11.10\", \"Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13\", \"Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, like Gecko) Version/6.0.0.337 Mobile Safari/534.1+\", \"Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 (KHTML, like Gecko) wOSBrowser/233.70 Safari/534.6 TouchPad/1.0\", \"Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124\", \"Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; IEMobile/9.0; HTC; Titan)\" ] 代码演示 import random from urllib.request import urlopen, Request url = \"http://httpbin.org/get\" ua_list = [ \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:91.0) Gecko/20100101 Firefox/91.0\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)\", \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1\", \"Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1\", \"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/11.11\", \"Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11\", \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)\", \"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)\", \"Mozilla/4.0 (compatible; MSIE 7.0; ","date":"2022-07-17","objectID":"/urllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:1:0","tags":["urllib库"],"title":"urllib库的基本使用","uri":"/urllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"使用代理 ","date":"2022-07-17","objectID":"/urllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:2:0","tags":["urllib库"],"title":"urllib库的基本使用","uri":"/urllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"常用的handler对象 HTTPHandler: 普通的HTTP处理器 ProxyHandler: 代理IP处理器 HTTPCookieProcessor: cookie处理器 ","date":"2022-07-17","objectID":"/urllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:2:1","tags":["urllib库"],"title":"urllib库的基本使用","uri":"/urllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"代码演示 HTTPHandler # -*- coding:utf-8 -*- from fake_useragent import UserAgent from urllib.request import Request, urlopen, build_opener, HTTPHandler def download(url): headers = { \"User-Agent\": UserAgent().random } req = Request(url, headers=headers) # 创建http处理器对象,debuglevel打开调试 handler = HTTPHandler(debuglevel=2) opener = build_opener(handler) resp = opener.open(req) print(resp.read().decode('utf-8')) if __name__ == '__main__': url = \"http://httpbin.org/get\" download(url) 输出如下 send: b'GET /get HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nHost: httpbin.org\\r\\nUser-Agent: Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.67 Safari/537.36\\r\\nConnection: close\\r\\n\\r\\n' reply: 'HTTP/1.1 200 OK\\r\\n' header: Date: Wed, 20 Jul 2022 08:06:06 GMT header: Content-Type: application/json header: Content-Length: 359 header: Connection: close header: Server: gunicorn/19.9.0 header: Access-Control-Allow-Origin: * header: Access-Control-Allow-Credentials: true { \"args\": {}, \"headers\": { \"Accept-Encoding\": \"identity\", \"Host\": \"httpbin.org\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.67 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-62d7b76e-4c99f8712c1292a55b601fa4\" }, \"origin\": \"访问的ip\", \"url\": \"http://httpbin.org/get\" } ProxyHandler # -*- coding:utf-8 -*- from fake_useragent import UserAgent from urllib.request import Request, build_opener, ProxyHandler def proxy_handler(url): headers = { \"User-Agent\": UserAgent().random } req = Request(url, headers=headers) # ProxyHandler({\"http\": \"ip:port\"}) handler = ProxyHandler({\"http\": \"58.20.235.180:9091\"}) opener = build_opener(handler) resp = opener.open(req) # print(resp.info()) print(resp.read().decode()) if __name__ == '__main__': url = \"http://httpbin.org/get\" proxy_handler(url) 输出如下 { \"args\": {}, \"headers\": { \"Host\": \"httpbin.org\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/27.0.1453.93 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-62d7b7ea-05098b4c34bab12d7cc0dfe7\" }, \"origin\": \"58.20.235.180\", \"url\": \"http://httpbin.org/get\" } 发现使用了代理IP请求的网页。 登录cookie处理见 ","date":"2022-07-17","objectID":"/urllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/:2:2","tags":["urllib库"],"title":"urllib库的基本使用","uri":"/urllib%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"爬虫分析步骤 准备工作 获取数据 解析内容 保存数据 ","date":"2022-07-17","objectID":"/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E7%88%AC%E8%99%AB/:1:0","tags":["python"],"title":"豆瓣电影数据分析","uri":"/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"url分析 页面包括250条电影数据，分10页，每页25条。每页的url的不同之处：最后的数值= （页数-1）*25 # 第一页第一条 https://movie.douban.com/top250?start=0 服务器通过headers鉴定客户端信息。 ","date":"2022-07-17","objectID":"/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E7%88%AC%E8%99%AB/:1:1","tags":["python"],"title":"豆瓣电影数据分析","uri":"/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"保存到excel表格中，代码如下 注意：如果ip被限制可以带cookie请求，这样服务器会认为是同一个客户端发出的请求。 或者使用代理IP来访问。 代理IP网站 from bs4 import BeautifulSoup # 网页解析，获取数据 import re # 正则表达式，进行文字匹配 import urllib.request, urllib.error # 指定url，获取网页数据 from urllib.error import URLError import xlwt # 进行execl操作 import sqlite3 # 进行sqlite 数据库操作 from fake_useragent import UserAgent # 引入动态随机UserAgent from urllib.request import build_opener, ProxyHandler # 反反爬，使用代理IP，防止被服务器封掉。 def main(): baseurl = \"https://movie.douban.com/top250?start=\" # 1.爬取网页 datalist = getData(baseurl) savepath = \".\\\\豆瓣电影top250.xls\" # 3.保存数据 saveData(datalist,savepath) # askURL(\"https://movie.douban.com/top250?start=0\") # 影片详情的规则 findLink = re.compile(r'\u003ca href=\"(.*?)\"\u003e') # 创建正则表达式对象，表示规则（字符串的模式） # 影片图片 findImgSrc = re.compile(r'\u003cimg.*src=\"(.*?)\"',re.S) # re.S 让换行符包含在字符中 # 影片片名 findTitle = re.compile(r'\u003cspan class=\"title\"\u003e(.*)\u003c/span\u003e') # 影片评分 findRating = re.compile(r'\u003cspan class=\"rating_num\" property=\"v:average\"\u003e(.*)\u003c/span\u003e') # 找到评价人数 findJudge = re.compile(r'\u003cspan\u003e(\\d*)人评价\u003c/span\u003e') # 找到概况 findInq = re.compile(r'\u003cspan class=\"inq\"\u003e(.*)\u003c/span\u003e') # 找到影片的相关内容 findBd =re.compile(r'\u003cp class=\"\"\u003e(.*?)\u003c/p\u003e',re.S) # 爬取网页 def getData(baseurl): datalist = [] for i in range(0,10): # 调用获取页面信息的函数,10次,正好10页内容250条。 url = baseurl + str(i*25) askURL(url) html = askURL(url) # 保存获取到的网页源码 # 2.逐一解析数据 soup = BeautifulSoup(html,\"html.parser\") for item in soup.find_all(\"div\",class_=\"item\"): #查找符合要求的字符串形成列表。 # print(item) # 测试查看电影item全部信息 data = [] #保存一部电影的所有信息 item = str(item) # 影片详情的链接 link = re.findall(findLink,item)[0] #re库用来通过正则表达式查找指定的字符串 # print(link) data.append(link) # 添加链接 imgSrc= re.findall(findImgSrc,item)[0] #添加图片 data.append(imgSrc) titles = re.findall(findTitle,item) # 片名可能只有一个中文名，没有外国名 if (len(titles) == 2): ctitle = titles[0] # 添加中文名 data.append(ctitle) otitle = titles[1].replace(\"/\",\"\") # 去掉无关的符号 data.append(otitle) # 添加外国名 else: data.append(titles[0]) data.append(' ') # 外国名字留空 rating = re.findall(findRating,item)[0] # 添加评分 data.append(rating) judgeNim = re.findall(findJudge,item)[0] data.append(judgeNim) # 添加评价人数 inq = re.findall(findInq,item) if len(inq) != 0: inq = inq[0].replace(\"。\",\"\") # 去掉句号 data.append(inq) # 添加概述 else: data.append(\" \") # 留空 bd = re.findall(findBd,item)[0] bd = re.sub('\u003cbr(\\s+)?/\u003e(\\s+)?',\" \",bd) # 去掉\u003cbr/\u003e bd = re.sub('/',\" \",bd) # 替换/ data.append(bd.strip()) # 去掉前后的空格 datalist.append(data) # 把处理好的一部分电影信息放入datalist # print(datalist) return datalist # 得到一个指定的URL的网页内容 def askURL(url): head = { # 模拟浏览器头部信息，向豆瓣服务器发送消息 \"User-Agent\": UserAgent().random } request = urllib.request.Request(url,headers=head) handler = ProxyHandler({\"http\":\"58.20.184.187:9091\"}) # 使用代理IP请求资源 opener = build_opener(handler) # 用户代理表示告诉豆瓣服务器，我们是什么类型的机器、浏览器(本质上是告诉浏览器，我们可以接收什么水平的文件内容) html = \"\" try: resp = opener.open(request) html = resp.read().decode(\"utf-8\") # print(html) except URLError as e: if hasattr(e,\"code\"): print(e.code) if hasattr(e,\"reason\"): print(e.reason) return html # 3.保存数据 def saveData(datalist,savepath): print(\"save....\") book = xlwt.Workbook(encoding='utf-8') # 创建workbook对象 sheet = book.add_sheet('豆瓣电影Top250',cell_overwrite_ok=True) # 创建工作表 col = (\"电影详情链接\",\"图片链接\",\"影片中文名\",\"影片外国名\",\"评分\",\"评价数\",\"概况\",\"相关信息\") for i in range(0,8): sheet.write(0,i,col[i]) # 列名 for i in range(0,250): print(\"第%d条\" %i) data = datalist[i] for j in range(0,8): sheet.write(i+1,j,data[j]) # 数据 book.save(savepath) # 保存数据表 if __name__ == \"__main__\": # 当程序执行时。程序入口，控制函数调用顺序。 # 调用函数 main() print(\"爬取完毕！\") ","date":"2022-07-17","objectID":"/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E7%88%AC%E8%99%AB/:1:2","tags":["python"],"title":"豆瓣电影数据分析","uri":"/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"保存到数据库中，代码如下 from bs4 import BeautifulSoup # 网页解析，获取数据 import re # 正则表达式，进行文字匹配 import urllib.request, urllib.error # 指定url，获取网页数据 from urllib.error import URLError import xlwt # 进行execl操作 import sqlite3 # 进行sqlite 数据库操作 from fake_useragent import UserAgent # 引入动态随机UserAgent from urllib.request import build_opener, ProxyHandler # 反反爬，使用代理IP，防止被服务器封掉。 def main(): baseurl = \"https://movie.douban.com/top250?start=\" # 1.爬取网页 datalist = getData(baseurl) dbpath = \"movie.db\" # 3.保存数据 saveData2DB(datalist, dbpath) # askURL(\"https://movie.douban.com/top250?start=0\") # 影片详情的规则 findLink = re.compile(r'\u003ca href=\"(.*?)\"\u003e') # 创建正则表达式对象，表示规则（字符串的模式） # 影片图片 findImgSrc = re.compile(r'\u003cimg.*src=\"(.*?)\"',re.S) # re.S 让换行符包含在字符中 # 影片片名 findTitle = re.compile(r'\u003cspan class=\"title\"\u003e(.*)\u003c/span\u003e') # 影片评分 findRating = re.compile(r'\u003cspan class=\"rating_num\" property=\"v:average\"\u003e(.*)\u003c/span\u003e') # 找到评价人数 findJudge = re.compile(r'\u003cspan\u003e(\\d*)人评价\u003c/span\u003e') # 找到概况 findInq = re.compile(r'\u003cspan class=\"inq\"\u003e(.*)\u003c/span\u003e') # 找到影片的相关内容 findBd =re.compile(r'\u003cp class=\"\"\u003e(.*?)\u003c/p\u003e',re.S) # 爬取网页 def getData(baseurl): datalist = [] for i in range(0,10): # 调用获取页面信息的函数,10次,正好10页内容250条。 url = baseurl + str(i*25) askURL(url) html = askURL(url) # 保存获取到的网页源码 # 2.逐一解析数据 soup = BeautifulSoup(html,\"html.parser\") for item in soup.find_all(\"div\",class_=\"item\"): #查找符合要求的字符串形成列表。 # print(item) # 测试查看电影item全部信息 data = [] #保存一部电影的所有信息 item = str(item) # 影片详情的链接 link = re.findall(findLink,item)[0] #re库用来通过正则表达式查找指定的字符串 # print(link) data.append(link) # 添加链接 imgSrc= re.findall(findImgSrc,item)[0] #添加图片 data.append(imgSrc) titles = re.findall(findTitle,item) # 片名可能只有一个中文名，没有外国名 if (len(titles) == 2): ctitle = titles[0] # 添加中文名 data.append(ctitle) otitle = titles[1].replace(\"/\",\"\") # 去掉无关的符号 data.append(otitle) # 添加外国名 else: data.append(titles[0]) data.append(' ') # 外国名字留空 rating = re.findall(findRating,item)[0] # 添加评分 data.append(rating) judgeNim = re.findall(findJudge,item)[0] data.append(judgeNim) # 添加评价人数 inq = re.findall(findInq,item) if len(inq) != 0: inq = inq[0].replace(\"。\",\"\") # 去掉句号 data.append(inq) # 添加概述 else: data.append(\" \") # 留空 bd = re.findall(findBd,item)[0] bd = re.sub('\u003cbr(\\s+)?/\u003e(\\s+)?',\" \",bd) # 去掉\u003cbr/\u003e bd = re.sub('/',\" \",bd) # 替换/ data.append(bd.strip()) # 去掉前后的空格 datalist.append(data) # 把处理好的一部分电影信息放入datalist # print(datalist) return datalist # 得到一个指定的URL的网页内容 def askURL(url): head = { # 模拟浏览器头部信息，向豆瓣服务器发送消息 \"User-Agent\": UserAgent().random } request = urllib.request.Request(url,headers=head) handler = ProxyHandler({\"http\":\"58.20.184.187:9091\"}) # 使用代理IP请求资源 opener = build_opener(handler) # 用户代理表示告诉豆瓣服务器，我们是什么类型的机器、浏览器(本质上是告诉浏览器，我们可以接收什么水平的文件内容) html = \"\" try: resp = opener.open(request) html = resp.read().decode(\"utf-8\") # print(html) except URLError as e: if hasattr(e,\"code\"): print(e.code) if hasattr(e,\"reason\"): print(e.reason) return html # 3.保存数据 def saveData2DB(datalist,dbpath): init_db(dbpath) conn = sqlite3.connect(dbpath) cur = conn.cursor() for data in datalist: for index in range(len(data)): if index == 4 or index == 5: continue data[index] = '\"'+data[index]+'\"' sql = ''' insert into movie250( info_link,pic_link,cname,ename,score,rated,instroduction,info ) values(%s)'''%\",\".join(data) # print(sql) # 打印插入语句（测试用） cur.execute(sql) conn.commit() cur.close() conn.close() def init_db(dbpath): sql = ''' create table movie250 ( id integer primary key autoincrement, info_link text, pic_link text, cname varchar , ename varchar , score numeric , rated numeric , instroduction text , info text ) ''' # 创建数据表 conn = sqlite3.connect(dbpath) cursor = conn.cursor() cursor.execute(sql) conn.commit() conn.close() if __name__ == \"__main__\": # 当程序执行时。程序入口，控制函数调用顺序。 # 调用函数 main() # init_db(\"movietest.db\") # 测试用，生成测试库。 print(\"爬取完毕！\") ","date":"2022-07-17","objectID":"/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E7%88%AC%E8%99%AB/:1:3","tags":["python"],"title":"豆瓣电影数据分析","uri":"/%E8%B1%86%E7%93%A3%E7%94%B5%E5%BD%B1%E7%88%AC%E8%99%AB/"},{"categories":["编程"],"content":"读写文件（上）–文件与文件路径 主要是os.path()第三方库 1.Windows系统中的\\和Linux系统中的/ 以下代码在Terminal中执行更直观 # D:\\\\code2022\\\\auto-work # /code2022/auto-work # 解决 \\ 和 / 的问题，可以使用os.path.join() # os.path.join('D:\\\\','code2022','auto-work') 2.获取当前的目录 os.getcwd() # 切换到指定路径下 os.chdir('D:\\\\code2022') \u003e\u003e\u003e os.getcwd() 'D:\\\\code2022\\\\auto-work' \u003e\u003e\u003e os.chdir('D:\\\\code2022') \u003e\u003e\u003e os.getcwd() 'D:\\\\code2022' 3.绝对路径和相对路径 绝对路径总是从根文件夹开始 相对路径是相对程序的当前工作目录 test1.py 的绝对路径 # D:\\code2022\\auto-work\\test1.py # D:\\code2022\\auto-work\\test2.py test2.py相对于test1.py的路径 # '.' 当前文件夹 # '..' 父文件夹 # 相对于test1.py 的路径 ../test2.py # 相对于auto-work/test2.py 的路径 ../../test2.py # 返回绝对路径 os.path.abspath('.') # 'D:\\\\code2022\\\\auto-work' os.path.abspath('test1.py') # 'D:\\\\code2022\\\\auto-work\\\\test1.py' # 返回相对路径 os.path.relpath(path[, start]) # 返回最后一个斜杠前的所有内容--目录名 os.path.dirname('D:\\\\code2022\\\\auto-work\\\\test1.py') # 'D:\\\\code2022\\\\auto-work' # 返回最后一个斜杠后的所有内容--文件名 os.path.basename('D:\\\\code2022\\\\auto-work\\\\test1.py') # 'test1.py' # 以元组的方式同时返回目录名和文件名 os.path.split('D:\\\\code2022\\\\auto-work\\\\test1.py') # 结果：('D:\\\\code2022\\\\auto-work', 'test1.py') # 按照斜杠裁剪,os.path.sep 会根据系统取不同的值 'D:\\\\code2022\\\\auto-work\\\\test1.py'.split(os.path.sep) # 结果：['D:', 'code2022', 'auto-work', 'test1.py'] 4.创建新文件夹（os.mkdir()） 在auto-work文件夹下创建test3文件夹 重复创建会报错 os.mkdir('D:\\\\code2022\\\\auto-work\\\\test3') 5.查看文件大小和文件夹内容(单位是字节) os.path.getsize('test2.py') # 28 os.listdir('.') # ['test1.py', 'test2.py', 'test3'] 这里是os.listdir()而不是os.path.list() 6.检查路径是否有效 如果提供的路径不存在，会使程序崩溃，以下函数可以检查路径是否存在 \u003e\u003e\u003e os.path.exists('test1.py') True \u003e\u003e\u003e os.path.isfile('test1.py') True \u003e\u003e\u003e os.path.isdir('test3') True \u003e\u003e\u003e 7.课后练习 把test3文件夹下的文件按照文件类型放到不同的文件夹下 把xlsx文件放到test3\\xlsx文件夹下 把jpeg文件放到test3\\jpeg文件夹下 把pptx文件放到test3\\pptx文件夹下 把docx文件放到test3\\doc文件夹下 把txt文件放到test3\\txt文件夹下 shutil模块支持文件的复制和删除 windows和linux都能使用 .py文件放到整理的文件夹内执行 import os,shutil def cleanDir(): BaseDir = os.getcwd() xlsxPath = os.path.join(BaseDir,'xlsx') imgPath = os.path.join(BaseDir,'img') pptPath = os.path.join(BaseDir,'ppt') docPath = os.path.join(BaseDir,'doc') txtPath = os.path.join(BaseDir,'txt') # D:\\\\code2022\\\\auto-work\\\\test3\\\\txt if not os.path.exists(xlsxPath): os.mkdir(xlsxPath) if not os.path.exists(imgPath): os.mkdir(imgPath) if not os.path.exists(pptPath): os.mkdir(pptPath) if not os.path.exists(docPath): os.mkdir(docPath) if not os.path.exists(txtPath): os.mkdir(txtPath) for file in os.listdir(BaseDir): baseName = os.path.basename(file) # 9.txt filePath = os.path.join(BaseDir,file) # D:\\\\code2022\\\\auto-work\\\\test3\\\\9.txt if os.path.isfile(filePath): ex = baseName.split('.')[1] # .txt if ex == 'xlsx': shutil.move(filePath,os.path.join(xlsxPath,baseName)) elif ex == 'jpeg': shutil.move(filePath,os.path.join(imgPath,baseName)) elif ex == 'pptx': shutil.move(filePath,os.path.join(pptPath,baseName)) elif ex == 'docx': shutil.move(filePath,os.path.join(docPath,baseName)) elif ex == 'txt': shutil.move(filePath,os.path.join(txtPath,baseName)) # 把D:\\\\code2022\\\\auto-work\\\\test3\\\\9.txt 剪切到D:\\\\code2022\\\\auto-work\\\\test3\\\\txt cleanDir() ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/:0:0","tags":["python"],"title":"python自动化办公之文件读写","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/"},{"categories":["编程"],"content":"纯文本文件和二进制文件的区别 纯文本文件就是只包含基本文本字符，不包含字体、大小和颜色信息的，例如txt文件 二进制文件只是除了纯文本文件外的其他文件，例如pdf，图像,excel等。 用程序读纯文本文件三步骤： open()打开，返回File对象 调用File对象的read()和write函数 调用File对象的close()函数，关闭该文件。 打开文件 filePath = r'D:\\code2022\\auto-work\\test3\\txt\\9.txt' f = open(filePath,encoding='utf-8') 读取文件内容 # read() 读取所有 content = f.read() print('txt的内容:') print(content) f.close() # 按行读取 f = open(filePath) rowIndex = 1 for line in f.readlines(): print('txt第{0}行内容:'.format(rowIndex)) print(line) rowIndex += 1 f.close() # 规定读取字节数 f = open(filePath) print('第一行内容：') print(f.readline()) print('读取5个字节：') print(f.readline(5)) f.close() 写入文件 写模式和添加模式 写模式会覆盖原来的内容 newFilePath = r'D:\\code2022\\auto-work\\test3\\txt\\9.txt' f = open(newFilePath,'w',encoding='utf-8') f.write(\"你好\\n\") f.close() f = open(newFilePath, 'a',encoding='utf-8') f.write(\"这是我用添加模式增加的内容\\n\") f.close() 练习： 将D:\\code2022\\auto-work\\test3\\txt\\10.txt中的数字转换成中文数字并且保存到源文件中 文本内容如下： 我还记得我初中3年都是在4班的，成绩一直马马虎虎，在班级前5名。 然后中考就进入了县里的重点高中。 高1的时候是在8班，换了6位同桌，其中2位是女生 到高2高3，又机缘巧合分到4班，然后就一直到了毕业。 代码实现： def convertNum(): filePath = r'D:\\code2022\\auto-work\\test3\\txt\\10.txt' f = open(filePath,'r',encoding='utf-8') newlines = [] for line in f.readlines(): newline = '' for i in range(len(line)): c = line[i] if c == '0': c = '零' elif c == '1': c = '一' elif c == '2': c = '二' elif c == '3': c = '三' elif c == '4': c = '四' elif c == '5': c = '五' elif c == '6': c = '六' elif c == '7': c = '七' elif c == '8': c = '八' elif c == '9': c = '九' newline = newline + c newlines.append(newline) f.close() f = open(r'D:\\code2022\\auto-work\\test3\\txt\\11.txt','w',encoding='utf-8') f.writelines(newlines) f.close() convertNum() 解读代码： 用utf-8编码打开文件，最外层for循环打印出每行形式，每一行都是一个列表。内层for循环，循环每一个列表中每一个字，如果碰到（0-9）就转换成相对应的汉字。保存到newlines列表中。关闭文件。创建一个新文件11.txt把处理后的列表写入11.txt中。 ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/:0:1","tags":["python"],"title":"python自动化办公之文件读写","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/"},{"categories":["编程"],"content":"shelve模块 windows 保存成三个新文件 .bak .dat .dir mac/Linux 保存成一个新文件 .db import shelve shelfFile = shelve.open(r'D:\\code2022\\auto-work\\test3\\txt\\shelve.txt') datas = {'username': 'smith','password':'123456'} shelfFile['userInfo'] = datas shelfFile.close() shelfFile = shelve.open(r'D:\\code2022\\auto-work\\test3\\txt\\shelve.txt') print(list(shelfFile.keys())) print(shelfFile['userInfo']) ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/:0:2","tags":["python"],"title":"python自动化办公之文件读写","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/"},{"categories":["编程"],"content":"读写文件总结 学习os.path的相关内容，绝对路径和相对路径，判断是否存在该路径 是否是文件或者目录，新建目录，得到该目录下所有文件等。 File对象，纯文本文件的读取方式，open()打开，read()/write()读写，close()关闭 shelve模块将数据保存到硬盘。 ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/:0:3","tags":["python"],"title":"python自动化办公之文件读写","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/"},{"categories":["编程"],"content":"使用python实现大批量文件简繁体转换 需要先安装zhconv和python-docx ToChs是繁体转换成简体，ToCht是简体转换成繁体 ToChs会把该文件夹下所有的docx文件全部处理成简体，保存为新文件，同理如ToCht. 无论是繁体转换成简体还是繁体转换成简体，都要把程序放在和文件的同级目录内。支持表格内的文字转换 原文章：文章.docx 转换后的文章：文章繁体版.docx 简体版同理 简体转繁体 # 简体转繁体 import zhconv from docx import Document import os def convert(text): rule = 'zh-hant' return zhconv.convert(text,rule) def ProcessDocx(docxName): print('正在处理'+docxName) obj = Document(docxName) for p in obj.paragraphs: p.text = convert(p.text) for t in obj.tables: for r in t.rows: for c in r.cells: c.text = convert(c.text) # 文章.docx # 文章繁体版.docx fileName = docxName.split('.') newDocxName = fileName[0] + \"繁体版\" + '.' + fileName[1] obj.save(newDocxName) print(docxName+'已经处理完毕') if __name__ == '__main__': for file in os.listdir('.'): if file.split('.')[1] == 'docx': ProcessDocx(file) 繁体转简体 # 繁体转换成简体 import zhconv from docx import Document import os def convert(text): rule = 'zh-hans' return zhconv.convert(text,rule) def ProcessDocx(docxName): print('正在处理'+docxName) obj = Document(docxName) for p in obj.paragraphs: p.text = convert(p.text) for t in obj.tables: for r in t.rows: for c in r.cells: c.text = convert(c.text) # 文章.docx # 文章简体版.docx fileName = docxName.split('.') newDocxName = fileName[0] + \"简体版\" + '.' + fileName[1] obj.save(newDocxName) print(docxName+'已经处理完毕') if __name__ == '__main__': for file in os.listdir('.'): if file.split('.')[1] == 'docx': ProcessDocx(file) ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/:0:4","tags":["python"],"title":"python自动化办公之文件读写","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC/"},{"categories":["编程"],"content":"安装第三方模块openpyxl pip3 install openpyxl 关于openpyxl模块的参考文档 . ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:1","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"使用python操作excel表格，代码如下： # 引入模块 import openpyxl import datetime # 创建工作簿并创建一个工作表 wb = openpyxl.Workbook() ws = wb.active # 可以自定义工作表名字，默认Sheet ws.title = '工作表1' # A1 单元格写入 520 ws['A1'] = 520 # A2 单元格写入一个列表 ws.append([1,2,3]) # A3 单元格写入当前时间 ws['A3'] = datetime.datetime.now() # 保存为 demo.xlsx wb.save('demo.xlsx') ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:2","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"打开excel表格 import openpyxl wb = openpyxl.load_workbook(r'D:\\code2022\\auto-work\\demo.xlsx') print(type(wb)) # \u003cclass 'openpyxl.workbook.workbook.Workbook'\u003e ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:3","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"查看工作表 print(wb.sheetnames) # ['Sheet'] ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:4","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"创建新的工作表并打印当前所有工作表 nws = wb.create_chartsheet(title = 'demo', index = 0) print(wb.sheetnames) # ['demo', 'Sheet'] ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:5","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"删除一个工作表 # 先查看所有工作表 print(wb.sheetnames) # ['demo', 'Sheet'] # 删除 demo 工作表 rem = wb.remove(wb['demo']) print(wb.sheetnames) # ['Sheet'] ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:6","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"定位单元格 ws = wb.active c = ws['A1'] # 打印行 print(c.row) # 1 # 打印列 print(c.column) # 1 # 打印当前坐标 print(c.coordinate) # A1 # 输出 A1 单元格值 print(ws['A1'].value) # 520 # 输出 A1 单元格的值 print(c.value) # 520 # 当前位置（A1）向下移动两个单元格，列不变。 d = c.offset(2,0) # 输出当前坐标 print(d.coordinate) # A3 # 输出当前坐标所对应的值 print(d.value) ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:7","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"访问多个工作表 # 从（1，1） 到（4，2）范围内所有的第一列的内容 for each_row in ws.iter_rows(min_row=1, min_col=1, max_row=4, max_col=2): print(each_row[0].value) # 输出从A1 到 C4 范围内的内容 for each_item in ws['A1':'C4']: for each_cell in each_item: print(each_cell.value, end = ' ') print('\\n') ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:8","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"拷贝工作表 ws = wb.active new = wb.copy_worksheet(ws) wb.save(r'D:\\code2022\\auto-work\\demo.xlsx') ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:9","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"个性化工作表 更改默认工作表颜色 import openpyxl wb = openpyxl.Workbook() ws1 = wb.create_sheet(title= '001') ws2 = wb.create_sheet(title= '003') ws3 = wb.create_sheet(title= '005') ws4 = wb.create_sheet(title= '007') ws1.sheet_properties.tabColor = \"FF0000\" ws2.sheet_properties.tabColor = \"00FF00\" ws3.sheet_properties.tabColor = \"0000FF\" ws4.sheet_properties.tabColor = \"880088\" wb.save(r\"D:\\code2022\\auto-work\\工作表变颜色.xlsx\") ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:10","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"调整行高和列宽 ws1.row_dimensions[2].height = 100 ws1.column_dimensions['C'].width = 50 wb.save(r'D:\\code2022\\auto-work\\工作表变颜色.xlsx') ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:11","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"合并和拆分单元格 # 合并从 A1 到 D2 范围内的所有单元格 ws2.merge_cells('A1:D2') wb.save(r'D:\\code2022\\auto-work\\工作表变颜色.xlsx') # 拆分单元格,要和合并的单元格范围一致 ws2.unmerge_cells = None wb.save(r'D:\\code2022\\auto-work\\工作表变颜色.xlsx') ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:12","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"冻结窗口 指的是无论横向还是纵向滚动单元格，最左侧和最上侧单元格不会跟随滚动而变化。 # 冻结窗口 import openpyxl wb = openpyxl.load_wordbook(r'D:\\code2022\\auto-work\\demo.xlsx') ws = wb.active ws.freeze_panes = 'B8' wb.save(r'D:\\code2022\\auto-work\\demo.xlsx') # 解冻窗口 ws.freeze_panes = None wb.save(r'D:\\code2022\\auto-work\\demo.xlsx') ","date":"2022-07-11","objectID":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/:0:13","tags":["python"],"title":"python自动化办公之excel","uri":"/python%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8A%9E%E5%85%AC%E4%B9%8Bexcel/"},{"categories":["编程"],"content":"安装及查看版本 pip3 install Django==4.0.6 # 进入python python import django print(django.get_version()) windows安装路径 C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python39\\Lib\\site-packages\\django ","date":"2022-07-09","objectID":"/django/:0:1","tags":["Django"],"title":"Django","uri":"/django/"},{"categories":["编程"],"content":"创建第一个django 项目 # 新建一个文件夹 E:\\code2022\\django\\demo # 进入文件夹 cd E:\\code2022\\django\\demo # 创建项目 mysite 是项目名称 django-admin.exe startproject mysite # 进入到mysite 然后启动项目 cd mysite python manage.py runserver \"\"\" July 08, 2022 - 15:34:30 Django version 4.0.6, using settings 'mysite.settings' Starting development server at http://127.0.0.1:8000/ \"\"\" # 访问：http://127.0.0.1:8000/ 出现网页，项目启动成功。 注意：启动项目可以指定端口，不指定默认是8000 python manage.py runserver 8002 创建网页文件views.py 在mysite文件夹内部创建 from django.http import HttpResponse def hello(requets): return HttpResponse(\"Hello world! \") 修改url路径 编辑urls.py from django.urls import path from . import views urlpatterns = [ path('hello/', views.hello), ] 测试访问： http://127.0.0.1:8000/hello/ 访问过程： 浏览器访问：http://127.0.0.1:8000/hello/ -\u003e 先到urls.py中hello路径对应的页面 views.hello-\u003e 然后执行views.py中定义的hello函数-\u003e最后把结果返回给浏览器。 创建第二个项目mysite2 # 路径 E:\\code2022\\django\\demo django-admin.exe startproject mysite2 创建和mysite2同级的文件夹templates并在其内部创建mytemp.html # 路径 E:\\code2022\\django\\demo\\mysite2 注意要和mysite2 内部的mysite2同级。 # mytemp.html 内容如下 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003e{{ hello }}\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 修改E:\\code2022\\django\\demo\\mysite2\\mysite2\\settings.py文件内容 找到刚刚创建的templates文件夹路径，修改下 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR,'templates')], 在第一行引入os模块 import os 解释os.path.john(BASE_DIR,'templates') 引入os模块，将BASE_DIR(项目绝对路径)和templates做路径拼接。拼接后的结果是：E:\\code2022\\django\\demo\\mysite2\\templates 在E:\\code2022\\django\\demo\\mysite2\\mysite2中创建views.py文件 from django.shortcuts import render def mytemp(request): context = {} context['hello'] = 'Hello World!' return render(request, 'mytemp.html', context) 修改url（E:\\code2022\\django\\demo\\mysite2\\mysite2\\urls.py） from django.urls import path from . import views urlpatterns = [ path('mytemp/', views.mytemp), ] 进入项目所在文件夹，在cmd中启动项目指定端口8002 python manage.py runserver 8002 测试访问 http://127.0.0.1:8002/mytemp/ 访问过程 127.0.0.1:8002/mytemp -\u003eurls.py中寻找/mytemp 它的映射为： views.mytemp -\u003e mytemp函数在views.py中定义 -\u003emytemp函数还定义了context空字典，传入键（hello）和值(Hello World!) 。键将在主页（mytemp.html）中调用。 -\u003e h1标签中调用键（hello） ","date":"2022-07-09","objectID":"/django/:0:2","tags":["Django"],"title":"Django","uri":"/django/"},{"categories":["编程"],"content":"django模板标签 链接 ","date":"2022-07-09","objectID":"/django/:0:3","tags":["Django"],"title":"Django","uri":"/django/"},{"categories":["编程"],"content":"列表 templates 中的 mytemp.html 中，可以用 . 索引下标取出对应的元素。 D:\\code2022\\Django\\demo\\mysite2\\mysite2\\urls.py中修改路径 from django.urls import path from . import views urlpatterns = [ path('mytemp/', views.mydef), ] 新建D:\\code2022\\Django\\demo\\mysite2\\mysite2\\views.py文件，定义mydef函数 from django.shortcuts import render def mydef(request): views_list = [\"简单示例demo1\",\"简单示例demo2\",\"简单示例demo3\"] return render(request, 'mytemp.html', {\"views_list\": views_list}) 创建模板文件夹和主页文件 D:\\code2022\\Django\\demo\\mysite2\\templates和D:\\code2022\\Django\\demo\\mysite2\\templates\\mytemp.html Tip:可以用!+Tab键快速创建html代码，然后再添加内容。s # mytemp.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cp\u003e{{ views_list }}\u003c/p\u003e # 取出整个列表 \u003cp\u003e{{ views_list.0 }}\u003c/p\u003e # 取出列表的第一个元素 \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e 设置主页文件(mytemp.html)路径 D:\\code2022\\Django\\demo\\mysite2\\mysite2\\settings.py 找到关于templates文件夹的配置 import os TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR,'templates')], 启动项目 python .\\manage.py runserver 8003 访问127.0.0.1:8003/mytemp测试。 ","date":"2022-07-09","objectID":"/django/:0:4","tags":["Django"],"title":"Django","uri":"/django/"},{"categories":["编程"],"content":"字典 D:\\code2022\\Django\\demo\\mysite3\\mysite3\\urls.py from django.urls import path from . import views urlpatterns = [ path('mytemp/', views.mydef), ] D:\\code2022\\Django\\demo\\mysite3\\mysite3\\views.py from django.shortcuts import render def mydef(request): views_dict = {'name':'简单demo演示'} return render(request,'mytemp.html', {'views_dict': views_dict}) D:\\code2022\\Django\\demo\\mysite3\\templates\\mytemp.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003cp\u003e{{ views_dict }}\u003c/p\u003e \u003cp\u003e{{ views_dict.name }}\u003c/p\u003e \u003c/head\u003e \u003cbody\u003e \u003c/body\u003e \u003c/html\u003e D:\\code2022\\Django\\demo\\mysite3\\mysite3\\settings.py import os TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR,'templates')], 启动项目并测试 python .\\manage.py runserver 8004 http://127.0.0.1:8004/mytemp ","date":"2022-07-09","objectID":"/django/:0:5","tags":["Django"],"title":"Django","uri":"/django/"},{"categories":["编程"],"content":"可迭代对象（Iterable） python中任意对象，只要它定义了可以返回一个迭代器的__iter__方法，或者定义了可以支持下标索引的__getitem__方法，那么他就是一个可迭代对象。可迭代对象就是能够提供迭代器的任意对象。 str1 = \"hello\" print(str1.__iter__()) # \u003cstr_iterator object at 0x0000022BDAF5A040\u003e ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:1:0","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"迭代器(Iterator) 任意对象，只要定义了next（python2）或者__next__方法他就是一个迭代器。 ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:2:0","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"迭代(Iteration) 从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身叫迭代。 ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:3:0","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"生成器(Generators) 生成器也是一种迭代器，但是你只能对其迭代一次。这是因为他们并没有把所有的值都存在内存中，而是在运行时生成值。大多数时候生成器是以函数是实现的。然而，它们并不返回一个值，而是yield(暂且译作“生出”)一个值。 Python内置函数：next()。它允许我们获取一个序列的下一个元素。 def generator_function(): for i in range(3): yield i gen = generator_function() print(next(gen)) # Output: 0 print(next(gen)) # Output: 1 print(next(gen)) # Output: 2 print(next(gen)) # Output: Traceback (most recent call last): # File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e # StopIteration 在yield掉所有的值后，next()触发了一个StopIteration的异常。基本上这个异常告诉我们，所有的值都已经被yield完了。 为什么我们在使用for循环时没有这个异常呢?for循环会自动捕捉到这个异常并停止调用next()。 Python中一些内置数据类型也支持迭代。 my_string = \"Yasoob\" next(my_string) # Output: Traceback (most recent call last): # File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e # TypeError: str object is not an iterator 这个异常说那个str对象不是一个迭代器。它是一个可迭代对象，而不是一个迭代器。这意味着它支持迭代，但我们不能直接对其进行迭代操作。怎样才能对它实施迭代呢？ 内置函数，iter。它将根据一个可迭代对象返回一个迭代器对象。 my_string = \"Yasoob\" my_iter = iter(my_string) print(next(my_iter)) # Output: 'Y' print(type(my_iter)) # \u003cclass 'str_iterator'\u003e ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:4:0","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"装饰器 装饰器(Decorators)是Python的一个重要部分。简单地说：他们是修改其他函数的功能的函数。 ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:5:0","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"嵌套函数解析 ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:6:0","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"从函数中返回函数 def hi(name=\"yasoob\"): def greet(): return \"now you are in the greet() function\" def welcome(): return \"now you are in the welcome() function\" if name == \"yasoob\": return greet else: return welcome a = hi() print(a) #outputs: \u003cfunction greet at 0x7f2143c01500\u003e #上面清晰地展示了`a`现在指向到hi()函数中的greet()函数 #现在试试这个 print(a()) #outputs: now you are in the greet() function 解析： 调用hi函数中创建的greet函数和welcome函数，作为结果输出出来。 问题： 在if/else语句中我们返回greet和welcome，而不是greet()和welcome()。为什么那样？这是因为当你把一对小括号放在后面，这个函数就会执行；然而如果你不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。 当我们写下a = hi()，hi()会被执行，而由于name参数默认是yasoob，所以函数greet被返回了。如果我们把语句改为a = hi(name = \"ali\")，那么welcome函数将被返回。我们还可以打印出hi()()，这会输出now you are in the greet() function。 ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:6:1","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"将函数作为参数传递给另一个参数 def hi(): return \"come from hi()\" def hello(func): print(\"I am doing some boring work before executing hi()\") print(func()) hello(hi) \"\"\" I am doing some boring work before executing hi() come from hi() \"\"\" ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:6:2","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"文件格式判断 常见的文件头字节码信息 http://doc.chacuo.net/filehead import io with open('blue.jpg', 'rb') as f: jpgdata = f.read() if jpgdata.startswith(b'\\xff\\xd8'): text = u'This is a jpg file(%d bytes long)\\n' else: text = u'This is not a jpg file(%d bytes long)\\n' with io.open('summary.txt','w',encoding='utf-8') as outf: outf.write(text % len(jpgdata)) 判断blue.jpg文件是不是jpg格式的文件。将判断结果保存到summary.txt. 提示：.jpg格式的文件头字节码为ff d8，注意读取blue.jpg文件时，要以字节方式读取。 u以unicode形式存储字符串。 ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:6:3","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"socket 模块 ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:7:0","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"udp套接字 应用层的一种编程方法 创建套接字：socket() 绑定IP端口: bind() 发送消息： sendto() 接受消息： recvfrom() 关闭套接字： close() udp 服务端代码： # 模块导入 from socket import * # 声明服务器IP, 端口 ADDR = ('0.0.0.0',8888) # 创建udp套接字 SOCK_DGRAM 表示选择的时UDP套接字 udp_socket = socket(AF_INET, SOCK_DGRAM) # 调用bind 绑定地址端口 udp_socket.bind(ADDR) # 循环接受消息 while True: # 接收消息 1024 一次能接收的最大字节数 msg, addr = udp_socket.recvfrom(1024) # 打印消息跟地址 decode() 解码 print('Recv:', addr,msg.decode()) # 回应消息 udp_socket.sendto('收到！'.encode(),addr) # 约定断开通信的 if msg == b'bye': break # 关闭套接字 udp_socket.close() udp客户端代码： # 模块导入 from socket import * # 确定服务器的地址 127.0.0.1 跟localhost 默认时本机IP ADDR = ('127.0.0.1',8888) # 创建套接字 udp_socket = socket(AF_INET, SOCK_DGRAM) # 接受消息 while True: msg = input('\u003e\u003e:') # 发送给服务器 udp_socket.sendto(msg.encode(),ADDR) # 接受服务器消息 data, addr = udp_socket.recvfrom(1024) print('来自服务器的消息:',data.decode()) # 终止客户端循环 if msg == b'bye': break udp_socket.close() ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:7:1","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"TCP编程流程 创建套接字：socket 绑定地址：bind 设置监听：listen 等待处理连接：accept 发送/接收消息：send/recv 关闭连接：close 粘包问题 产生原因 为了解决数据传输中的速率不协调问题，操作系统设置了缓冲区 实际网路工作过程比较复杂，导致消息收发不一致 tcp以字节流方式进行数据传输，在接收的时候不区分消息边界 带来问题 如果发送的消息每次都是独立的，需要接收端去独立解析消息时回带来消息误解问题 解决方式 人工设置消息边界 减缓消息发送速度 tcp服务端代码 import socket phone = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #tcp协议 # phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) phone.bind(('127.0.0.1', 9000)) #0-65535 phone.listen(5) print('staring....') while True: #链接循环 conn, client_addr=phone.accept() #(conn,client_addr) print(client_addr) while True: #通信循环 try: data = conn.recv(1024) #1024bytes? if not data:break #针对的是Linux系统，因为linux不会抛异常。windows会抛异常。 print('客户端信息', data) conn.send(data.upper()) except ConnectionResetError: break conn.close() phone.close() tcp客户端代码 import socket phone=socket.socket(socket.AF_INET, socket.SOCK_STREAM) phone.connect(('127.0.0.1', 9000)) while True: #通信循环 msg=input('\u003e\u003e: ').strip() if not msg: continue #防止发送空信息 phone.send(msg.encode('utf-8')) data = phone.recv(1024) print(data) phone.close() vscode 先运行服务端，再运行客户端。服务端和客户端分两个目录，这样可以同时运行。 ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:7:2","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"文件传输 文件传输服务端 1.建立TCP套接字 2.等待客户端内的连接 3.接收图片内容 4.保存图片 5.终止连接 # 导入模块 from socket import * import time # 创建套接字 socket = socket() # 绑定IP socket.bind(('0.0.0.0',8888)) # 设置监听 socket.listen(5) # 创建connfd connfd, addr = socket.accept() # 接收客户端数据 data = connfd.recv(1024*1024) file_name = '%d-%d-%d.jpg'%time.localtime()[:3] f = open(file_name, 'wb') f.write(data) f.close() # 关闭连接 connfd.close() socket.close() ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:7:3","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"文件传输客户端 \"\"\" 1.创建套接字 2.连接服务端 3.读取文件内容 4.发送文件内容 5.关闭连接 \"\"\" # 导入模块 from socket import * # 创建套接字 socket = socket() # 连接服务端 socket.connect(('127.0.0.1',8888)) # 读入文件内容 f = open('2.jpg', 'rb') data = f.read() # 发送内容 socket.send(data) f.close() socket.close() ","date":"2022-07-07","objectID":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/:7:4","tags":["python"],"title":"生成器-可迭代对象-迭代器-迭代","uri":"/%E7%94%9F%E6%88%90%E5%99%A8-%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1-%E8%BF%AD%E4%BB%A3%E5%99%A8-%E8%BF%AD%E4%BB%A3/"},{"categories":["编程"],"content":"函数基础 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:1:0","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"函数基本使用 函数定义 定义函数格式如下： def 函数名(): 函数封装的代码 ... 1.def是英文define的缩写 2.函数名称 应该能够表达 函数封装代码的功能，方便后续的调用 函数名称 的名命应该 符合标识符的名命规则 可以由 字母、下划线和数字组成 不能以数字开头 不能与关键字重名 函数调用 调用函数很简单，通过函数名()即可完成对函数的调用。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:1:1","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"编写第一个函数 需求： 1.编写一个打招呼say_hello的函数，封装三行打招呼代码 2.在函数下方调用打招呼代码 name = '小明' # 解释器知道这里定义了一个函数 def say_hello(): print('hello 1') print('hello 2') print('hello 3') # 只有在调用函数时，之前定义的函数才会被执行 # 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码 say_hello() print(name) 用 单步执行 F8 和 F7 观察以上代码的执行过程 定义好函数后，只表示这个函数封装了一段代码而已 如果不主动调用函数，函数是不会主动执行的 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:1:2","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"思考 能否将 函数调用 放在 函数定义的上方？ 不能 因为在 使用函数名调用之前，必须要保证 python已经知道函数的存在 否则控制台会提示NameError: name 'say_hello' is not defined(名称错误：say_hello这个名字没有被定义) ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:1:3","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"pycharm 的调试工具 F8 step over 可以单步执行代码，会把函数调用看作是一行代码直接执行 F7 step into 可以单步执行代码, 如果是函数，会进入函数内部。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:1:4","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"函数的文档注释 在开发中，如果希望给函数添加注释，应该在 定义函数 的下方，使用 连续的三对引号 在 连续的三对引号 之间编写对函数的说明文字 在函数调用位置，使用快捷键 ctrl + Q可以查看函数说明信息 注意： 因为 函数体行对比较独立，函数定义的上方，应该和其他代码（包括注释）保留两个空行。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:2:0","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"函数参数的使用 在函数名的后面的小括号内部填写 参数 多个参数之间使用,分隔 def sum_2_num(num1, num2): res = num1 + num2 print(\"%d + %d = %d\" % (num1, num2, res)) sum_2_num(10, 20) sum_2_num() # 不传参时会报错。TypeError: sum_2_num() missing 2 required positional arguments: 'num1' and 'num2' ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:2:1","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"参数的作用 函数， 把 具有独立功能的代码块组织为一个小模块，在需要的时候 调用。 函数的参数，增加函数的 通用性，针对 相同的数据处理逻辑，能够使用更多的数据 1.在函数内部，把参数当作 变量 使用，进行需要的数据处理 2.函数调用时，按照函数定义的参数顺序， 把 希望在函数内部处理的数据，通过 参数传递。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:2:2","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"函数的返回值 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理。 返回值 是函数 完成工作后，最后 给调用者的一个结果。 在函数中使用return关键字可以返回结果。 调用函数一方，可以使用变量来接收函数的返回结果。 注意：return表示返回，后续代码都不会被执行 def sum_2_num(num1, num2): \"\"\"对两个数字求和\"\"\" return num1 + num2 # 调用函数，并使用 res 变量接收计算结果 res = sum_2_num(10, 20) print(\"计算结果是 %d\" % res) # 计算结果是 30 多个返回值 def divid(a,b): shang = a//b yushu = a%b return shang,yushu sh,yu = divid(5,2) print(\"商: %d, 余数：%d\"%(sh,yu)) 输出 商: 2, 余数：1 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:2:3","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"函数的嵌套调用 一个函数里面又调用了另外一个函数test1 如果函数test2中，调用了另外一个函数test1 那么执行到调用test1函数时，会先把函数test1中的任务都执行完 才会回到test2中调用函数test1的位置，继续执行后续的代码。 def test1(): print(\"*\" * 50) print(\"test 1\") print(\"*\" * 50) def test2(): print(\"_\" * 50) print(\"test 2\") test1() print(\"_\" * 50) test2() 结果如下 简单说就是按从上到下的顺序执行。 __________________________________________________ test 2 ************************************************** test 1 ************************************************** __________________________________________________ ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:2:4","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"函数嵌套的演练–打印分割线 体会一下工作中 需求是多变的 需求1 定义一个print_line函数能够打印*组成的 一条分割线 def print_line(): print(\"*\" * 50) # print_line() 需求2 定义一个可以打印任意字符的分割线函数 def print_line_1(char): print(char * 50) # print_line_1(\"_\") 需求3 定义一个函数能够打印任意重复次数的分割线 def print_line_2(char, num): print(char * num) # print_line_2(\"_\", 50) 需求4 定义一个函数能够打印5行分割线 分割线要求要符合需求3 def print_line_3(char, num): row = 0 while row \u003c 5: print_line_2(char, num) row += 1 print_line_3('*', 30) ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:2:5","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"全局变量和局部变量 全局变量和局部变量相同名字 a = 100 def test1(): a = 300 # 局部变量优先使用 print(\"teest1---------修改前: a= %d\"%a) a = 200 print(\"teest1---------修改后: a= %d\"%a) def test2(): print(\"teest2---------a= %d\"%a) # 没有局部变量，默认使用全局变量 test1() test2() 输出结果 teest1---------修改前: a= 300 teest1---------修改后: a= 200 teest2---------a= 100 在函数中修改全局变量 a = 100 def test1(): global a # 声明全局变量在函数中的标识符 print(\"teest1---------修改前: a= %d\"%a) a = 200 print(\"teest1---------修改后: a= %d\"%a) def test2(): print(\"teest2---------a= %d\"%a) # 没有局部变量，默认使用全局变量 test1() test2() 输出结果 teest1---------修改前: a= 100 teest1---------修改后: a= 200 teest2---------a= 200 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:2:6","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"使用模块中的函数 模块是python程序架构的一个核心概念 模块好比是工具包，要想使用这个工具包中的工具，就需要 导入import 这个模块 每一个以拓展名py结尾 的python源代码都是一个模块 在模块中定义的 全局变量、 函数 都是模块额能够提供给外界直接使用的工具 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:3:0","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"第一个模块使用 步骤 新建mypython模块.py name = \"mypython模块\" 创建另一个文件imp_mypython模块.py来引入模块mypython模块.py。 import mypython模块 print(mypython模块.name) 执行结果 mypython模块 小结 可以在一个python文件中 定义变量 或者函数 然后在另一个文件中使用import导入这个模块 导入之后，就可以使用模块名.变量/模块名.函数的方式，使用这个模块中定义的变量或者函数 模块可以让曾经编写过的代码 方便的被复用！ ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:3:1","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"模块名也是一个标识符 标识符可以由 字母、下划线和数字组成 不能以数字开头 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/:3:2","tags":["python"],"title":"python回炉重造-函数","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"集合 特性： 1.无序性： 一个集合中，每个元素的地位都是相同的，元素之间是无序的 2.互异性： 一个集合中，任何两个元素都是不同的，即元素在集合中只能出现一次 3.确定性： 给定一个集合和一个任意元素，给袁思要么属于这个集合，要么不属于这个集合，二者必居其一，不允许有模棱两可的情况出现。 集合的成员运算在性能上要优于列表的成员 运算，这是集合的底层存储特性（哈希存储）决定的。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/:1:0","tags":["python"],"title":"python回炉重造-集合","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"创建集合 用set()创建，或者用 {}定义一个空集合，但{}中至少要有一个元素，没有元素就不是空集合而是空字典了。也可以将其他序列转换成集合，例如：set('hello')会得到一个包含4个字符的集合（重复的l会被去掉）。还可以用生成式语法来创建集合，和用生成式创建列表一样。要知道集合中有多少个元素，还是使用内置函数len。使用for循环可以实现对集合元素的遍历。 # 创建集合（重复元素不会出现在集合中，因此常用集合这一特性去重！！） set1 = {1, 2, 3, 3, 3, 2} print(set1) # {1, 2, 3} print(len(set1)) # 3 # 创建集合构造器语法 set2 = set('hello') print(set2) # {'o', 'l', 'e', 'h'} # 将列表转换成集合（可以去掉列表中重复的元素） set3 = set([1,2,3,3,2,1]) print(set3) # {1, 2, 3} # 创建集合的生成式语法（将列表生成式的[] 换成{}） set4 = {num for num in range(1,20) if num % 3 == 0 or num % 5 == 0} print(set4) # {3, 5, 6, 9, 10, 12, 15, 18} # 集合元素的循环遍历 for elem in set4: print(elem) 注意：集合中的元素必须是hashable类型。hashable类型指的是能够计算出哈希码的数据类型。可以暂时将哈希码理解为和变量对应的唯一的ID值。**通常不可变类型都是hashable类型。**如整数、浮点、字符串、元组等。而可变类型都不是hashable类型，因为可变类型无法确定唯一的ID值，所以也就不能放到集合中。集合本身也是可变类型，所以集合不能作为集合中的元素。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/:1:1","tags":["python"],"title":"python回炉重造-集合","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"集合的运算 python为集合类型提供了非常丰富的运算符，主要包括:成员运算、交集运算、并集运算、差集运算、比较运算（相等性、子集、超集）等。 成员运算 通过成员运算in、not in检查元素是否在集合中 set1 = {11,12,13,14,15} print(10 in set1) # False print(15 in set1) # True set2 = {'python', 'Java', 'Go', 'swift'} print('Ruby' in set2) # False print('Java' in set2) # True 交并差运算 python中的集合跟数学上的集合一样。可以进行交集、并集、差集等运算，而且可以通过运算符和方法调用方式来操作，代码如下。 set1 = {1,2,3,4,5,6,7} set2 = {2,4,6,8,10} # 交集 # 方式一：使用 \u0026 运算符 print(set1 \u0026 set2) # {2, 4, 6} # 方法二： 使用intersection方法 print(set1.intersection(set2)) # {2, 4, 6} # 并集 # 方法一： 使用 | 运算符 print(set1 | set2) # {1, 2, 3, 4, 5, 6, 7, 8, 10} # 方法二： 使用union方法 print(set1.union(set2)) # {1, 2, 3, 4, 5, 6, 7, 8, 10} # 差集 # 方法一： 使用 - 运算符 print(set1 - set2) # {1, 3, 5, 7} # 方法二： 使用difference 方法 print(set1.difference(set2)) # {1, 3, 5, 7} # 对称差 # 方法一： 使用 ^ 运算符 print(set1 ^ set2) # {1, 3, 5, 7, 8, 10} # 方法二： 使用 方法 print(set1.symmetric_difference(set2)) # {1, 3, 5, 7, 8, 10} # 方法三： 对称差相当于两个集合的并集减去交集 print((set1 - set2) - (set1 \u0026 set2)) # {1, 3, 5, 7} 总结：对于两个集合求交集，\u0026运算符和intersection方法的作用是完全相同的，使用运算符的方式更直观而且代码也比较简短。 比较运算 两个集合可以用==和!=进行相等性判断，如果两个集合中的元素完全相同，那么==比较的结果就是 True，否则就是False，如果集合A中的任意一个元素都是集合B的元素，那么集合A称为集合B的子集。 set1 = {1,3,5} set2 = {1,2,3,4,5} set3 = set2 # \u003c 运算符表示真子集， \u003c= 表示子集 print(set1 \u003c set2, set1 \u003c= set2) # True True print(set2 \u003c set3, set2 \u003c= set3) # False True # 通过issubset 方法也能进行子集判断 print(set1.issubset(set2)) # True # 反过来可以用issuperset 或\u003e运算符进行超集判断 print(set2.issuperset(set1)) # True print(set2 \u003e set1) # True 集合的方法 python中的集合是可变类型，我们可以通过集合类型的方法为集合添加或删除元素。 # 创建一个空集合 set1 = set() # 通过add方法添加元素 set1.add(33) set1.add(55) set1.update({1,10,100,1000}) print(set1) # {33, 1, 100, 55, 1000, 10} # 通过discard方法删除指定元素 set1.discard(100) set1.discard(99) # 元素不存在不会抛出异常 和remove方法对比。 print(set1) # {33, 1, 55, 1000, 10} # 通过remove方法删除指定元素，建议先做成员运算再删除 # 否则元素如果不在集合中就会引发KeyError异常 set1.remove(99) print(set1) # KeyError: 99 # pop方法可以从集合中随机删除一个元素并返回该元素 print(set1.pop()) # 33 # clear方法可以清空整个集合 set1.clear() print(set1) # set() 如果要判断两个集合有没有相同的元素可以使用isdisjoint方法，没有相同元素返回True,否则返回 False，代码如下。 set1 = {'Java', 'Python', 'Go', 'Kotlin'} set2 = {'Kotlin', 'Swift', 'Java', 'Objective-C', 'Dart'} set3 = {'HTML', 'CSS', 'JavaScript'} print(set1.isdisjoint(set2)) # False print(set1.isdisjoint(set3)) # True ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/:1:2","tags":["python"],"title":"python回炉重造-集合","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"不可变集合 python中还有一种不可变类型的集合，名字叫frozenset。set和frozenset的区别就如同list跟tuple的区别。frozenset由于是不可变类型，能够计算出哈希码，因此它可以作为set中的元素。除了不能添加和删除元素，frozenset在其他方面跟set基本一样。 set1 = frozenset({1,3,5,7}) set2 = frozenset(range(1,6)) print(set1 \u0026 set2) # frozenset({1, 3, 5}) print(set1 | set2) # frozenset({1, 2, 3, 4, 5, 7}) print(set1 - set2) # frozenset({7}) print(set1 \u003c set2) # False ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/:1:3","tags":["python"],"title":"python回炉重造-集合","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"总结 python中集合底层使用了哈希存储的方式。集合是一种容器，元素必须是hashable类型，与列表不同的地方在于集合中元素没有序、不能用索引运算、不能重复。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/:1:4","tags":["python"],"title":"python回炉重造-集合","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9B%86%E5%90%88/"},{"categories":["编程"],"content":"列表常用操作 在ipython3中定义一个列表，例如：name_list = [] 输入name_list.按下Tab键，ipython会提示能够使用的方法如下： name_list.append name_list.count name_list.insert name_list.reverse name_list.clear name_list.extend name_list.pop name_list.sort name_list.copy name_list.index name_list.remove 序号 分类 关键字/函数/方法 说明 1 增加 列表.insert(索引,数据) 在指定位置插入数据 列表.append(数据) 在末尾追加数据 列表.extend(列表2) 将列表2的数据追加到列表 2 修改 列表[索引] = 数据 修改指定索引的数据 3 删除 del 列表[索引] 删除指定索引的数据 列表.remove[数据] 删除第一个出现的指定数据 列表.pop 删除末尾 数据 列表.pop(索引) 删除指定索引数据 列表.clear 清空列表 4 统计 len(列表) 列表长度 列表.count(数据) 数据在列表中出现的次数 5 排序 列表.sort() 升序排序 列表.sort(reverse=True) 降序排序 列表.reverse() 逆序、反转 del关键字 使用del关键字（delete）同样可以删除列表元素 del关键字本质上是用来将一个变量从内存中删除的 如果使用del关键字将变量从内存中删除，后续的代码就不能使用这个变量了 del name_list[1] 在日常开发中，要从列表删除数据，建议用列表提供的方法。 关键字、函数和方法 关键字是python内置的、具有特殊意义的标识符 import keyword print(keyword.kwlist) print(len(keyword.kwlist)) 关键字后面不需要使用括号 函数 封装了独立功能，可以直接调用 函数名(参数) 函数需要死记硬背 方法 和函数类似，同样是封装了独立的功能 方法 需要通过 对象来调用，表示针对这个对象要做的操作。 对象.方法名（参数） 在变量后面输入.，然后选择针对这个变量要执行的操作，记忆起来比函数要简单的多。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/:1:0","tags":["python"],"title":"python回炉重造-列表","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/"},{"categories":["编程"],"content":"循环遍历 遍历 就是 从头到尾 依次 从列表中获取数据 在 循环体内部 针对 每一个元素，执行相同操作 在 python中为了提高列表的遍历效率，专门提供的 迭代iteration遍历 使用 for就能实现迭代遍历 # for 循环内部使用的变量 in 列表 for name in name_list: 循环内部针对列表元素进行操作 print(name) ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/:2:0","tags":["python"],"title":"python回炉重造-列表","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/"},{"categories":["编程"],"content":"浅拷贝和深拷贝 浅拷贝：利用列表的 copy() 方法或者切片来实现 深拷贝：利用 copy 模块的 deepcopy() 函数来实现 浅拷贝可以用于处理一维列表，对于嵌套列表的拷贝，只能拷贝第一层数据，其余仅拷贝其引用： \u003e\u003e\u003e x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] \u003e\u003e\u003e y = x.copy() \u003e\u003e\u003e x[1][1] = 0 \u003e\u003e\u003e x [[1, 2, 3], [4, 0, 6], [7, 8, 9]] \u003e\u003e\u003e y [[1, 2, 3], [4, 0, 6], [7, 8, 9]] 深拷贝可以用于处理多维列表： \u003e\u003e\u003e import copy \u003e\u003e\u003e x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] \u003e\u003e\u003e y = copy.deepcopy(x) \u003e\u003e\u003e x[1][1] = 0 \u003e\u003e\u003e x [[1, 2, 3], [4, 0, 6], [7, 8, 9]] \u003e\u003e\u003e y [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/:3:0","tags":["python"],"title":"python回炉重造-列表","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/"},{"categories":["编程"],"content":"小结 列表浅拷贝只是外层对象拷贝，将原对象拷贝的同时，不会拷贝对象中所引用的子对象 copy() 切片[:] 浅拷贝，如果包含嵌套对象，那么拷贝的只是其引用 列表的深拷贝将原对象拷贝的同时，也将对象中所有引用的子对象一并进行拷贝。 copy.copy() # 浅拷贝 copy.deepcopy() ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/:3:1","tags":["python"],"title":"python回炉重造-列表","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/"},{"categories":["编程"],"content":"查找特定下标范围的元素 mylist = ['a','c','b','a'] print(mylist.index('a',1,4)) # 查找特定下标范围的元素，并返回找到对应数据的下标。 范围区间，左闭右开。开区间取不到。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/:3:2","tags":["python"],"title":"python回炉重造-列表","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/"},{"categories":["编程"],"content":"列表元素删除 moviename = ['apple','banana','糖豆人','apple'] print(\"-------删除前，电影列表的数据-----\") for name in moviename: print(name) # moviename.pop() # del moviename[0] moviename.remove('apple') # 多个重复元素只删除最近的一个 print(\"-------删除后，电影列表的数据-----\") for name in moviename: print(name) ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/:4:0","tags":["python"],"title":"python回炉重造-列表","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/"},{"categories":["编程"],"content":"列表元素反转与排序 a = [1,3,4,5,612,29] a.reverse() print(a) # [29, 612, 5, 4, 3, 1] a.sort() # 升序 print(a) # [1, 3, 4, 5, 29, 612] a.sort(reverse=True) # [612, 29, 5, 4, 3, 1] 降序 print(a) ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/:4:1","tags":["python"],"title":"python回炉重造-列表","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/"},{"categories":["编程"],"content":"多个列表嵌套元素取法 schoolName = [[\"北京大学\",\"清华大学\"],[\"南开大学\",\"天津大学\",\"天津师范大学\"],[\"山东大学\",\"北京航空航天大学\"]] print(schoolName[0][0]) # 北京大学 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/:4:2","tags":["python"],"title":"python回炉重造-列表","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/"},{"categories":["编程"],"content":"练习 需求：不同的人随机分配3个办公室，一个人只属于一个办公室，可以多人在一个办公室。 import random # 三个空办公室 offices = [[],[],[]] # 6个待分配的人 names = [\"A\",\"B\",\"C\",\"D\",\"E\",\"F\"] # 给6个人随机分配到3个办公室 for name in names: index = random.randint(0,2) # 获得0-2范围内随机整数 offices[index].append(name) # 展示办公室活动人员基本信息 i = 1 for office in offices: print(\"办公室%s的人数为:%d\"%(i,len(office))) # office的列表长度就是办公室中的人数 i += 1 for name in office: # 展示每个办公室中的人员信息 print(\"%s\"%name,end=\"\\t\") print(\"\\n\") print(\"_\"*20) 程序执行结果 办公室1的人数为:1 A ____________________ 办公室2的人数为:4 B C E F ____________________ 办公室3的人数为:1 D ____________________ ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/:4:3","tags":["python"],"title":"python回炉重造-列表","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/"},{"categories":["编程"],"content":"列表同时取出下标和元素小技巧 mylist = [1,20,200,2000,3,90] for i,v in enumerate(mylist): print(i,v) 输出结果 0 1 1 20 2 200 3 2000 4 3 5 90 还可以从1开始计数 mylist = [1,20,200,2000,3,90] for i,v in enumerate(mylist): print(i+1,v) ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/:4:4","tags":["python"],"title":"python回炉重造-列表","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%88%97%E8%A1%A8/"},{"categories":["编程"],"content":"面向对象编程入门 程序是指令的集合 函数： 把相互独立且经常重复使用的代码放置到函数中，在需要使用这些代码的时候调用函数即可。 在面向对象编程的世界里，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为对象。对象可以接收消息。解决问题的方法是创建对象并向对象发出各种各样的消息。通过消息的传递，程序中的多个对象可以协同工作，这样就能构造出复杂的系统并解决现实中的问题。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:1:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"类和对象 面向对象编程：把一组数据和处理数据的方法组成对象，把行为相同的对象归纳为类，通过封装隐藏对象的内部细节，通过继承实现类的特化和泛化，通过多态实现基于对象类型的动态分派。 对象（object） 类（class） 封装（encapsulation） 继承（inheritance） 多态（polymorphism） 在面向对象编程中，**类是一个抽象的概念，对象是一个具体的概念。**我们把同一类对象的共同特征抽出来就是一个类。比如 人类 就是一个抽象概念，我们每个人就是人类的这个抽象概念下的实实在在的存在，也就是一个对象。简而言之，类是对象的蓝图和模板，对象是类的实例，是可以接收消息的实体。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:1:1","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"类属性和类方法 术语–实例 1.使用面向对象开发， 先设计类 2.使用 **类名()**创建对象，创建对象 的动作有两步 ​ 1.在内存空间中为对象 分配空间 2. 调用初始化方法`__init__`为对象初始化 3.对象创建后， 内存中就有了一个对象 的实实在在 的存在 – 实例 因此，通常也会把： 创建出来的 对象 叫做 类的实例 创建对象的 动作 叫做 实例化 对象的属性 叫做 实例属性 对象调用的方法 叫做 实例方法 在程序执行时： 1.对象各自拥有自己的 实例属性 2.调用对象方法，可以通过self. 访问自己的属性 调用自己的方法 结论 每一个对象 都有自己 独立的内存空间，保存各自不同的属性 多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用 传递到方法内部 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:2:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"类是一个特殊的对象 python中 一切皆对象 class AAA: 定义的类属于 类对象 obj1 = AAA()属于 实例对象 在程序运行时， 类 同样 会被加载到内存 在 python中， 类是一个特殊的对象 – 类对象 在程序运行时， 类对象 在内存中 只有一份， 使用 一个类 可以创建出 很多个对象实例 除了封装 实例的 属性 和方法外，类对象 哈可以拥有自己的 属性和方法 类属性 类方法 通过 类名.的方式 可以访问类的属性 或者 调用类的方法 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:2:1","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"定义类 在python中，用class关键字加上类名来定义类，通过缩进确定类的代码块。类的代码块中写函数，这些函数是对一类对象共同的动态特征的提取。写在类里面的函数我们称之为方法。方法是对象的行为，也就是对象可以接收的消息。方法的第一个参数是self，它代表接收这个消息的对象本身。 \"\"\" 类名首字母要大写，Student类中定义了 study 和 play 两个方法。 两个方法第一个参数`self`代表接收消息的学生对象，`study`方法的第二个参数是学习的课程名称。 \"\"\" class Student: def study(self, course_name): print(f'学生正在学习{course_name}.') def play(self): print(f'学生正在玩游戏.') ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:3:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"创建和使用对象 # 当前的stu1 是Student这个类的对象 是一个具体的实例 stu1 = Student() stu2 = Student() # 当前输出的值为这个具体实例在内存中的地址 十六进制的值 print(stu1) # \u003c__main__.Student object at 0x7f4c9b62af70\u003e print(stu2) # \u003c__main__.Student object at 0x7f4c9b5ffb50\u003e print(hex(id(stu1)), hex(id(stu2))) # 0x7f4c9b62af70 0x7f4c9b5ffb50 定义变量其实是保存 一个对象在内存中的地址（十六进制形式），和用id函数查看的值是相同的。 通过这个逻辑地址，就能在内存中找到这个对象。 常见报错，类没有实例化。 Student.study('python') # TypeError: study() missing 1 required positional argument: 'course_name' 正确写法，在调用类中方法时先 进行类的实例化。类名后加小括号就是类的实例化。 Student().study('java') # 学生正在学习java. 也可以将类实例化后赋给一个变量，像stu1 = Student()。后面调用类中的方法时就可以用变量名.方法名来调用方法。例如stu1.play()。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:3:1","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"初始化方法 上面创建的对象只有行为没有属性，使用__init__方法来初始化属性。 修改Student类，给学生对象添加name（姓名）和age（年龄）两个属性。 class Student: \"\"\"初始化方法 给当前对象创建属性\"\"\" def __init__(self,name, age): # 给当前类添加属性 self.name = name self.age = age def study(self, course_name): # 属性使用self 进行调用 参数是直接调用 print(f'{self.name}正在学习{course_name}.') def play(self): \"\"\"玩耍\"\"\" print(f'{self.name}正在玩游戏.') 由于初始化方法除了self之外还有两个参数，所以调用Student 类的构造器创建的对象时要传入这两个参数。 stu1 = Student('john', 20) stu1.study('python') # john正在学习python. stu2 = Student('smith', 30) stu2.play() # smith正在玩游戏. ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:4:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"打印对象 在python中，以两个下划线__、开头和结尾的方法通常都是有特殊用途和意义的方法，我们一般称之为 魔术方法或魔法方法。 如果我们在打印对象时候不希望看到对象的地址二十看到我们自定义的信息。可以通过在类中使用__repr__魔术方法来做到。该方法返回的字符串就是用print函数打印对象的时候会显示的内容。 # 使用类中内置魔术方法来实现 def __repr__(self): return f'{self.name}: {self.age}' # 类实例化 stu1 = Student('john', 20) # 打印当前对象 print(stu1) # john: 20 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:5:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"面向对象的支柱 封装： 隐藏一切可以隐藏的实现细节，只向外界暴露简单的调用接口。 在类型中定义的对象其实是一种封装。在创建对象后，只需要给对象发送一个消息就可以执行方法中的代码，也就是说我们在只知道方法名字和参数（方法外部视图），不知道方法内部实现细节（方法内部视图）的情况下就完成了对方法的使用。 根据 职责将属性和方法封装到一个抽象的类中 继承：实现代码的重用，相同的代码不需要重复编写 多态：不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:6:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"继承 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:7:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"单继承 继承的概念： 子类 拥有 父类的所有方法和属性 案例1：不使用继承创建两个类动物类和狗类 \"\"\" 开发两个类 动物类 狗类 动物类具有四个特性 吃 喝 跑 睡 狗的特性 吃 喝 跑 睡 汪汪叫 \"\"\" class Animal: def eat(self): print('吃') def drink(self): print('喝') def run(self): print('跑') def sleep(self): print('睡') class Dog: def eat(self): print('吃') def drink(self): print('喝') def run(self): print('跑') def sleep(self): print('睡') def bark(self): print('汪汪叫') laoha = Dog() laoha.eat() laoha.drink() laoha.run() laoha.sleep() laoha.bark() \"\"\" 当前动物类和狗类的四个方法已经重复了 如何解决这样的情况 继承 \"\"\" 使用继承特性较少重复代码。 class Animal: def eat(self): print('吃') def drink(self): print('喝') def run(self): print('跑') def sleep(self): print('睡') class Dog(Animal): def bark(self): print('汪汪叫') # 类实例化 laoha = Dog() # 调用类中方法 laoha.eat() laoha.drink() laoha.run() laoha.sleep() laoha.bark() ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:7:1","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"继承语法 class 类名(父类名): pass 子类 继承自 父类，可以直接享受 父类中 已经封装好的方法，不需要再次开发。 子类 中应该根据 职责，封装 子类特有的属性和方法 专业术语 Dog 类是Animal类的子集，Animal类是Dog类的父类，Dog类从 Animal类继承 Dog类是 Animal类的派生类，Animal类是Dog类的基类，Dog类从 Animal类派生 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:7:2","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"继承的传递性 C类从B类继承，B类又从A类继承 那么C类就具有B类和A类的所有属性和方法 子类 拥有 父类 以及 父类的父类 中封装的所有属性和方法。 应用场景 当 父类 的方法实现不能满足子类需求时，可以对方法进行重写。 Dog是XiaoTianQuan的父类， Animal又是Dog的父类。 所以XiaoTianQuan可以继承Dog和Animal中定义的所有方法。 class Animal: def eat(self): print('吃') def drink(self): print('喝') def run(self): print('跑') def sleep(self): print('睡') class Dog(Animal): def bark(self): print('汪汪叫') class XiaoTianQuan(Dog): def fly(self): print(\"飞\") # 类实例化 wangwang = XiaoTianQuan() # 可以调用自身定义的方法 wangwang.fly() # 也可以调用父类以及父父类的方法 wangwang.bark() wangwang.run() ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:7:3","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"方法的重写 子类 拥有 父类的 所有方法 和属性 子类 继承自 父类，可以直接 享受 父类中已经封装好的方法， 不需要再次开发。 重写 父类方法有两种情况： 1.覆盖 父类的方法 如何在开发中， 父类的方法实现 和 子类的方法实现，完全不同。 就可以使用 覆盖 的方法，在子类中 重新编写 父类的方法实现 具体的实现方式，就相当于在 子类中定义了一个 和父类同名的方法并且实现。 class Animal: def eat(self): print('吃') def drink(self): print('喝') def run(self): print('跑') def sleep(self): print('睡') class Dog(Animal): def bark(self): print('汪汪叫') class XiaoTianQuan(Dog): def fly(self): print(\"飞\") # bark方法的重写，规则：和继承的方法名称一样。 def bark(self): print(\"叫的和神一样....\") wangwang = XiaoTianQuan() wangwang.bark() # 叫的和神一样.... \"\"\" 哮天犬是神犬和普通狗叫声不一样, XiaoTianQuan 类中定义自己的方法，由于继承了父类（Dog）类的bark 方法。这里 覆盖父类的bark方法，创建一个和父类同名的方法。来区分神犬的叫声。 \"\"\" 小结： 在子类中重写了父类的方法后，在进行方法调用时会执行子类中重写的方法。 2.对父类方法进行扩展 如果在开发中， 子类的方法实现中 包含 父类的方法实现 父类原本封装的方法实现 是 子类方法的一部分 就可以使用 扩展 的方式 1.在子类中 重写 父类的方法 2.在需要的位置使用super().父类方法来调用父类方法的执行 3.代码其他的位置针对子类的需求，编写 子类特有的代码实现 关于 super 在python中super是一个 特殊的类 super()就是使用super类创建出来的对象 最常 使用的场景是 在重写父类方法时，调用 在父类中封装的方法实现。 class Animal: def eat(self): print('吃') def drink(self): print('喝') def run(self): print('跑') def sleep(self): print('睡') class Dog(Animal): def bark(self): print('汪汪叫') class XiaoTianQuan(Dog): def fly(self): print(\"飞\") def bark(self): # 在当前方法中去调用父类方法 # 使用super方法 print(\"叫的和神一样....\") # super() 也是一个对象 super().bark() # 当前的子类方法进行扩展 print('这是一个测试...') wangwang = XiaoTianQuan() wangwang.bark() # 叫的和神一样.... # 汪汪叫 # 这是一个测试... \"\"\" XiaoTianQuan类不仅要调用自身的bark方法，也要调用它所继承父类（Dog）的bark方法。 使用super().方法 来实现 \"\"\" 调用父类方法的另外一种方式 在 python2.x 中，如果需要调用父类的方法，还可以使用以下方式： 父类名.方法(self) 这种方式，目前在python 3.x还支持这种方式 这种方式 不推荐使用，因为一旦 父类发生变化，方法调用位置的 类名 同样需要修改 提示 在开发中，父类名和super()两种方式不要混用 如果使用 当前子类名 调用方法，会形成递归调用，出现死循环。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:7:4","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"父类的 私有属性 和私有方法 1.子类对象 不能在自己的方法内部，直接访问父类的 私有属性或私有方法 2.子类对象 可以通过 父类的公有方法间接访问到 私有属性或私有方法 私有属性、方法是对象的隐私，不对外公开，外界以及子类都不能直接访问。 示例 代码理解父类的私有属性和私有方法 class A: # 创建类属性 def __init__(self): # 公共属性 self.num_1 = 100 # 私有属性 self.__num_2 = 200 # 创建私有方法 def __test(self): print(f'私有属性与公共属性的值：{self.num_1}, {self.__num_2}') class B(A): def demo(self): # 父类方法 super().__test() \"\"\" B 具有父类的所有属性和方法 如果是私有属性和私有方法的情况下 不可以直接去使用。 \"\"\" b = B() # 使用子类去打印父类的公共属性 print(b.num_1) # 打印父类中的私有属性 我们不可以直接打印弗莱的私有属性 print(b.__num_2) # AttributeError: 'B' object has no attribute '__num_2' # 调用父类中的私有方法 不允许子类直接去调用父类的私有方法 b.demo() # AttributeError: 'super' object has no attribute '_B__test' 子类访问父类的私有属性和私有方法 class A: def __init__(self): self.num_1 = 100 self.__num_2 = 200 # 创建私有方法 def __test(self): print(f'私有属性与公共属性的值：{self.num_1}, {self.__num_2}') # 创建公有方法 def test(self): print(f'父类中的公共方法输出私有属性: {self.__num_2}') # 在公有方法中调用私有方法 self.__test() class B(A): # 公有方法 def demo(self): # 1. 在子类方法中访问父类的公共属性 print(f'子类方法输出父类中的公有属性:{self.num_1}') # 2. 在子类中调用父类的公有方法输出私有属性 self.test() b = B() b.demo() \"\"\" 子类方法输出父类中的公有属性:100 父类中的公共方法输出私有属性: 200 私有属性与公共属性的值：100, 200 \"\"\" ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:7:5","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"多继承 概念 子类 可以拥有 多个父类，并且具有 所有父类的属性 和方法 例如： 孩子 会继承自己 父亲和母亲的特性 语法 class 子类名(父类名1, 父类名2...): pass 举例 class A: def test(self): print(\"test 方法\") class B: def demo(self): print(\"demo 方法\") class C(A, B): pass # 创建C类对象 c = C() c.test() c.demo() \"\"\" 在python中 面向对象是支持多个类进行继承的 子类同时具有父类中的所有方法和所有属性 \"\"\" ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:7:6","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"多继承的使用注意事项 如果 不同的父类 中存在 同名的方法，子类对象 在调用方法时，会调用 哪一个父类中的方法呢？ 提示：开发时，应该尽量避免这种容易产生混淆的情况！ —— 如果 父类之间存在同名的属性或者方法，应该尽量避免使用多继承。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:7:7","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"python 中的MRO——方法搜索顺序 python中针对 类 提供了一个 内置属性 __mro__可以查看 方法 搜索顺序 MOR是 method resolution order,主要用于 在多继承时判断方法、属性的调用路径 print(C.__mro__) 输出结果 (\u003cclass '__main__.C'\u003e, \u003cclass '__main__.A'\u003e, \u003cclass '__main__.B'\u003e, \u003cclass 'object'\u003e) 在搜索方法时，是按照__mro__的输出结果 从左到右的顺序查找的 如果在当前类中找到方法，就直接执行，不再搜索。 如果 没有找到，就查找下一个类 中是否有对应的方法，如果找到，就直接执行，不再搜索。 如果找到最后一个类，还没有找到方法，程序报错。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:7:8","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"新式类和旧式类（经典类） object是python为所有对象提供的 基类，提供有一些内置的属性和方法，可以使用dir函数查看。 新式类： 以object为基类，推荐使用 经典类： 不以object为基类，不推荐使用 在python 3.x中定义类时，如果没有指定父类，会默认使用object作为该类的 基类——python3.x中定义的类都是 新式类 在python 2.x中定义类时，如果没有指定父类，不会以object作为基类。 新式类 和 经典类 在多继承时—会影响到方法的搜索顺序 为了保证编写的代码能够同时在Python2.x和Python3.x运行！今后在定义类时，如果没有父类，建议统一继承自object。 在python3中如果不指定继承关系那么默认继承object。 class A(object): pass dir(A) ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__'] ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:7:9","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"可见性和属性的装饰器 对象的方法通常是公开（public）的，因为公开的方法是对象能够接收的消息，也是对象暴露给外界的调用接口。可以用__name表示一个私有属性，_name表示一个受保护属性。 class Student: # 设置两个私有属性 name 和 age def __init__(self,name, age): self.__name = name self.__age = age def study(self, course_name): print(f'{self.name}正在学习{course_name}.') def play(self): print(f'{self.name}正在玩游戏.') # 类实例化， __init__函数中定义了2个参数，这里要传入两个参数。 stu1 = Student(\"john\", 18) # 尝试调用私有属性 name。抛出异常。 stu1.study(\"python\") # AttributeError: 'Student' object has no attribute '__name' 由此可见，以__开头的属性__name是私有的，在类的外面无法直接访问，但是在类里面的study方法中可以通过self.__name访问该属性。 那么有没有方法在类的外面也能访问私有属性呢？ 可以，需要更换名字规则。对象._类名__方法名这种形式来读取私有属性。或者使用下面的装饰器来实现。 stu1 = Student(\"john\", 18) print(stu1._Student__name, stu1._Student__age) # john 18 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:8:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"装饰器 python中可以通过property装饰器为“私有”属性提供读取和修改的方法。装饰器通常会放在类、函数或方法的声明之前，通过一个@符号表示将装饰器应用于类、函数或方法。 class Student: def __init__(self,name, age): self.__name = name self.__age = age # 私有属性读取（getter方法）- 获取__name属性 @property def name(self): return self.__name # 私有属性修改器（setter方法）- 修改__name属性 @name.setter def name(self, name): # 如果name 参数不为空就赋值给对象的__name属性 # 否则将__name属性赋值为'无名氏',有两种写法 # self.__name = name if name else '无名氏' self.__name = name or '无名氏' # 获取私有属性 @property def age(self): return self.__age def study(self, course_name): print(f'{self.name}正在学习{course_name}.') def play(self): print(f'{self.name}正在玩游戏.') stu1 = Student('smith', 20) print(stu1.age, stu1.name) # 20 smith # 修改私有属性name的值，设置为空会触发私有属性修改器@name.setter。 stu1.name = '' print(stu1.name) # 无名氏 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:8:1","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"动态属性 在python中，我们可以动态为对象添加属性。python是动态类型语言。 对象的方法本质上也是对象的属性，如果给对象发送一个无法接收的信息，引发的异常仍然是AttributeError。 class Student: def __init__(self, name, age): self.name = name self.age = age stu = Student('john', 18) # 想要在不修改当前类的代码的情况下，去添加一个sex属性 stu.sex = \"女\" print(stu.name, stu.age, stu.sex) # john 18 女 如果不希望再使用对象时动态的为对象添加属性，可以使用python的__slots__魔法方法。对于Student类来说，可以在类中指定__slots__ = ('name', 'age')，这样Student类的对象只能有name 和 age 属性。如果想动态添加其他属性会引发异常。 注意添加位置，要在__init__方法之前添加。 class Student: __slots__ = (\"name\", \"age\") def __init__(self, name, age): self.name = name self.age = age stu = Student('john', 18) # 想要在不修改当前类的代码的情况下，去添加一个属性 stu.sex = \"女\" print(stu.name, stu.age, stu.sex) # AttributeError: 'Student' object has no attribute 'sex' ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:9:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"静态方法和类方法 在类中定义的方法都是对象方法，这些方法都是对象可以接收消息。 静态方法和类方法是发送给类对象的消息。 举例： 定义一个三角形类，通过传入三条边的长度来构造三角形，并提供计算周长和面积的方法。计算周长和面积肯定是三角形对象的方法，这一点毫无疑问。但是在创建三角形对象时，传入的三条边长未必能构造出三角形，为此我们可以先写一个方法来验证给定的三条边长是否可以构成三角形，这种方法很显然就不是对象方法，因为在调用这个方法时三角形对象还没有创建出来。我们可以把这类方法设计为静态方法或类方法，也就是说这类方法不是发送给三角形对象的消息，而是发送给三角形类的消息，代码如下所示。 class Triangle(object): \"\"\"三角形类\"\"\" def __init__(self, a, b, c): \"\"\"初始化方法\"\"\" self.a = a self.b = b self.c = c @staticmethod def is_valid(a,b,c): \"\"\"判断三条边长能否构成三角形（静态方法）\"\"\" return a + b \u003e c and b + c \u003e b # @classmethod # def is_valid(cls, a, b, c): # \"\"\"判断三条边长能否构成三角形（类方法）\"\"\" # return a + b \u003e c and b + c \u003e b def perimeter(self): \"\"\"计算周长\"\"\" return self.a + self.a + self.c def area(self): \"\"\"计算面积\"\"\" p = self.perimeter() / 2 return (p * (p - self.a) * (p - self.b) * (p - self.c)) ** 0.5 # 正常调用，需要先进行类的实例化。 triangle = Triangle(10 ,20 ,30) print(triangle.perimeter()) # 50 # 调用静态方法中定义的属性，不需要对当前类进行实例化，可以直接调用。类方法也一样。 print(Triangle.is_valid(10,20,30)) # False ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:10:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"小结 在调用静态方法时，不需要对当前类进行实例化，可以直接使用类名.方法。 静态方法和类方法的区别 1.静态方法传入的参数都是普通参数 2.类方法的参数第一位必须是cls class简写，代表当前的方法是属于当前的类 静态方法是不和当前类进行绑定的，可以看成一个单独的函数。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:10:1","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"多态 面向对象三大特性 1.封装 根据 职责 将属性 和 方法 封装到一个抽象的类中 定义类的准则 2.继承 实现代码的重用，相同的代码不需要重复的编写 设计类的技巧 子类针对自己特有的需求，编写特有的代码 3.多态 不同的子类对象 调用相同的父类方法，产生不同的执行结果 多态 可以 增加代码的灵活度 以 继承 和 重写父类方法 为前提 是调用方法的技巧，不会影响到内部设计. class A: def work(self): print('人类需要工作') # 程序员 class B(A): def work(self): print('程序员在工作--代码') # 设计师 class C(A): def work(self): print('设计师在工作--图纸') b = B() c = C() c.work() b.work() ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:11:0","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"多态案例演练 需求 1.在Dog类中封装方法game 普通狗只是简单的玩耍 2.定义XiaoTianDog继承自Dog，并且重写game方法 哮天犬需要在天上玩耍 3.定义Person类，并且封装一个 和狗玩 的方法 在方法内部，直接让狗对象 调用 game方法 案例小结 Person类中只需要让 狗对象 调用game方法，而不关心具体是什么狗 game方法是在Dog父类中定义的 在程序执行时，传入不同的 狗对象 实参，就会产生不同的执行效果 多态更容易编写出通用的代码，做出通用的编程，以适应需求的不断变化。 class Dog: # 定义类属性 def __init__(self, name): self.name = name # 方法 def game(self): print('%s 在蹦蹦跳跳的玩耍...' % self.name) class XiaoTianDog(Dog): # 当前的哮天犬和普通的狗不一样 \"\"\" 子类继承父类的时候 具有父类的所有属性和方法 \"\"\" def game(self): print('%s 飞到天上去玩耍...' % self.name) class Person: def __init__(self, name): self.name = name def game_with_dog(self, dog): # 让狗玩耍 dog.game() # 让狗与人一起玩耍 print('%s 和 %s 快乐的玩耍...' % (self.name, dog.name)) # 创建一个普通狗对象 # wangcai = Dog('旺财') wangcai = XiaoTianDog('旺财') # 创建一个人的对象 xiaoming = Person('小明') xiaoming.game_with_dog(wangcai) \"\"\" 旺财 在蹦蹦跳跳的玩耍... 小明 和 旺财 快乐的玩耍... 旺财 飞到天上去玩耍... 小明 和 旺财 快乐的玩耍... \"\"\" \"\"\" 多态的运行情况 我们在调用子类中的同名方法时 输出的值不一样 继承和重写的 \"\"\" ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/:11:1","tags":["python"],"title":"python回炉重造-面向对象编程入门","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/"},{"categories":["编程"],"content":"元组 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/:1:0","tags":["python"],"title":"python回炉重造-元组","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/"},{"categories":["编程"],"content":"元组的定义 tuple（元组）与列表类似，不同之处在于元组的元素不能修改 元组中包含列表项，可以修改元组值（间接修改列表） a = ([1,2],[3,4]) a[0][0] = 520 print(a) # ([520, 2], [3, 4]) 元组 表示多个元素组成的序列 元组 在python开发中，有特定的应用场景 用于存储 一串信息，数据之间使用 ,分隔 元组用()定义 元组的索引从0开始 索引就是数据在元组中的位置编号 info_tuple = (\"zhangsan\", 18, 1.75) 创建空元组 info_tuple() 元组中只包含一个元素时，需要在元素后面添加逗号 info_tuple(50, ) ​ 元组的索引是从0开始的 ​ len(元组)获取元组的长度n+1 ​ 元组.count(数据) 数据在元组中出现的次数 元组[索引] 从列表中取值 元组.index(数据) 获得数据第一次出现的索引 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/:1:1","tags":["python"],"title":"python回炉重造-元组","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/"},{"categories":["编程"],"content":"元组的常用操作 在ipython3中定义一个元组，例如：info=() 输入info.按下Tab键，ipython会提示 元组 能够使用的函数如下： info.count info.index 有关元组的常用操作 可以参照上图练习 注意：元组只能查，增删改都不可以。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/:2:0","tags":["python"],"title":"python回炉重造-元组","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/"},{"categories":["编程"],"content":"循环遍历 取值 就是从 元组中获取存储在指定位置的数据 遍历 就是从头到尾依次 从元组中获取数据 # for 循环内部使用的变量 in 元组 for item in info: 循环内部针对元组元素进行操作 print(item) 在python中，可以使用for循环遍历所有非数字类型的变量： 列表、元组、字典以及字符串 提示：在实际开发中，除非能够确认元组中数据类型，否则针对元组的循环遍历需求并不是很多。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/:2:1","tags":["python"],"title":"python回炉重造-元组","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/"},{"categories":["编程"],"content":"应用场景 尽管可以使用for in 遍历元组 但是在开发中，更多的应用场景是： 函数的 参数和返回值，一个函数可以接收 任意多个参数，或者 依次返回多个数据 有关 函数的参数 和返回值，在后续 函数高级 给大家介绍 格式字符串，格式化字符串后面的()本质尚就是一个元组 让列表不可以被修改，以保护数据安全。 info = (\"zhangsan\", 18) print(\"%s 的年龄是 %d\" % info) ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/:2:2","tags":["python"],"title":"python回炉重造-元组","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/"},{"categories":["编程"],"content":"元组和列表之间的转换 使用list函数可以把元组转换成列表 list(元组) 使用tuple函数可以把列表转换成元组 tuple(列表) ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/:2:3","tags":["python"],"title":"python回炉重造-元组","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/"},{"categories":["编程"],"content":"元组打包和解包 打包：多个元素在一个元组内 t = (123, \"FishC\", 3.14) 解包：将多个元素赋值给变量 x,y,z = t print(x) print(y) print(z) # =左边变量数要和 =右边序列中字符数量一致 # 若不等 a,*b = t print(a) # 123 print(b) # ['FishC', 3.14] ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/:2:4","tags":["python"],"title":"python回炉重造-元组","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%85%83%E7%BB%84/"},{"categories":["编程"],"content":"字典的定义 dictionary（字典）是 除列表意外python之中 最灵活的数据类型 字典同样可以用来 存储多个数据 通常用于存储 描述一个 物体的相关信息 和列表的区别 列表是 有序 的对象集合 字典是 无序的对象集合 字典使用 键值对存储数据，键值对之间使用,分割 键 key是索引 值 value 是数据 键 和 值 之间使用:分割 键必须是唯一的 值 可以取任何数据类型，但 键 只能使用 字符串、数字或元组 xiaoming = { \"name\": \"小明\". \"age\": 18, \"gender\" : True \"height\": 1.75 } ​ len(字典) 获取字典的 键值对数量 key value name 小明 age 18 gender true height 1.75 字典.keys() 所有 key 列表 字典.values() 所有value 列表 字典.items() 所有（key, value）元组列表 字典[key] 可以从字典中取值， key 不存在会报错 字典.get(key) 可以从字典中取值， key 不存在不会报错 字典[key] = value 如果 key 存在 ，修改数据 如果 key 不存在 ，新建键值对 字典.setdefault(key, value) 如果 key 存在 ，不会修改数据 如果 key 不存在 ，新建键值对 字典.update(字典2) 将字典2 的数据合并到字典1 del 字典[key] 删除指定键值对， key 不存在会报错 字典.pop(key) 删除指定键值对， key 不存在会报错 字典.popitem() 随机删除一个键值对 字典.clear() 清空字典 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E5%85%B8/:1:0","tags":["python"],"title":"python回炉重造-字典","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E5%85%B8/"},{"categories":["编程"],"content":"字典常用操作 在 ipython3中定义一个 字典 ，例如 ：xiaoing = {} 输入 xiaoming. 按下Tab键，ipython会提示字典 能够使用的函数如下： xiaoming.clear() xiaoming.copy() xiaoming.get() xiaoming.items() xiaoming.keys() xiaoming.pop() xiaoming.popitem() xiaoming.setdefault() xiaoming.update() xiaoming.values() 有关 字典的 常用操作 可以参照上图练习 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E5%85%B8/:2:0","tags":["python"],"title":"python回炉重造-字典","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E5%85%B8/"},{"categories":["编程"],"content":"清空字典 info = {\"name\": \"john\", \"age\":18} print(\"清空前:%s\" %info) info.clear() print(\"清空后:%s\" %info) 结果 清空前:{'name': 'john', 'age': 18} 清空后:{} ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E5%85%B8/:2:1","tags":["python"],"title":"python回炉重造-字典","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E5%85%B8/"},{"categories":["编程"],"content":"遍历循环 遍历就是 依次 从字典中获取所有键值对 # for 循环内部使用`key的变量` in 字典 for k,v in xiaoming.items(): print(\"key=%s,value=%s\"%(k,v)) 提示：在实际开发中，由于字典中每一个键值对保存的数据类型是不同的，所以针对字典的循环需求并不是很多。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E5%85%B8/:3:0","tags":["python"],"title":"python回炉重造-字典","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E5%85%B8/"},{"categories":["编程"],"content":"应用场景 尽量可以使用for in遍历 字典 但是在开发中，更多的应用场景是： 使用 多个键值对，存储 描述一个物体的相关信息 ——–描述更复杂的数据信息 将 多个字典 放在一个列表中，再进行遍历， 在循环体内部针对每一个字典进行 相同的处理 card_list = [ { \"name\": \"张三\", \"qq\": \"123465\", \"phone\": \"110\", }, { \"name\": \"李四\", \"qq\": \"123456\", \"phone\":\"120\" } ] ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E5%85%B8/:4:0","tags":["python"],"title":"python回炉重造-字典","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E5%85%B8/"},{"categories":["编程"],"content":"字符串 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["编程"],"content":"定义 字符串 就是一串字符，是编程语言中表示文本的数据类型 在 python中可以使用 一堆双引号 \"\"或者 一对单引号 ''定义一个字符串 虽然可以使用\\\"或者\\'做字符串的转义，但是在实际开发中： 如果字符串内部需要使用\"\",可以使用''定义字符串。 如果字符串内部需要使用'',可以使用\"\"定义字符串。 可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0 开始 亦可以使用 for循环遍历 字符串中每一个字符 大多数编程语言都是用\"\"来定义字符串 string = 'Hello Python' for c in string: print(c) 字符串的索引值是从0 开始的 p y t h o n ↑ len(字符串) 获取字符串的长度 字符串.count(字符串) 小字符串在大字符串中出现的次数 字符串[索引] 从字符串中取出单个字符。 它也支持切片操作 字符串[1:4:] # yth 字符串.index(字符串) 获得小字符串第一次出现的索引 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:1","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["编程"],"content":"字符串的常规操作 在 ipython3中定义一个 字符串 ，例如 ： hello_str = \"\" 输入hello_str,按下Tab键，ipython会提示 字符串能够使用的方法如下： hello_str.capitalize hello_str.isidentifier hello_str.rindex hello_str.casefold hello_str.islower hello_str.rjust hello_str.center hello_str.isnumeric hello_str.rpartition hello_str.count hello_str.isprintable hello_str.rsplit hello_str.encode hello_str.isspace hello_str.rstrip hello_str.endswith hello_str.istitle hello_str.split hello_str.expandtabs hello_str.isupper hello_str.splitlines hello_str.find hello_str.join hello_str.startswith hello_str.format hello_str.ljust hello_str.strip hello str.format_map hello_str.lower hello_str.swapcase hello_str.index hello_str.lstrip hello_str.title hello_str.isalnum hello_str.maketrans hello_str.translate hello_str.isalpha hello_str.partition hello_str.upper hello_str.isdecimal hello_str.replace hello_str.zfill hello_str.isdigit hello_str.rfind 提示：正是因为python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作。 1）判断类型-9 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回True string.isdecimal() 如果 string 只包含数字则返回True ,全角数字 string.isnumeric() 如果 string 只包含数字则返回True ,全角数字，汉字数字 string.isdigit() 如果 string 只包含数字则返回True ,全角数字、{1}、\\u00b2 string.istitle() 如果 string是标题化的（每个单词首字母大写）则返回True 。 string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写，则返回True 。 string.upper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是大写，则返回True 。 2）查找和替换-7 方法 说明 string.startswith(str) 检查字符串是否以str开头，是则返回True。 string.find(str, beg=0, end=len(string)) 检测 str 是否包含在 string 中，如果 beg 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回-1 string.index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在 string中会报一个异常. string.rfind(str, beg=0,end=len(string) ) 类似于 find() 函数，返回字符串最后一次出现的位置，如果没有匹配项则返回 -1。 string.rindex( str, beg=0,end=len(string)) 类似于 index()，不过是返回最后一个匹配到的子字符串的索引号。 string.replace(str1, str2, num=string.count(str1)) 把 string 中的 str1 替换成 str2,如果 num 指定，则替换不超过 num 次. ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["编程"],"content":"字符串的方法 在python中，我们可以通过字符串类型自带的方法对字符串进行操作和处理，对于一个字符串的变量，我们可以用变量名.方法名()的方式来调用它的方法。所谓方法其实就是跟某个类型的变量绑定的函数，后面我们讲面向对象编程的时候还会对这一概念详加说明。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:0","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["编程"],"content":"大小写相关操作 下面的代码演示了和字符串大小写变换相关的方法。 s1 = 'hello, world!' # 使用capitalize方法获得字符串首字母大写后的字符串 print(s1.capitalize()) # Hello, world! # 使用title方法获得字符串每个单词首字母大写后的字符串 print(s1.title()) # Hello, World! # 使用upper方法获得字符串大写后的字符串 print(s1.upper()) # HELLO, WORLD! s2 = 'GOODBYE' # 使用lower方法获得字符串小写后的字符串 print(s2.lower()) # goodbye ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:1","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["编程"],"content":"查找操作 如果想在一个字符串中从前向后查找有没有另外一个字符串，可以使用字符串的find或index方法。 s = 'hello, world!' # find 方法从字符串中查找另一个字符串所在的位置 # 找到了返回字符串中另一个字符串首字母字符串的索引 print(s.find('or')) # 8 # 找不到返回 -1 print(s.find('shit')) # -1 # index方法与find方法类似 # 找到了返回字符串中另一个字符串首字符的索引 print(s.index('or')) # 8 # 找不到引发异常 print(s.index('shit')) # ValueError: substring not found 在使用find和index方法时还可以通过方法的参数来指定查找的范围，也就是查找不必从索引0的位置开始。find和index方法还有逆向查找（从后向前查找）的版本，分别是rfind和rindex ，代码如下所示。 s = 'hello good world!' # 从前向后查找字符o出现的位置（相当于第一次出现） print(s.find('o')) # 4 # 从索引为5 的位置开始查找o出现的位置 print(s.find('o', 5)) # 7 # 从后向前查找字符o出现的位置（相当于最后一次出现） print(s.rfind('o')) # 12 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:2","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["编程"],"content":"性质判断 可以通过字符串的startswith、endswith俩判断字符串是否以某个字符串开头和结尾；还可以用is开头的方法判断字符串的特征，这些方法都返回布尔值，代码如下图所示。 s1 = 'hello, world!' # startwith 方法检查字符串是否以指定的字符串开头返回布尔值 print(s1.startswith('He')) # False print(s1.startswith('hel')) # True # endwith 方法检查字符串是否以指定的字符串结尾返回布尔值 print(s1.endswith('!')) # True s2 = 'abc123456' # isdigit 方法检查字符串是否由数字构成返回布尔值 print(s2.isdigit()) # False # isalpha 方法检查字符串是否由字母构成返回布尔值 print(s2.isalpha()) # False # isalnum 方法检查字符串是否以数字和字母构成返回布尔值 print(s2.isalnum()) # True ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:3","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["编程"],"content":"格式化字符串 在python中，字符串类型可以通过center、ljust、rjust方法做居中、左对齐和右对齐处理。如果要在字符串的左侧补零，也可以使用zfill方法。 s = 'hello, world!' # center 方法以宽度20 将字符串居中并在两侧填充* print(s.center(20, '*')) # ***hello, world!**** print(s.rjust(20)) # hello, world! print(s.ljust(20, '-')) # hello, world!------- print('33'.zfill(5)) # 00033 print('-33'.zfill(5)) # -0033 在用print函数输出字符串时，可以用下面的方式对字符串进行格式化。 a = 321 b = 123 print('%d * %d = %d'% (a, b, a * b)) 当然，我们也可以用字符串的方法来完成字符串的格式，代码如下所示。 a = 321 b = 123 print('{0} * {1} = {2}'.format(a, b, a * b)) 从python3.6开始，格式化字符串还有更为简介的书写方式，就是在字符串前加f来格式化字符串，在这种以f打头的字符串中{变量名}是一个占位符，会被变量对应的值将其替换掉，代码如下所示。 a = 321 b = 123 print(f'{a} * {b} = {a * b}') f 表达式只支持python3.6 以上版本。。 如果需要进一步控制格式化中变量值的形式，可以参照下面的表格来进行字符串格式化操作。 变量值 占位符 格式化结果 说明 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 3.1415926 {:.0f} 3 不带小数 123 {:0\u003e10d} 0000000123 左边补0，补够10位 123 {:x\u003c10d} 123xxxxxxx 右面补x，补够10位 123 {:\u003e10d} 123 左补空格，补够10位 123 {:\u003c10d} 123 右补空格，补够10位 123456789 {:,} 123,456,789 逗号分隔格式 0.123 {:.2%} 12.30% 百分比格式 123456789 {:.2e} 1.23e+08 科学计数法格式 11 '{:0\u003e10d}'.format(11) 0000000011 进制 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:0","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["编程"],"content":"修剪操作 字符串的strip方法可以帮我们获得将原字符串修剪左右两端空格之后的字符串。这个方法非常有实用价值，通常用来将用户输入因不小心键入的头尾空格去掉，strip方法还有lstrip和rstrip两个版本。 s = ' tuling_python@163.com \\t \\r \\n' # strip 方法获得的字符串修剪左右两侧空格之后的字符串 print(s.strip()) # tuling_python@163.com ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:1","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["编程"],"content":"替换操作 如果希望用新的内容替换字符串中指定内容，可以用replace方法，代码如下。replace方法的第一个参数是被替换的内容，第二个参数是替换后的内容，还可以通过第三个参数指定替换的次数。 s1 = 'hello, world' print(s1.replace('o','@')) # hell@, w@rld print(s1.replace('o','@',1)) # hell@, world 拆分、合并操作 可以使用字符串的split方法将一个字符串拆分为多个字符串（放在一个列表中），也可以使用字符串的join方法将列表中的多个字符串连接成一个字符串。 s2 = 'I love you' words = s2.split() print(words) # ['I', 'love', 'you'] print('#'.join(words)) # I#love#you 需要说明的是，split方法默认使用空格进行拆分，也可以指定其他的字符来拆分字符串，而且还可以指定最大拆分次数来控制拆分的效果。 s3 = 'I#love#you#so#much' word1 = s3.split('#') print(word1) # ['I', 'love', 'you', 'so', 'much'] word2 = s3.split('#', 3) print(word2) # ['I', 'love', 'you', 'so#much'] ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:2","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["编程"],"content":"编码、解码操作 python中除了字符串str类型外，还有一种表示二进制数据的字节串类型（bytes）。所谓字节串，就是由零个或多个字节组成的有限序列。通过字符串的encode方法，我们可以按照某种编码方式将字符串编码为字节串，也可以使用字节串的decode方法，将字节串解码为字符串，代码如下所示。 a = '小红' b = a.encode('utf-8') c = a.encode('gbk') print(b, c) # b'\\xe5\\xb0\\x8f\\xe7\\xba\\xa2' b'\\xd0\\xa1\\xba\\xec' print(b.decode('utf-8')) # 小红 print(c.decode('gbk')) # 小红 注意：用什么方式编码 ，就用什么方式解码。 ","date":"2022-07-03","objectID":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:3","tags":["python"],"title":"python回炉重造-字符串","uri":"/python%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["工具"],"content":"测试网站： http://httpbin.org/ ","date":"2022-06-30","objectID":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/:0:0","tags":["web测试"],"title":"http和https各种方法测试","uri":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/"},{"categories":["工具"],"content":"http所有方法 ","date":"2022-06-30","objectID":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/:1:0","tags":["web测试"],"title":"http和https各种方法测试","uri":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/"},{"categories":["工具"],"content":"get import requests def get_html_text(url): headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36' } r = requests.get(url, headers=headers) if r.status_code == 200: html = r.text print(html) else: print(\"访问失败\") url = 'http://httpbin.org/get' get_html_text(url) 返回数据 { \"args\": {}, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Host\": \"httpbin.org\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-62b26fdb-5f9089b418e89e7533cd64f7\" }, \"origin\": \"124.64.235.140\", \"url\": \"http://httpbin.org/get\" } ","date":"2022-06-30","objectID":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/:1:1","tags":["web测试"],"title":"http和https各种方法测试","uri":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/"},{"categories":["工具"],"content":"带请求头和不带请求头访问区别 不带请求头 import requests def get_html_text(url): r = requests.get(url) if r.status_code == 200: html = r.text print(html) else: print(\"访问失败\") url = 'http://httpbin.org/user-agent' get_html_text(url) 结果 只显示原始请求，有些网站会拒绝访问。 { \"user-agent\": \"python-requests/2.25.1\" } 带请求头 import requests def get_html_text(url): headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36' } r = requests.get(url, headers=headers) if r.status_code == 200: html = r.text print(html) else: print(\"访问失败\") url = 'http://httpbin.org/user-agent' get_html_text(url) 结果 可以伪装成任意设备。 { \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36\" } ","date":"2022-06-30","objectID":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/:1:2","tags":["web测试"],"title":"http和https各种方法测试","uri":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/"},{"categories":["工具"],"content":"cookies 请求头带cookies请求资源 import requests def auth_html(url): headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36', 'cookies': 'stale_after=never; fake=fake_value; last_nonce=65ef22149cc1c4c4214bf968aab45271' } r = requests.get(url, headers=headers) if r.status_code == 200: html = r.text print(html, r.status_code) else: print(\"访问失败\") url = 'http://httpbin.org/get' auth_html(url) 结果 { \"args\": {}, \"headers\": { \"Accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\", \"Accept-Encoding\": \"gzip, deflate\", \"Accept-Language\": \"zh-CN,zh;q=0.9\", \"Cookie\": \"stale_after=never; fake=fake_value; last_nonce=65ef22149cc1c4c4214bf968aab45271\", \"Host\": \"httpbin.org\", \"Upgrade-Insecure-Requests\": \"1\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-62b28149-3ba69f2e27ccba90684da343\" }, \"origin\": \"124.64.235.140\", \"url\": \"http://httpbin.org/get\" } ","date":"2022-06-30","objectID":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/:1:3","tags":["web测试"],"title":"http和https各种方法测试","uri":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/"},{"categories":["工具"],"content":"post import requests def post_html_text(url): headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36' } r = requests.post(url, headers=headers) if r.status_code == 200: html = r.text print(html) else: print(\"访问失败\") url = 'http://httpbin.org/post' get_html_text(url) 执行结果 { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": {}, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Length\": \"0\", \"Host\": \"httpbin.org\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-62b2706d-7f50d849381586d306230274\" }, \"json\": null, \"origin\": \"124.64.235.140\", \"url\": \"http://httpbin.org/post\" } 如果想带数据post,可以加入参数，请求结果显示出来。 import requests def post_html_text(url): headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36' } data = 'hello world' params = {'name':'jack'} r = requests.post(url, headers=headers, data=data, params=params) if r.status_code == 200: html = r.text print(html) else: print(\"访问失败\") url = 'http://httpbin.org/post' post_html_text(url) 请求结果 { \"args\": { \"name\": \"jack\" }, \"data\": \"hello world\", \"files\": {}, \"form\": {}, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Length\": \"11\", \"Host\": \"httpbin.org\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36\", \"X-Amzn-Trace-Id\": \"Root=1-62b27146-6d5aa1171e476ed97757a9a5\" }, \"json\": null, \"origin\": \"124.64.235.140\", \"url\": \"http://httpbin.org/post?name=jack\" } ","date":"2022-06-30","objectID":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/:1:4","tags":["web测试"],"title":"http和https各种方法测试","uri":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/"},{"categories":["工具"],"content":"auth认证 请求头中加入authorization，带着请求头去请求。 import requests def auth_html(url): headers = { 'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36', 'authorization': 'Basic MTIzOjEyMw==' } data = 'hello world' params = {'name':'jack'} r = requests.get(url, headers=headers, data=data, params=params) if r.status_code == 200: html = r.text print(html) else: print(\"访问失败\") url = 'http://httpbin.org/basic-auth/123/123' auth_html(url) 请求结果 { \"authenticated\": true, \"user\": \"123\" } MTIzOjEyMw==是base64加密后的。 解密 echo \"MTIzOjEyMw==\" | base64 -d 123:123 也可以直接浏览器测试认证功能。 http://httpbin.org/basic-auth/用户名/密码 浏览器f2 过滤无关元素 -.js -.jpg -.css -.gif -.png -.ico -.webp ","date":"2022-06-30","objectID":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/:1:5","tags":["web测试"],"title":"http和https各种方法测试","uri":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/"},{"categories":["工具"],"content":"linux系统命令行请求 get请求 curl -X GET \"http://httpbin.org/get\" -H \"accept: application/json\" -H \"user-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/102.0.0.0 Safari/537.36\" post请求 curl -X POST \"http://httpbin.org/post\" -H \"accept: application/json\" ","date":"2022-06-30","objectID":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/:1:6","tags":["web测试"],"title":"http和https各种方法测试","uri":"/http%E5%92%8Chttps%E5%90%84%E7%A7%8D%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/"},{"categories":["工具"],"content":"rm垃圾桶 rm命令杀伤力很大，如果误删了系统文件，会很麻烦。所以，给linux系统建立一个垃圾桶，是很有必要的，详情参考Make “rm” Command To Move The Files To “Trash Can” 。 1、下载安装saferm.sh git clone https://github.com/lagerspetz/linux-stuff sudo mv linux-stuff/scripts/saferm.sh /bin rm -Rf linux-stuff 2、编辑.bashrc文件，末尾添加 alias rm=saferm.sh alias sudo='sudo ' 3、使环境生效 source .bashrc 之后，再使用rm或者sudo rm命令，实际上执行的是mv操作，移动文件到Trash目录。 ","date":"2022-06-30","objectID":"/linux%E5%9E%83%E5%9C%BE%E6%A1%B6/:1:0","tags":["linux垃圾桶"],"title":"linux垃圾桶","uri":"/linux%E5%9E%83%E5%9C%BE%E6%A1%B6/"},{"categories":["工具"],"content":"本机外网IP获取 https://ifconfig.me/ 或 curl ifconfig.me ","date":"2022-06-30","objectID":"/linux%E5%9E%83%E5%9C%BE%E6%A1%B6/:2:0","tags":["linux垃圾桶"],"title":"linux垃圾桶","uri":"/linux%E5%9E%83%E5%9C%BE%E6%A1%B6/"},{"categories":["工具"],"content":"安装jupyter 1、登录dockerhub查看需要的Jupyter - Docker Official Images 。 2、下载jupyter镜像（以6.4.12为例） docker pull jupyter/base-notebook:notebook-6.4.12 3、创建配置目录 mkdir -p /opt/jupyter/jovyan mkdir -p /opt/jupyter/jovyan/.jupyter chmod 777 -R /opt/jupyter/jovyan 4、启动jupyter服务 docker run --name vk-jupyter -d \\ -p 8888:8888 \\ -v /opt/jupyter/jovyan:/home/jovyan \\ jupyter/base-notebook:notebook-6.4.12 以上命令： 命名容器为vk-jupyter，后台运行 映射宿主机8888端口到容器的8888端口 挂载宿主机目录/opt/jupyter/jovyan到容器目录/home/jovyan 更多启动命令参数可以参考Jupyter Docker Stacks 。 5、验证安装 docker ps，jupyter启动正常的话就可以看到vk-jupyter容器。 浏览器访问 http://aliyunip:8888 ，可以看到Jupyter登录页面。 6、登录 docker exec -it vk-jupyter jupyter notebook list 可以查看到登录需要的token，使用token即可登录进入jupyter编辑页面。 配置jupyter 1、设置密码 docker exec -it vk-jupyter jupyter notebook password docker restart vk-jupyter 2、使用密码 浏览器访问 http://aliyunip:8888 此时使用自己设置的密码就可以访问jupyter了。 3、根目录 jupyter编辑器的默认根目录为 /home/jovyan ，对应宿主机目录 /opt/jupyter/jovyan ，创建的目录和文件都去这个路径下面去找。 配置Nginx jupyter 使用了 websocket 协议，所以需要配置支持 websocket。 如果不配置的话，通过域名访问时会报错无法连接内核，也就无法运行python脚本。 server { listen 80; server_name jupyter.voidking.com; charset utf-8; location /{ proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://172.17.12.85:8888; # WebSocket support proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; } } jupyter小技巧 ","date":"2022-06-30","objectID":"/docker%E5%AE%89%E8%A3%85jupyter/:0:0","tags":["jupyter"],"title":"docker安装jupyter","uri":"/docker%E5%AE%89%E8%A3%85jupyter/"},{"categories":["工具"],"content":"执行bash 在代码框里输入叹号+bash命令，即可执行bash，例如： !ls -l ","date":"2022-06-30","objectID":"/docker%E5%AE%89%E8%A3%85jupyter/:1:0","tags":["jupyter"],"title":"docker安装jupyter","uri":"/docker%E5%AE%89%E8%A3%85jupyter/"},{"categories":["工具"],"content":"登录进容器 docker exec -it vk-jupyter /bin/bash docker exec --user root -it vk-jupyter /bin/bash ","date":"2022-06-30","objectID":"/docker%E5%AE%89%E8%A3%85jupyter/:2:0","tags":["jupyter"],"title":"docker安装jupyter","uri":"/docker%E5%AE%89%E8%A3%85jupyter/"},{"categories":["工具"],"content":"安装常用命令 docker exec --user root -it vk-jupyter /bin/bash apt update apt install curl apt install unzip ","date":"2022-06-30","objectID":"/docker%E5%AE%89%E8%A3%85jupyter/:3:0","tags":["jupyter"],"title":"docker安装jupyter","uri":"/docker%E5%AE%89%E8%A3%85jupyter/"},{"categories":["工具"],"content":"ubuntu20.04安装docker ","date":"2022-06-29","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85docker/:1:0","tags":["ubuntu"],"title":"ubuntu20.04安装docker","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85docker/"},{"categories":["工具"],"content":"操作系统要求 Docker只支持64位版本的 Ubuntu 18.04 LTS、20.04 LTS、21.04、21.10 操作系统，更旧的 Ubuntu 操作系统如 16.04 官方已不再维护； Docker Engine 支持 x86_64 (or amd64)、armhf、arm64、s390x 体系架构。 ","date":"2022-06-29","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85docker/:1:1","tags":["ubuntu"],"title":"ubuntu20.04安装docker","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85docker/"},{"categories":["工具"],"content":"卸载旧版本的 Docker Engine Docker的旧版本被称为docker，docker.io或docker-engine。如果安装了这些，请卸载它们： sudo apt-get remove docker docker-engine docker.io containerd runc 如果您想保留现有数据，那么直接进入下一步即可。 如果您不想保留现有数据（可选），如 image、container、volume等，执行下面的命令，相比remove命令，purge会同时清除软件包和软件的配置文件。 sudo apt-get purge docker-ce docker-ce-cli containerd.io 主机上的 image、container、volume 或自定义配置文件不会自动删除。要删除所有映像、容器和卷，执行下面的命令，删除对应的文件夹： sudo rm -rf /var/lib/docker sudo rm -rf /var/lib/containerd 卸载完成。 ","date":"2022-06-29","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85docker/:1:2","tags":["ubuntu"],"title":"ubuntu20.04安装docker","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85docker/"},{"categories":["工具"],"content":"Docker Engine 安装方法 官方提供了三种安装 Docker Engine 的方法： 大多数用户设置 Docker 的仓库，使用包管理器安装，以便于安装和升级任务，这是推荐的方法； 一些用户下载 deb 包并手动安装，完全手动管理升级。这在诸如在无法访问 Internet 的系统上安装 Docker 等情况下很有用； 在测试和开发环境中，一些用户选择使用自动化脚本来安装 Docker。 本文只介绍 Docker Engine 官方安装-Ubuntu 中的第一种方法——使用包管理器安装。 设置 Docker Engine 存储库 ① 更新 apt 包索引并安装 ca-certificates、curl、gnupg、lsb-release等，以允许 apt 通过 HTTPS 使用存储库; sudo apt-get update sudo apt-get install ca-certificates curl gnupg lsb-release ② 添加 Docker 的官方 GPG 密钥; curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg ③ 使用下面命令设置 stable 仓库。 echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 安装 Dokcer Engine 安装最新版本的 Dokcer Engine： sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io 安装指定版本的 Dokcer Engine，首先使用cpt-cache命令查看仓库中 docker-ce 的版本，选择对应的版本，使用install命令安装。 apt-cache madison docker-ce sudo apt-get install docker-ce=\u003cVERSION_STRING\u003e docker-ce-cli=\u003cVERSION_STRING\u003e containerd.io 更新 Dokcer Engine sudo apt-get update sudo apt-get upgrade ","date":"2022-06-29","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85docker/:1:3","tags":["ubuntu"],"title":"ubuntu20.04安装docker","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85docker/"},{"categories":["工具"],"content":"Docker Compose 安装方法 Docker Compose 稳定版 1.29.2 安装 下面的步骤来自于 Docker Compose 官方安装-Ubuntu 。 目前 Docker Compose 的稳定版为 1.29.2。 运行下面的命令将 Docker Compose 1.29.2 的二进制版本安装到 /usr/local/bin/docker-compose 中。 要安装不同版本的 Compose，请将 1.29.2 替换为您要使用的 Compose 版本。 sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 对二进制文件 /usr/local/bin/docker-compose 赋予可执行权限。 sudo chmod +x /usr/local/bin/docker-compose 测试是否安装成功，正确输出 compose 版本号，即成功。 docker-compose --version Docker Compose V2 安装 对Docker Compose V2有兴趣，请访问 Compose V2 ，来进行安装。 ","date":"2022-06-29","objectID":"/ubuntu20.04%E5%AE%89%E8%A3%85docker/:1:4","tags":["ubuntu"],"title":"ubuntu20.04安装docker","uri":"/ubuntu20.04%E5%AE%89%E8%A3%85docker/"},{"categories":["编程"],"content":"可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改： 列表 list 字典 dict 集合set ","date":"2022-06-13","objectID":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/:1:0","tags":["python"],"title":"Python数据结构总结","uri":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"categories":["编程"],"content":"哈希 (hash) Python 中内置有一个名字叫做 hash(o) 的函数 接收一个不可变类型的数据作为参数 返回结果是一个整数 哈希是一种算法,其作用就是提取数据的特征码（指纹） 相同的内容得到相同的结果 不同的内容得到不同的结果 在Python 中，设置字典的键值对时，会首先对key进行hash已决定如何在内存中保存字典的数据，以方便后续对字典的操作：增、删、改、查 键值对的key 必须是不可变类型数据 键值对的value 可以是任意类型的数据 ","date":"2022-06-13","objectID":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/:1:1","tags":["python"],"title":"Python数据结构总结","uri":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"categories":["编程"],"content":"可以hash的类型 元组 #任意类型转换成元组类型 tuple() # tuple1 = (1,2,3) #可以hash print(hash(tuple1)) # 529344067295497451 字符串 #任意类型转换成字符串类型 str() str1 = \"hello world\" print(hash(str1)) # 8722840457505038127 整形 #任意类型转换成整形类型 int() num = 10 print(hash(num)) 浮点型 #任意类型转换成浮点类型 float() num1 = 10.2 print(hash(num1)) 布尔类型 #任意类型转换成布尔类型。True False bool() num1 = True print(hash(num1)) ","date":"2022-06-13","objectID":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/:1:2","tags":["python"],"title":"Python数据结构总结","uri":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"categories":["编程"],"content":"不可以hash的类型 列表 #任意类型转换成列表类型 list() # list1 = [1,2,3,4,5] #不可以hash hash(list1) # TypeError: unhashable type: 'list' 字典 # 创建一个字典 dict() # my_dict = {'name':'smith', 'age':18} 集合 # 其他类型转换成集合类型 set() set1 = {1,2,3,4,5} ","date":"2022-06-13","objectID":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/:1:3","tags":["python"],"title":"Python数据结构总结","uri":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"categories":["编程"],"content":"函数的返回值 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 ","date":"2022-06-13","objectID":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/:2:0","tags":["python"],"title":"Python数据结构总结","uri":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"categories":["编程"],"content":"举例1 def my_func(): a = 10 b = 20 # print(a) return a print(b) my_func() # 结果为空。没有内容输出。print(b)语句在return 语句后面，不会被执行。 ","date":"2022-06-13","objectID":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/:2:1","tags":["python"],"title":"Python数据结构总结","uri":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"categories":["编程"],"content":"举例2 设置变量来接受函数的返回结果 def my_func(): a = 10 b = 20 # print(a) return a print(b) result = my_func() print(result) # 结果为 10 ,设置一个变量 result 来接收函数返回结果 ","date":"2022-06-13","objectID":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/:2:2","tags":["python"],"title":"Python数据结构总结","uri":"/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"基于k8s的ceph集群搭建 ","date":"2022-05-16","objectID":"/ceph/:0:1","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"环境 master-139 mon,osd 既做管理节点又做子节点 node1-140 mon,osd 做子节点 node2-141 mon,osd 做子节点 ceph 版本 13.2.10 mimic (stable) ","date":"2022-05-16","objectID":"/ceph/:0:2","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"系统配置 系统配置工作， 三台节点依次执行 1、修改主机名称 [root@master-139 ~]# vi /etc/hostname master-139 2、编辑hosts文件 10.4.7.139 master-139 10.4.7.140 node1-140 10.4.7.141 node2-141 注意， 这里面的主机名称要和节点名称保持一致， 否则安装的时候会出现问题 3.修改yum源 cat \u003c\u003c EOF \u003e /etc/yum.repos.d/ceph.repo [ceph] name=Ceph packages for $basearch baseurl=https://mirrors.tuna.tsinghua.edu.cn/ceph/rpm-mimic/el7/x86_64/ enabled=1 gpgcheck=1 type=rpm-md gpgkey=https://download.ceph.com/keys/release.asc [ceph-noarch] name=Ceph noarch packages # 官方源 #baseurl=http://download.ceph.com/rpm-mimic/el7/noarch # 清华源 baseurl=https://mirrors.tuna.tsinghua.edu.cn/ceph/rpm-mimic/el7/noarch/ enabled=1 gpgcheck=1 type=rpm-md gpgkey=https://download.ceph.com/keys/release.asc [ceph-source] name=Ceph source packages baseurl=https://mirrors.tuna.tsinghua.edu.cn/ceph/rpm-mimic/el7/SRPMS/ enabled=1 gpgcheck=1 type=rpm-md gpgkey=https://download.ceph.com/keys/release.asc EOF 4、安装ceph与ceph-deploy组件 yum clean all \u0026\u0026 yum makecache yum -y install python-setuptools epel-release yum -y install python2-pip ceph-deploy ceph 5.安装NTP时间同步工具 yum install ntp ntpdate ntp-doc -y 确保时区是正确， 设置开机启动： systemctl enable ntpd 并将时间每隔1小时自动校准同步。编辑 vi /etc/rc.d/rc.local 追加： /usr/sbin/ntpdate ntp1.aliyun.com \u003e /dev/null 2\u003e\u00261; /sbin/hwclock -w 配置定时任务, 执行crontab -e 加入： ","date":"2022-05-16","objectID":"/ceph/:1:0","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"免密码SSH登陆 6.开放端口， 非生产环境， 可以直接禁用防火墙： systemctl stop firewalld.service systemctl disable firewalld.service 7.SELINUX设置 SELinux 设为禁用： 永久生效： 编辑 vi /etc/selinux/config 修改： SELINUX=disabled 8.生成密钥 执行 ssh-keygen ，一直按默认提示点击生成 RSA 密钥信息。 9.分发密钥至各机器节点 ssh-copy-id root@master-139 ssh-copy-id root@node1-140 ssh-copy-id root@node2-141 注意：以上1-9步骤在所有节点上执行！！ ","date":"2022-05-16","objectID":"/ceph/:1:1","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"集群搭建配置 1.采用root身份进行安装，在管理节点创建集群配置目录 cd /usr/local/ mkdir ceph-cluster cd ceph-cluster 注意： 此目录作为 ceph 操作命令的基准目录， 会存储处理配置信息。 2.创建集群， 包含三台机器节点： ceph-deploy new master-139 node1-140 node2-141 创建成功后， 会生一个配置文件。 [root@master-139 ceph-cluster]# ll total 16 -rw-r--r-- 1 root root 242 May 15 03:15 ceph.conf -rw-r--r-- 1 root root 5559 May 15 03:15 ceph-deploy-ceph.log -rw------- 1 root root 73 May 15 03:15 ceph.mon.keyring 3.如果接下来集群的安装配置出现问题， 可以执行以下命令清除， 再重新安装(可选) ceph-deploy purge master-139 node1-140 node2-141 ceph-deploy purgedata master-139 node1-140 node2-141 ceph-deploy forgetkeys 4.将三台节点的mon信息也删除（可选） rm -rf /var/run/ceph/ 5.修改配置文件， 有些配置后面需用到 vi /usr/local/ceph-cluster/ceph.conf [global] # 设置pool池默认分配数量 默认副本数为3 osd pool default size = 3 # 容忍更多的时钟误差 mon clock drift allowed = 2 mon clock drift warn backoff = 30 # 允许删除pool mon_allow_pool_delete = true [mgr] # 开启WEB仪表盘 mgr modules = dashboard 第一项为副本数， 设为 3 份。 第二、三项为允许一定时间的漂移误差。 设置完成后的配置如下 [global] fsid = 67dcaf50-275b-442f-b69d-677fd8afcc94 mon_initial_members = master-139, node1-140, node2-141 mon_host = 10.4.7.139,10.4.7.140,10.4.7.141 auth_cluster_required = cephx auth_service_required = cephx auth_client_required = cephx # 设置pool池默认分配数量 默认副本数为3 osd pool default size = 3 # 容忍更多的时钟误差 mon clock drift allowed = 2 mon clock drift warn backoff = 30 # 允许删除pool mon_allow_pool_delete = true [mgr] # 开启WEB仪表盘 mgr modules = dashboard 6.执行安装 ceph-deploy install master-139 node1-140 node2-141 如果出现错误： ceph_deploy][ERROR ] RuntimeError: Failed to execute command: ceph --version 可以在各节点上单独进行安装： yum -y install ceph 如果没有仓库文件 ceph.repo ， 按上面的步骤手工创建。 7.初始monitor信息 ceph-deploy mon create-initial ## ceph-deploy --overwrite-conf mon create-initial 初始化后生成以下信息 [ceph_deploy.gatherkeys][INFO ] Storing ceph.client.admin.keyring [ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-mds.keyring [ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-mgr.keyring [ceph_deploy.gatherkeys][INFO ] keyring 'ceph.mon.keyring' already exists [ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-osd.keyring [ceph_deploy.gatherkeys][INFO ] Storing ceph.bootstrap-rgw.keyring [ceph_deploy.gatherkeys][INFO ] Destroy temp directory /tmp/tmpuBxetx [root@master-139 ceph-cluster]# ll total 220 -rw------- 1 root root 113 May 15 03:29 ceph.bootstrap-mds.keyring -rw------- 1 root root 113 May 15 03:29 ceph.bootstrap-mgr.keyring -rw------- 1 root root 113 May 15 03:29 ceph.bootstrap-osd.keyring -rw------- 1 root root 113 May 15 03:29 ceph.bootstrap-rgw.keyring -rw------- 1 root root 151 May 15 03:29 ceph.client.admin.keyring -rw-r--r-- 1 root root 529 May 15 03:22 ceph.conf -rw-r--r-- 1 root root 167370 May 15 03:29 ceph-deploy-ceph.log -rw------- 1 root root 73 May 15 03:22 ceph.mon.keyring 8.同步管理信息 下发配置文件和管理信息至各节点： ceph-deploy admin master-139 node1-140 node2-141 9.安装mgr(管理守护进程)， 大于12.x版本需安装， 我们装的是最新版，需执行： ceph-deploy mgr create master-139 node1-140 node2-141 10.查看当前ceph版本 # ceph -v ceph version 13.2.10 (564bdc4ae87418a232fc901524470e1a0f76d641) mimic (stable) 以上操作都在管理节点master-139上执行！！ ","date":"2022-05-16","objectID":"/ceph/:2:0","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"安装OSD(对象存储设备) 注意： 新版本的 OSD 没有 prepare 与 activate 命令。 这里需要新的硬盘作为 OSD 存储设备， 关闭虚拟机， 增加一块硬盘， 不用格式化。 各节点都添加100G硬盘。 重启， fdisk -l 查看新磁盘名称： Disk /dev/sdb: 107.4 GB, 107374182400 bytes, 209715200 sectors Units = sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes 1.执行创建OSD命令 ceph-deploy osd create --data /dev/sdb master-139 ceph-deploy osd create --data /dev/sdb node1-140 ceph-deploy osd create --data /dev/sdb node2-141 三台节点都需分别依次执行。 都切换到/usr/local/ceph-cluster下执行 ceph-deploy gatherkeys master-139 2.验证节点： 输入 ceph health 或 ceph -s 查看， 出现 HEALTH_OK 代表正常。 [root@master-139 ceph-cluster]# ceph -s cluster: id: 4f74ac9a-b5f5-4bf5-9107-15ab8ea41f76 health: HEALTH_OK services: mon: 3 daemons, quorum master-139,node1-140,node2-141 mgr: master-139(active), standbys: node1-140, node2-141 osd: 3 osds: 3 up, 3 in data: pools: 0 pools, 0 pgs objects: 0 objects, 0 B usage: 3.0 GiB used, 297 GiB / 300 GiB avail pgs: 3.如果出现错误，各节点上执行,确保时间一致。 ntpdate ntp1.aliyun.com ","date":"2022-05-16","objectID":"/ceph/:2:1","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"安装管理后台（可选） 1.开启dashboard模块 ceph mgr module enable dashboard 2.生成签名 ceph dashboard create-self-signed-cert 3.创建目录 mkdir mgr-dashboard [root@master-139 mgr-dashboard]# pwd /usr/local/ceph-cluster/mgr-dashboard 4.生成密钥对 cd /usr/local/ceph-cluster/mgr-dashboard openssl req -new -nodes -x509 -subj \"/O=IT/CN=ceph-mgr-dashboard\" -days 3650 -keyout dashboard.key -out dashboard.crt -extensions v3_ca 5.启动dashboard ceph mgr module disable dashboard ceph mgr module enable dashboard 6.设置IP与PORT ceph config set mgr mgr/dashboard/server_addr 10.4.7.139 ceph config set mgr mgr/dashboard/server_port 18843 注意：ip为管理节点的主IP 7.关闭HTTPS ceph config set mgr mgr/dashboard/ssl false 8.查看服务信息 [root@master-139 mgr-dashboard]# ceph mgr services { \"dashboard\": \"https://master-139:8443/\" } 9.设置管理用户与密码 ceph dashboard set-login-credentials admin admin 10.访问 http://10.4.7.139:18843 ","date":"2022-05-16","objectID":"/ceph/:3:0","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"创建Cephfs 集群创建完后， 默认没有文件系统， 我们创建一个 Cephfs 可以支持对外访问的文件系统。 1.创建两个存储池, 执行两条命令 ceph osd pool create cephfs_data 128 ceph osd pool create cephfs_metadata 64 少于 5 个 OSD 可把 pg_num 设置为 128 OSD 数量在 5 到 10 ，可以设置 pg_num 为 512 OSD 数量在 10 到 50 ，可以设置 pg_num 为 4096 OSD 数量大于 50 ，需要计算 pg_num 的值 通过下面命令可以列出当前创建的存储池： [root@master-139 ceph-cluster]# ceph osd lspools 1 cephfs_data 2 cephfs_metadata 2.创建fs, 名称为cephfs ceph fs new cephfs cephfs_metadata cephfs_data 3.状态查看， 以下信息代表正常 [root@master-139 ceph-cluster]# ceph fs ls name: cephfs, metadata pool: cephfs_metadata, data pools: [cephfs_data ] [root@haproxy ceph-cluster]# ceph mds stat cephfs-1/1/1 up {0=haproxy=up:active}, 1 up:standby 这里mds如果只显示cephfs-1/1/1 up 后面没内容说明mds没创建需要手动创建。如果不创建后面ceph挂载会报错。提示mds不存在。 [root@master-139 ceph-cluster]# ceph mds stat cephfs-0/0/1 up #挂载时报错信息 [root@node1-140 ceph-cluster]# ceph-fuse -k /etc/ceph/ceph.client.admin.keyring -m 10.4.7.139:6789 /usr/local/cephfs_directory ceph-fuse[42676]: starting ceph client 2022-05-15 03:43:48.136 7f84eb7cac00 -1 init, newargv = 0x561dca3c0240 newargc=7 ceph-fuse[42676]: probably no MDS server is up? ceph-fuse[42676]: ceph mount failed with (65536) Unknown error 65536 手动创建mds ceph-deploy mds create master-139 node1-140 node2-141 附： 如果创建错误， 需要删除， 执行： ceph fs rm cephfs --yes-i-really-mean-it ceph osd pool delete cephfs_data cephfs_data --yes-i-really-really-mean-it 确保在ceph.conf中开启以下配置： [mon] mon allow pool delete = true ","date":"2022-05-16","objectID":"/ceph/:4:0","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"采用fuse挂载 先确定 ceph-fuse 命令能执行， 如果没有， 则安装： yum -y install ceph-fuse 1.创建挂载目录 mkdir -p /usr/local/cephfs_directory 2.挂载cephfs ceph-fuse -k /etc/ceph/ceph.client.admin.keyring -m 10.4.7.139:6789 /usr/local/cephfs_directory 3.查看磁盘挂载信息 #df -hT /usr/local/cephfs_directory 目录已成功挂载。 [root@node1-140 ceph-cluster]# df -hT | grep cephfs ceph-fuse fuse.ceph-fuse 94G 0 94G 0% /usr/local/cephfs_directory 注意查看当前ceph 的主节点是谁。三台机器中如果有一台突然宕机，然后又恢复了。此时出问题的那台将成为主节点。 [root@node1-140 ceph-cluster]# ceph -s cluster: id: 4f74ac9a-b5f5-4bf5-9107-15ab8ea41f76 health: HEALTH_OK services: mon: 3 daemons, quorum master-139,node1-140,node2-141 mgr: master-139(active), standbys: node1-140, node2-141 mds: cephfs-1/1/1 up {0=master-139=up:active}, 2 up:standby osd: 3 osds: 3 up, 3 in data: pools: 2 pools, 192 pgs objects: 21 objects, 2.2 KiB usage: 3.0 GiB used, 297 GiB / 300 GiB avail pgs: 192 active+clean io: client: 5.0 KiB/s wr, 0 op/s rd, 9 op/s wr active的是主节点， standbys是备用节点。 ","date":"2022-05-16","objectID":"/ceph/:4:1","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"ceph常用命令 ceph # 查看机器的监控状态 ceph health # 查看ceph的实时运行状态 ceph -w # 检查信息状态信息 ceph -s # 查看ceph存储空间 ceph df ceph认证 创建管理用户 为ceph创建一个admin用户并为admin用户创建一个密钥，把密钥保存到/etc/ceph目录下： ceph auth get-or-create client.admin mds 'allow' osd 'allow *' mon 'allow *' \u003e /etc/ceph/ceph.client.admin.keyring 或 ceph auth get-or-create client.admin mds 'allow' osd 'allow *' mon 'allow *' -o /etc/ceph/ceph.client.admin.keyring 为osd.0创建一个用户并创建一个key ceph auth get-or-create osd.0 mon 'allow rwx' osd 'allow *' -o /var/lib/ceph/osd/ceph-0/keyring 为mds.node1创建一个用户并创建一个key ceph auth get-or-create mds.node1 mon 'allow rwx' osd 'allow *' mds 'allow *' -o /var/lib/ceph/mds/ceph-node1/keyring 查看ceph集群中的认证用户及相关的key ceph auth list 删除集群中的一个认证用户 ceph auth del osd.0 集群相关 # 查看集群的详细配置 ceph daemon mon.node1 config show | more # 查看集群健康状态细节 ceph health detail # 查看ceph log日志所在的目录 ceph-conf --name mon.node1 --show-config-value log_file mon命令 ceph mon stat#查看mon的状态信息 ceph mon dump#查看你ceph映射信息 ceph mon remove node1 #删除一个mon节点 ceph-deploy mon destroy {host-name [host-name]...} ceph mon add node1 node1_ip #添加一个mon节点 ceph-deploy mon create {host-name [host-name]...} mon节点的/var/lib/ceph/mon/ceph-node2/store.db文件内容一致，添加mon注意先改配置目录配置文件，再推送到所有节点 ceph-deploy --overwrite-conf config push node1 node2 node3 mds命令 ceph mds stat #查看msd状态 ceph mds dump #msd的映射信息 ceph mds rm 0 mds.node1#删除一个mds节点 ceph-deploy mds create {host-name}[:{daemon-name}] [{host-name}[:{daemon-name}] ...] osd命令 ceph osd stat #查看osd状态 ceph osd dump #osd的映射信息 ceph osd tree#查看osd目录树 ceph osd down 0 #down掉osd.0节点 ceph osd rm 0#集群删除一个osd硬盘 ceph osd crush remove osd.4#删除标记 ceph osd getmaxosd#查看最大osd个数 ceph osd setmaxosd 10#设置osd的个数 ceph osd out osd.3#把一个osd节点逐出集群 ceph osd in osd.3#把逐出的osd加入集群 ceph osd pause#暂停osd （暂停后整个集群不再接收数据） ceph osd unpause#再次开启osd （开启后再次接收数据） ceph osd lspools#查看ceph集群中的pool数量 ceph osd pool create jiayuan 100#创建一个pool 这里的100指的是PG组 ceph osd pool delete jiayuan jiayuan --yes-i-really-really-mean-it #集群名字需要重复两次 rados df#显示集群中pool的详细信息 ceph osd pool get data pg_num #查看data池的pg数量 ceph osd pool set data target_max_bytes 100000000000000#设置data池的最大存储空间为100T（默认是1T) ceph osd pool set data size 3 #设置data池的副本数是3 ceph osd pool set data min_size 2 #设置data池能接受写操作的最小副本为2 ceph osd pool set data pg_num 100#设置一个pool的pg数量 ceph osd pool set data pgp_num 100#设置一个pool的pgp数量 pg命令 ceph pg stat#查看pg状态 ceph pg dump#查看pg组的映射信息 ceph pg map 0.3f#查看一个pg的map ceph pg 0.26 query#查看pg详细信息 ceph pg dump --format plain#显示一个集群中的所有的pg统计 rados和rbd命令 rados lspools#查看ceph集群中有多少个pool （只是查看pool) rados df #查看ceph集群中有多少个pool,并且每个pool容量及利用情况 rados mkpool test#创建一个pool rados create test-object -p test#创建一个对象object rados rm test-object-1 -p test#删除一个对象object rados -p test ls rbd ls pool_name#查看ceph中一个pool里的所有镜像 rbd info -p pool_name --image 74cb427c-cee9-47d0-b467-af217a67e60a #查看ceph pool中一个镜像的信息 rbd create -p test --size 10000 zhanguo#在test池中创建一个命名为zhanguo的10000M的镜像 rbd rm -p test lizhanguo #删除一个镜像 rbd resize -p test --size 20000 zhanguo #调整一个镜像的尺寸 CRUSH映射 ceph osd getcrushmap -o MAP #获取一个CRUSH映射 crushtool -d MAP -o MAP.TXT #反编译一个CRUSH映射 crushtool -c MAP.TXT -o MAP #编译一个CRUSH映射 ceph osd setcrushmap -i MAP #设置一个CRUSH映射 块设备的一些命令 单位为M，默认在rbd pool中 创建块设备：rbd create {image-name} --size {megabytes} --pool {pool-name} 列出块设备：rbd ls {poolname} -l 检索块信息：rbd --image {image-name} info 更改块大小：rbd resize --image {image-name} --size {megabytes} 删除块设备：rbd rm {image-name} 映射块设备：rbd map {image-name} --pool {pool-name} --id {user-name} 查看已映射块设备：rbd showmapped 取消映射：rbd unmap /dev/rbd/{poolname}/{imagename} 快照和克隆相关命令 创建快照： rbd --pool {pool-name} snap create --snap {snap-name} {image-name} rbd snap create {pool-name}/{image-name}@{snap-name} 快照回滚： rbd --pool {pool-name} snap rollback --snap {snap-name} {image-name} rbd snap rollback {pool-name}/{image-name}@{snap-name} 清除快照： rbd --pool {pool-name} snap purge {image-name} rbd snap purge {pool-name}/{image-name} 删除快照： rbd --pool {pool-name} snap rm --snap {snap-name} {image-name} rbd snap rm {pool-name}/{image-name}@{snap-name","date":"2022-05-16","objectID":"/ceph/:5:0","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"日志文件汇总 mon ,mgr , osd 等安装报错信息均在对应日志文件中。 /usr/local/ceph-cluster/ceph-deploy-ceph.log # tree /var/log/ceph/ /var/log/ceph/ ├── ceph.audit.log ├── ceph-client.admin.log ├── ceph.log ├── ceph-mds.haproxy.log ├── ceph-mgr.haproxy.log ├── ceph-mon.haproxy.log ├── ceph-osd.0.log └── ceph-volume.log ","date":"2022-05-16","objectID":"/ceph/:6:0","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["linux"],"content":"参考文档 1 2 3 ","date":"2022-05-16","objectID":"/ceph/:6:1","tags":["ceph集群"],"title":"ceph","uri":"/ceph/"},{"categories":["编程"],"content":"基于centos7/8安装任意版本python 编译安装python ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:1","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["编程"],"content":"安装python依赖环境 sudo yum -y install epel-release sudo yum -y update 重启(可选) reboot ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:2","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["编程"],"content":"安装编译环境 sudo yum -y groupinstall \"Development Tools\" sudo yum -y install openssl-devel bzip2-devel libffi-devel xz-devel ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:3","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["编程"],"content":"确认gcc可用 $ gcc --version gcc (GCC) 4.8.5 20150623 (Red Hat 4.8.5-44) Copyright (C) 2015 Free Software Foundation, Inc. This is free software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:4","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["编程"],"content":"选择编译包 官网编译包 wget https://www.python.org/ftp/python/3.9.12/Python-3.9.12.tgz ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:5","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["编程"],"content":"解压并进入 tar -zxvf Python-3.9.12.tgz cd Python-3.9.12/ ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:6","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["编程"],"content":"配置脚本 ./configure --enable-optimizations ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:7","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["编程"],"content":"开始编译 sudo make altinstall ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:8","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["编程"],"content":"如果成功将会显示以下内容 copying build/scripts-3.9/pydoc3.9 -\u003e /usr/local/bin copying build/scripts-3.9/idle3.9 -\u003e /usr/local/bin copying build/scripts-3.9/2to3-3.9 -\u003e /usr/local/bin changing mode of /usr/local/bin/pydoc3.9 to 755 changing mode of /usr/local/bin/idle3.9 to 755 changing mode of /usr/local/bin/2to3-3.9 to 755 rm /usr/local/lib/python3.9/lib-dynload/_sysconfigdata__linux_x86_64-linux-gnu.py rm -r /usr/local/lib/python3.9/lib-dynload/__pycache__ /usr/bin/install -c -m 644 ./Misc/python.man \\ /usr/local/share/man/man1/python3.9.1 if test \"xupgrade\" != \"xno\" ; then \\ case upgrade in \\ upgrade) ensurepip=\"--altinstall --upgrade\" ;; \\ install|*) ensurepip=\"--altinstall\" ;; \\ esac; \\ ./python -E -m ensurepip \\ $ensurepip --root=/ ; \\ fi Looking in links: /tmp/tmp3k1lhlmm Processing /tmp/tmp3k1lhlmm/setuptools-58.1.0-py3-none-any.whl Processing /tmp/tmp3k1lhlmm/pip-22.0.4-py3-none-any.whl Installing collected packages: setuptools, pip Successfully installed pip-22.0.4 setuptools-58.1.0 ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:9","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["编程"],"content":"确认是否安装成功 [root@43f873a76b81 Python-3.9.12]# python3.9 --version Python 3.9.12 ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:10","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["编程"],"content":"pip是否也安装了 [root@43f873a76b81 Python-3.9.12]# pip3.9 --version pip 22.0.4 from /usr/local/lib/python3.9/site-packages/pip (python 3.9) ","date":"2022-05-11","objectID":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/:0:11","tags":["python"],"title":"基于centos7/8安装任意版本python","uri":"/%E5%AE%89%E8%A3%85%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%ACpython/"},{"categories":["工具"],"content":"git入门 ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:0","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"介绍 Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:1","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"windows中安装 各操作系统版本下载 安装后在开始菜单里找到\"Git\"-\u003e“Git Bash”，会弹出 Git 命令窗口，你可以在该窗口进行 Git 操作。 创建工作目录，比如在D盘根目录下创建blog mkdir -p blog ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:2","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"git初始化 默认会生成.git文件夹 git init 用户信息 配置个人的用户名称和电子邮件地址： git config --global user.name \"smith\" git config --global user.email smith@gmail.com 查看配置信息 git config --list 也可以在配置文件中看到 vim ~/.gitconfig [http] postBuffer = 2M [user] name = smith email = smith@gmail.com ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:3","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"git 工作流程 git-process.png 创建readme.txt文件 Git is a version control system. Git is free software. 把文件提交到暂存区 git add readme.txt git commit -m \"first push\" -m:后面输入本次提交的说明，可以输入任何内容。 ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:4","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"查看提交日志 $ git log commit 934e87838ae19b396a9db3779f5722be53701f22 (HEAD -\u003e master) Author: smith \u003csmith@gmail.com\u003e Date: Mon May 9 09:17:05 2022 +0800 thired version commit 7580fbdc4ddfd4cf740cba51e1661b020806638c Author: smith \u003csmith@gmail.com\u003e Date: Mon May 9 09:16:18 2022 +0800 second version commit 48eca9171d496942470fbcb5b93500bf593c3fdf Author: smith \u003csmith@gmail.com\u003e Date: Mon May 9 09:12:21 2022 +0800 first push 精简输出加上--pretty=oneline $ git log --pretty=oneline 934e87838ae19b396a9db3779f5722be53701f22 (HEAD -\u003e master) thired version 7580fbdc4ddfd4cf740cba51e1661b020806638c second version 48eca9171d496942470fbcb5b93500bf593c3fdf first push commit后面的id是根据sha1算法得来的。 各个版本中readme.txt内容 版本一 Git is a version control system. Git is free software. 版本二 Git is a version control system. Git is free software. second version 版本三 Git is a version control system. Git is free software. thired version ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:5","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"版本回退 通过git log查看最新一次提交id为934e87838ae19b396a9db3779f5722be53701f22。git中用HEAD表示当前版本。上一个版本用HEAD^'表示，上上版本用HEAD^^表示。往上100个版本用HEAD~100表示。现在回到上一个版本。 $ git reset --hard HEAD^ HEAD is now at 7580fbd second version 查看readme.txt文件内容。果然回到上一个版本了。 查看当前版本库状态 $ git log commit 7580fbdc4ddfd4cf740cba51e1661b020806638c (HEAD -\u003e master) Author: smith \u003csmith@gmail.com\u003e Date: Mon May 9 09:16:18 2022 +0800 second version commit 48eca9171d496942470fbcb5b93500bf593c3fdf Author: smith \u003csmith@gmail.com\u003e Date: Mon May 9 09:12:21 2022 +0800 first push 发现之前的版本不见了，还可以通过commit id 回到之前的版本。id不用写全，至少写6位。 $ git reset --hard 934e87 HEAD is now at 934e878 thired version 再次查看readme.txt文件果然又回来了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向thired version. 如果还想回退到最新版本而又忘记了commit id ，Git提供了一个命令git reflog用来记录你的每一次命令。 $ git reflog 934e878 (HEAD -\u003e master) HEAD@{0}: reset: moving to 934e87 7580fbd HEAD@{1}: reset: moving to HEAD^ 934e878 (HEAD -\u003e master) HEAD@{2}: commit: thired version 7580fbd HEAD@{3}: commit: second version 48eca91 HEAD@{4}: commit (initial): first push 然后通过commit id回到最新版本。 ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:6","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"总结 HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。 穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。 ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:7","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"工作区和暂存区 工作区 在笔记本中创建的blog文件夹就是工作区。 暂存区 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 把文件向git版本库里添加时，分两步执行： 用git add把文件添加进去，实际上就是把文件修改添加到暂存区 用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 测试： 修改readme.txt文件。提交到暂存区，查看当前状态，最后提交到当前分支。 $ git status On branch master Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: readme.txt $ git commit -m \"change sth\" [master 410b2e7] change sth 1 file changed, 1 insertion(+), 1 deletion(-) $ git status On branch master nothing to commit, working tree clean 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： $ git status On branch master nothing to commit, working tree clean ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:8","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"管理修改 测试过程：第一次修改 -\u003e git add -\u003e 第二次修改 -\u003e git commit 修改readme.txt文件 第一次修改并提交到缓存区 $ vi readme.txt Git is a version control system. Git is free software. with add $ git add readme.txt 第二次修改直接使用commit 提交 $ with readme.txt Git is a version control system. Git is free software. no add $ git commit -m \"change sth\" [master 729bf9e] change sth 1 file changed, 1 insertion(+) 最后查看状态，发现第二次修改没被提交。 $ git status On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 总结 Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别： $ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txt index 23faa4f..199308a 100644 --- a/readme.txt +++ b/readme.txt @@ -1,3 +1,3 @@ Git is a version control system. Git is free software. -with add +no add 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -\u003e git add -\u003e 第二次修改 -\u003e git add -\u003e git commit 都操作完后查看状态。 $ git status On branch master nothing to commit, working tree clean ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:9","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"撤销更改 修改readme.txt文件–\u003egit add(提交到暂存区，没有commit) –\u003e发现文件修改有错误–\u003egit reset HEAD file(把暂存区的修改回退到工作区) –\u003egit checkout – file(丢弃工作区的修改)–\u003egit status (查看状态) vi readme.txt Git is a version control system. Git is free software. no add add sthssssss 提交到暂存区，没有commit $ git add readme.txt 查看状态。有修改。 $ git status On branch master Changes to be committed: (use \"git restore --staged \u003cfile\u003e...\" to unstage) modified: readme.txt 把暂存区的修改回退到工作区 $ git reset HEAD readme.txt Unstaged changes after reset: M readme.txt 查看状态。已撤回。 $ git status On branch master Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 丢弃工作区的修改 $ git checkout -- readme.txt 查看状态。 $ git status On branch master nothing to commit, working tree clean 文件已还原 $ cat readme.txt Git is a version control system. Git is free software. no add 总结 提交到暂存区的文件可以用git reset HEAD file命令把文件退回到工作区。 退回到工作区后用git checkout -- file命令丢弃工作区修改。 可以用git status查看状态。 ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:10","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"删除文件 文件提交后直接把文件删除可以在版本库中找到并恢复，如果从来没提交过，那文件是无法恢复的。 实验：创建test.txt文件并提交到版本库，工作区删除文件。并恢复。 git add . git commit -m 'test' rm test.txt 查看状态 $ git status On branch master Changes not staged for commit: (use \"git add/rm \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) deleted: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 恢复文件 $ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 如果确实不想用了版本区可以删除文件，这样就永久删除了。 git rm test.txt ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:11","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"远程仓库 需求： 将本地仓和远程仓数据同步，还可以多人协同。 本地仓：笔记本 远程仓：github 1.github上创建新仓库 2.将远程仓库克隆到本地 $ git remote add origin git@github.com:github用户名/仓库名.git 3.把本地库所有内容推送到远程库 $ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样。 后面再次推送可以使用简化命令 $ git push origin master 删除远程库 如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm \u003cname\u003e命令。使用前，建议先用git remote -v查看远程库信息。 $ git remote -v origin git@github.com:michaelliao/learn-git.git (fetch) origin git@github.com:michaelliao/learn-git.git (push) 然后，根据名字删除，比如删除origin： $ git remote rm origin 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。 总结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改。 从远程库克隆 克隆一个本地库 $ git clone git@github.com:github用户名/仓库名.git 本地查看有了。 有几种方式克隆仓库到本地 https :https://github.com/github用户名/仓库名.git ssh : git@github.com :github用户名/仓库名.git github cli : gh repo clone github用户名/仓库名 推荐使用ssh方式，速度更快。 ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:12","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"分支管理 创建分支dev $ git checkout -b dev Switched to a new branch 'dev' 查看当前分支，星号代表当前分支 $ git branch -a * dev master 写入内容 $ vi readme.txt Git is a version control system. Git is free software. dev branch add sth 上传到暂存区，并推送到dev分支。 $ git add . $ git commit -m \"push dev branch\" [dev d51e5f2] push dev branch 1 file changed, 1 insertion(+) 切换到master主分支，查看readme.txt文件发现最后一行不见了。git中各分支之间互不影响。 git checkout master 将dev分支和master主分支合并。merge后面是要合并的分支名。 $ git merge dev Updating 8e3076e..d51e5f2 Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) 切换到master分支 git checkout master 再次查看文件内容，显示了。 $ cat readme.txt Git is a version control system. Git is free software. dev branch add sth 删除dev分支 git branch -d dev 总结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch \u003cname\u003e 切换分支：git checkout \u003cname\u003e或者git switch \u003cname\u003e 创建+切换分支：git checkout -b \u003cname\u003e或者git switch -c \u003cname\u003e 合并某分支到当前分支：git merge \u003cname\u003e 删除分支：git branch -d \u003cname\u003e 新版本git 支持switch来切换分支。更加容易区分。 ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:13","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"分支管理策略 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下--no-ff方式的git merge： 首先，仍然创建并切换dev分支： $ git switch -c dev Switched to a new branch 'dev' 修改readme.txt文件，并提交一个新的commit： $ git add readme.txt $ git commit -m \"add merge\" [dev f52c633] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master： $ git switch master Switched to branch 'master' 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： $ git merge --no-ff -m \"merge with no-ff\" dev Merge made by the 'recursive' strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： $ git log --graph --pretty=oneline --abbrev-commit * f116cb6 (HEAD -\u003e master) merge with no-ff |\\ | * 98d73ce (dev) add merge |/ * d51e5f2 push dev branch * 8e3076e init * 3f097bb dev branch commit * 601bf08 del sth 分支策略 master分支应该是非常稳定的，也就是仅用来发布新版本 dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本。 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 Bug分支 发现master分支有Bug需要修复，此时dev上的工作还没提交到暂存区。可以用git stash命令将当前工作现场保存起来，后面修复完Bug后在还原回来。 $ git status On branch dev Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git stash Saved working directory and index state WIP on dev: 7f2ad74 init status $ git status On branch dev nothing to commit, working tree clean 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： $ git checkout master Switched to branch 'master' 创建新分支issue-102 $ git checkout -b issue-102 Switched to a new branch 'issue-102' 修复Bug（修改readme.txt文件内容），然后提交。 $ git add readme.txt $ git commit -m \"fix bug 102\" [issue-102 858cab6] fix bug 102 1 file changed, 1 insertion(+) 修复完成后，切换到master分支，并完成合并，最后删除issue-102分支： $ git switch master Switched to branch 'master' $ git merge --no-ff -m \"merged bug fix 102\" issue-102 Merge made by the 'ort' strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 现在回到dev分支还原之前的工作状态 $ git switch dev Switched to branch 'dev' 查看之前存储的数据 $ git stash list stash@{0}: WIP on dev: 7f2ad74 init status 两种方法恢复之前的工作内容 用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除 用git stash pop，恢复的同时把stash内容也删了 $ git stash pop On branch dev Changes not staged for commit: (use \"git add \u003cfile\u003e...\" to update what will be committed) (use \"git restore \u003cfile\u003e...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") Dropped refs/stash@{0} (6228502b0116dba3633cdb19b738aba9bd6d4664) 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： $ git stash apply stash@{0} 在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。 先切换到master分支上查看之前“ fix bug 102” 那条commit id $ git switch master #也可以用git switch -来切换。 $ git log --graph commit 858cab6c5238646df8d353bfd83382a92a432fcd (issue-102) Author: smith \u003csmith@gmail.com\u003e Date: Tue May 10 13:18:18 2022 +0800 fix bug 102 Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支。再次切换到dev分支，复制master分支上“fix bug 102”这条改动提交。 $ git branch * dev master $ git cherry-pick 858cab [dev 0996ec3] fix bug 102 Date: Tue May 10 13:18:18 2022 +0800 1 file changed, 1 insertion(+) Git自动给dev分支做了一次提交，注意这次提交的commit是0996ec3，它并不同于master的858cab，因为这两个commit只是改动相同，但确实是两个不同的commit。用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。 总结 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick \u003ccommit\u003e命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:14","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"参考 1 ","date":"2022-05-07","objectID":"/git%E5%85%A5%E9%97%A8/:1:15","tags":["git"],"title":"git入门","uri":"/git%E5%85%A5%E9%97%A8/"},{"categories":["工具"],"content":"ansible的配置文件 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:1:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"全局配置文件 ansible默认的全局配置文件是/etc/ansible/ansible.cfg，可认为是全局配置的入口。 Ansible支持4种方式指定配置文件，它们的解析顺序从上到下 ANSIBLE_CFG 环境变量指定的配置文件 ansible.cfg 当前目录下的ansible.cfg ~/.ansible.cfg 家目录下的.ansible.cfg /etc/ansible/ansible.cfg 默认全局配置文件 修改默认配置文件/etc/ansible/ansible.cfg： $ cat /etc/ansible/ansible.cfg | grep -vE \"^$|^#\" [defaults] inventory = /etc/ansible/hosts # inventory文件：ansible管理的主机清单 library = /usr/share/my_modules/ forks = 5 # ansbile的并发连接数 sudo_user = root remote_port = 22 host_key_checking = False timeout = 10 log_path = /var/log/ansible.log 文件中其它的可配置项： stdout_callback = debug # 可将输出变得人性化；默认输出会挤在一行，配置后会换行输出； ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:1:1","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"inventory主机文件 inventory文件默认路径是/etc/ansible/hosts，在这里配置目标主机，ansible便可以对其进行控制。 在/etc/ansible/hosts文件里配置node主机名或ip： $ cat hosts [default] # 主机分组 node1 # 172.18.0.101 node2 # 172.18.0.102 可以通过/etc/ansible/ansible.cfg文件修改inventory的默认路径：inventory = /etc/ansible/hosts。如果将该配置指定为目录，便可以使用多个inventory文件来管理节点，一般很少动这个。 通常，不会修改默认的路径。如果有自定义的inventory文件，可以直接在ansible命令行中使用-i选项指定: # ansible -i /tmp/my_inventory.ini ... # ansible-playbook -i /tmp/my_inventory.ini ... ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:1:2","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"查看inventory 列出ansiblek可管理的所有主机 $ ansible-inventory --graph all # 指定文件：ansible-inventory -i /etc/ansible/hosts --graph all @all: # all是默认的主机组，包含所有主机 |--@default: | |--node1 | |--node2 |--@ungrouped: ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:1:3","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"运行ansible命令 完成上述的基本配置后，即可以开始使用ansible来批量管理主机了，这里的管理方式为命令行方式（又称为Ad-hoc方式）。 Ad-hoc方式运行ansible的命令格式：ansible 主机组/主机 -m 模块 -a 参数 选项解析： -m: 指定调用的模块 -a: 向模块传递的参数，模块不需要则可省略;参数需要使用引号包围 此外ansible命令还可以带上其它选项： -i: 指定本次的inventory路径，指定该参数则后面不加主机组/主机 -e: 设置变量，格式为'var1=\"aaa\" var=\"bbb\"' -v/vv/vvv: 命令输出的打印级别 ansible的批量管理功能依靠各个模块来完成，ansible提供了几千个模块（其中ansible团队自己维护大约100多个核心模块），每个模块完成各自的作用。 下面用ping模块和debug模块来演示一下ansible的基础功能。 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:2:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"ping模块 ping模块是ansible最基础模块之一，可用于检测远程主机是否在线。 命令：ansible 主机组/主机 -m ping 返回值：changed、ping 命令：ansible all -m ping [root@master ansible]$ ansible all -m ping node2 | SUCCESS =\u003e { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } node1 | SUCCESS =\u003e { \"ansible_facts\": { \"discovered_interpreter_python\": \"/usr/bin/python\" }, \"changed\": false, \"ping\": \"pong\" } ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:2:1","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"debug模块 官网说明：https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html debug模块用于输出或调试一些变量或数据。该模块共有三个参数msg、var、verbosity。 msg：打印配置的信息 var：打印变量值 verbosity：运行级别，设置为3，则-vvv或更高才会打印输出 命令： ansible all -m debug -a 'msg=\"hello world\"' ansible all -e 'str=\"hello world\"' -m debug -a 'var=str' ansible all -v -m debug -a 'msg=\"hello world\" verbosity=1' 示例： [root@master ansible]$ ansible all -m debug -a 'msg=\"hello world\"' node1 | SUCCESS =\u003e { \"msg\": \"hello world\" } node2 | SUCCESS =\u003e { \"msg\": \"hello world\" } [root@master ansible]$ ansible all -e 'str=\"hello world\"' -m debug -a 'var=str' node1 | SUCCESS =\u003e { \"str\": \"hello world\" } node2 | SUCCESS =\u003e { \"str\": \"hello world\" } [root@master ansible]$ ansible all -m debug -a 'msg=\"hello world\" verbosity=1' node1 | SKIPPED node2 | SKIPPED [root@master ansible]$ ansible all -v -m debug -a 'msg=\"hello world\" verbosity=1' Using /etc/ansible/ansible.cfg as config file node1 | SUCCESS =\u003e { \"msg\": \"hello world\" } node2 | SUCCESS =\u003e { \"msg\": \"hello world\" } ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:2:2","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"playbook playbook是一个yaml格式的文件，由一个或多个play按顺序列表的方式组成。每个play运行一个或多个task，每个task调用一个模块module。 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:3:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"playbook、play、task的关系 playbook中可以定义一个或多个play 每个play中可以定义一个或多个task 其中还可以定义两类特殊的task：pre_tasks和post_tasks pre_tasks表示执行执行普通任务之前执行的任务列表 post_tasks表示普通任务执行完之后执行的任务列表 每个play都需要通过hosts指令指定要执行该play的目标主机 每个play都可以设置一些该play的环境控制行为，比如定义play级别的变量 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:3:1","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"编写一个playbook并执行 playbook使用yaml语法格式组织各种play和task规则。 下面使用ping模块和debug模块编写一个playbook文件如下： # cat test.yaml --- - name: play1 # play的名称，非必须 hosts: all # 指定目标主机 gather_facts: false # 收集目标主机信息，默认值true，非必须 tasks: # tasks声明任务列表 - name: task1 # task任务名称，非必须 ping: # 模块 data: \"pong task1\" # 模块参数 - name: task2 ping: data: \"pong task2\" - name: play2 hosts: all gather_facts: false tasks: - name: task1 debug: msg: \"hello task1 in play2\" - name: task2 debug: msg: \"hello task2 in play2\" 注意所有的-和:符号后面均需要接一个空格 执行playbook的命令是ansible-playbook test.yaml： 该命令同样支持像ansile命令一样的多个选项，如-e、-i、-v等 $ ansible-playbook -v test.yaml Using /etc/ansible/ansible.cfg as config file PLAY [play1] ********************************************************************************************************************** TASK [task1] ********************************************************************************************************************** ok: [node2] =\u003e {\"ansible_facts\": {\"discovered_interpreter_python\": \"/usr/bin/python\"}, \"changed\": false, \"ping\": \"pong task1\"} ok: [node1] =\u003e {\"ansible_facts\": {\"discovered_interpreter_python\": \"/usr/bin/python\"}, \"changed\": false, \"ping\": \"pong task1\"} TASK [task2] ********************************************************************************************************************** ok: [node1] =\u003e {\"changed\": false, \"ping\": \"pong task2\"} ok: [node2] =\u003e {\"changed\": false, \"ping\": \"pong task2\"} PLAY [play2] ********************************************************************************************************************** TASK [task1] ********************************************************************************************************************** ok: [node1] =\u003e { \"msg\": \"hello task1 in play2\" } ok: [node2] =\u003e { \"msg\": \"hello task1 in play2\" } TASK [task2] ********************************************************************************************************************** ok: [node1] =\u003e { \"msg\": \"hello task2 in play2\" } ok: [node2] =\u003e { \"msg\": \"hello task2 in play2\" } PLAY RECAP ************************************************************************************************************************ node1 : ok=4 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 node2 : ok=4 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:3:2","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"playbook文件各配置指令及含义 yaml文件中，使用-表示一个列表元素，多个key：value表示一个字典。 每个playbook使用列表来组织多个play，play内同样使用列表来组织多个task；play和task自身则采用字典的方式组织，即多个键值对。 在playbook顶层使用- xxx:表示这是一个play；每个play中必须包含hosts和tasks指令。 hosts指令用来指定要执行该play的目标主机，可以是主机名、主机组或者其它多种方式。 tasks指令用来指定该play中包含的任务列表，每个任务使用- xxx:方式表示。 name指令用来设置play和task的名称，值具有唯一性。 gather_facts指令用来收集目标主机的信息，由setup模块提供。默认情况下，每个play都先执行这个特殊任务，收集完信息才开始其它任务。如果后续任务中用不到该信息，则可以禁止掉该任务，提升效率。 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:3:3","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"向模块传递参数 yaml中，向模块传递参数的方式总结为字符串和数组两种方式。 还是以debug模块为例。 数组方式如上面test.yaml文件里的传参，即key: value的形式： ...... - name: task1 debug: msg: \"hello task1 in play2\" verbosity=1 字符串方式，由于yaml的语法规则（字符串换行将自动转换为空格），又有不同的书写形式： --- - name: debug hosts: all gather_facts: false tasks: - name: task1 debug: msg=\"hello task1\" verbosity=1 # 参数写成一行 - name: task2 debug: msg=\"hello task2\" # 参数写成多行 verbosity=1 - name: task3 debug: | # 竖线|，将保留字符串的换行符，否则将自动转换成空格，在一些模块中很有用，如shell msg=\"hello task3\" verbosity=1 - name: task4 debug: \u003e # 符号\u003e，效果和直接写成多行一样 msg=\"hello task4\" verbosity=1 还可以直接使用指令args指明参数： ...... - name: task1 debug: args: msg: \"hello task1 in play2\" ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:3:4","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"默认的任务执行策略 /etc/ansible/ansible.cfg文件的forks配置，决定ansible执行任务的并发连接数。 假如forks配置为5，那么ansible第一次将同时连接5个node节点执行任务。其中若有节点提前执行完任务， 则ansible会新建一个新进程，来连接下一个节点执行任务。 forks是保证最多有N个节点同时执行任务。 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:3:5","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"常见模块 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:4:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"shell模块 说明： shell模块接收shell命令，命令后可跟空格分割的参数列； 必须传入自由格式的命令，或者cmd参数； 它十分类似command模块，但是它在远程主机上通过shell（比如/bin/bash）来运行命令； shell模块相比command模块，支持解析特殊符号\u003c、\u003e、|、;、\u0026等。 参数： Parameter Choices/Defaults 说明 chdir path 运行脚本前，切换到相关目录 cmd string 需要运行的命令，后跟可选的参数 creates path 若一个文件或目录存在，则跳过该步骤 removes path 若一个文件或目录不存在，则跳过该步骤 executable path 改变执行命令的解释器，如/bin/bash、/usr/bin/expect、/usr/bin/python；绝对路径 free_form string 自由格式的命令（即命令字符串，没有相关参数，直接写在shell模块后面即可） stdin string Set the stdin of the command directly to the specified value. stdin_add_newline boolean Choices: no yes ←（default） Whether to append a newline to stdin data. warn boolean Choices: no yes ←(default) Whether to enable task warnings. 示例： --- - name: shell hosts: all gather_facts: no tasks: - name: task1 shell: hostname - name: task2 shell: cmd: date +\"%F %T\" - name: task3 shell: cmd: pwd chdir: /etc/sysconfig - name: task4 shell: cmd: ls /tmp creates: /tmp - name: task5 shell: cmd: print('hello world') executable: /usr/bin/python 注意chdir参数只支持下面的方式： - name: task3 shell: cmd: pwd chdir: /etc/sysconfig - name: task3 shell: pwd # free_from格式需要采用args参数，显式指定chdir参数 args: chdir: /etc/sysconfig # 下面的方式将发生错误 - name: task3 shell: pwd chdir: /etc/sysconfig Ad-hoc方式： $ ansible all -m shell -a \"ls -l | wc -l\" $ ansible all -v -m shell -a \"ls chdir=/tmp \" https://docs.ansible.com/ansible/latest/collections/ansible/builtin/shell_module.html#ansible-collections-ansible-builtin-shell-module ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:4:1","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"script模块 说明： script模块接受一个脚本名称，后面可跟空格分割的参数列； 支持自由格式的命令，或者cmd参数； 将本地脚本传输到远程主机上执行； 在远程主机上使用shell环境执行脚本； 该模块不需要python，类似raw模块。 参数： Parameter Choices/Defaults 说明 chdir path 运行脚本前，切换到远程主机的相关目录 cmd string 需要运行的脚本路径，后跟可选的参数 creates path 若一个文件或目录存在，则跳过该步骤 removes path 若一个文件或目录不存在，则跳过该步骤 示例： sctipt-simple.yml --- - name: script hosts: web tasks: - name: list files script: /etc/ansible/test-yml/trans_exec.sh trans_exec.sh #!/bin/bash date \u0026\u0026 hostname Ad-hoc： $ ansible all -m script -a \"/tmp/hello.sh world\" $ ansible all -m script -a \"/tmp/hello.sh world creates=/tmp\" https://docs.ansible.com/ansible/latest/collections/ansible/builtin/script_module.html#ansible-collections-ansible-builtin-script-module ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:4:2","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"hostname模块 说明： 设置系统的主机名 参数： Parameter Choices/Defaults 说明 name string / required 设置主机名 示例： - name: Set a hostname ansible.builtin.hostname: name: web01 - name: Set a hostname specifying strategy ansible.builtin.hostname: name: web01 use: systemd https://docs.ansible.com/ansible/latest/collections/ansible/builtin/hostname_module.html ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:4:3","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"在playbook中设置变量 vars指令可在play或task中设置变量，可以设置一个或多个。可以采用字典或列表的形式定义变量。 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:5:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"字典变量的定义和引用 定义： vars: foo1: a: hello b: world foo2: a: aaa b: bbb 引用： 使用点号或方括号，在yaml文件使用jinja2语法引用，需要加单双引号，否则解析yaml的时候将报错 - name: task1 debug: msg: \"{{ foo1.a }} {{ foo1['b'] }}\" # 注意{{}}是jinja2的语法，在yaml文件中需要使用引号引起来，单双引号都行 - name: task2 debug: var: foo1.a,foo1['b'] # debug模块的var参数，多个值使用逗号分隔，且无需花括号，前后加不加引号均可 - name: task3 debug: msg: '{{ foo2.a }} {{ foo2.b }}' 示例： --- - name: vars play hosts: all gather_facts: no vars: foo1: a: hello b: world foo2: a: aaa b: bbb tasks: - name: task1 debug: msg: \"{{ foo1.a }} {{ foo1['b'] }}\" - name: task2 debug: var: foo1.a,foo1['b'] - name: task3 debug: msg: '{{ foo2.a }} {{ foo2.b }}' ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:5:1","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"列表变量的定义和引用 定义： vars: foo: - a: hello b: world - a: aaa b: bbb 引用： - name: task1 debug: msg: \"{{ foo[0].a }} {{ foo[0].b }}\" - name: task2 debug: msg: \"{{foo[1]['a']}} {{foo[1]['b']}}\" 引用变量时，使用点号比较方便，但如果变量名本身带点，则尽量选择方括号的方式。 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:5:2","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"when指令进行条件判断 when指令是ansible提供的唯一一个通用条件指令。when指令后的变量引用不需要双花括号，当when指令的值为true时，执行任务。 yaml文件如下： --- - name: when hosts: all gather_facts: no vars: foo: test tasks: - name: task1 when: foo == \"test\" # when指令的变量可直接引用 debug: msg: \"hello\" - name: task2 when: foo == \"dev\" debug: msg: \"world\" 示例： 从输出中可看出，任务task2由于条件不满足自动跳过 [root@master ansible]# ansible-playbook -v when.yaml Using /etc/ansible/ansible.cfg as config file PLAY [when] *********************************************************************************************************************** TASK [task1] ********************************************************************************************************************** ok: [node1] =\u003e { \"msg\": \"hello\" } ok: [node2] =\u003e { \"msg\": \"hello\" } TASK [task2] ********************************************************************************************************************** skipping: [node1] =\u003e {} skipping: [node2] =\u003e {} PLAY RECAP ************************************************************************************************************************ node1 : ok=1 changed=0 unreachable=0 failed=0 skipped=1 rescued=0 ignored=0 node2 : ok=1 changed=0 unreachable=0 failed=0 skipped=1 rescued=0 ignored=0 多个判断条件： - name: task3 when: foo == \"dev\" or foo == \"test\" # 逻辑或 debug: msg: \"hello world\" - name: task4 when: (foo == \"dev\") or (foo == \"test\") # 支持括号括起来 debug: msg: \"hello world\" - name: task5 when: (foo == \"dev\") and (foo == \"test\") # 逻辑与 debug: msg: \"hello world\" - name: task6 when: - foo == \"dev\" # 逻辑与的另一种组织方式 - foo == \"test\" debug: msg: \"hello world\" - name: task7 when: foo != \"dev\" # 逻辑否 debug: msg: \"hello world\" ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:6:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"loop循环结构 loop指令中的各项元素将以item变量名进行迭代。 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:7:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"直接迭代列表 迭代简单列表： 列表元素为字符串 - name: task1 shell: \"{{ item }}\" loop: - hostname - \"uptime -p\" 示例： [root@master ansible]# cat loop.yaml --- - name: loop hosts: all gather_facts: no tasks: - name: task1 shell: \"{{ item }}\" loop: - hostname - \"uptime -p\" [root@master ansible]# ansible-playbook -v loop.yaml Using /etc/ansible/ansible.cfg as config file PLAY [loop] *********************************************************************************************************************** TASK [task1] ********************************************************************************************************************** changed: [node2] =\u003e (item=hostname) =\u003e {\"ansible_facts\": {\"discovered_interpreter_python\": \"/usr/bin/python\"}, \"ansible_loop_var\": \"item\", \"changed\": true, \"cmd\": \"hostname\", \"delta\": \"0:00:00.020436\", \"end\": \"2022-01-09 15:05:17.126971\", \"item\": \"hostname\", \"rc\": 0, \"start\": \"2022-01-09 15:05:17.106535\", \"stderr\": \"\", \"stderr_lines\": [], \"stdout\": \"node2\", \"stdout_lines\": [\"node2\"]} changed: [node1] =\u003e (item=hostname) =\u003e {\"ansible_facts\": {\"discovered_interpreter_python\": \"/usr/bin/python\"}, \"ansible_loop_var\": \"item\", \"changed\": true, \"cmd\": \"hostname\", \"delta\": \"0:00:00.361005\", \"end\": \"2022-01-09 15:05:17.409020\", \"item\": \"hostname\", \"rc\": 0, \"start\": \"2022-01-09 15:05:17.048015\", \"stderr\": \"\", \"stderr_lines\": [], \"stdout\": \"node1\", \"stdout_lines\": [\"node1\"]} changed: [node2] =\u003e (item=uptime -p) =\u003e {\"ansible_loop_var\": \"item\", \"changed\": true, \"cmd\": \"uptime -p\", \"delta\": \"0:00:00.006628\", \"end\": \"2022-01-09 15:05:17.610052\", \"item\": \"uptime -p\", \"rc\": 0, \"start\": \"2022-01-09 15:05:17.603424\", \"stderr\": \"\", \"stderr_lines\": [], \"stdout\": \"up 3 weeks, 2 days, 19 hours, 42 minutes\", \"stdout_lines\": [\"up 3 weeks, 2 days, 19 hours, 42 minutes\"]} changed: [node1] =\u003e (item=uptime -p) =\u003e {\"ansible_loop_var\": \"item\", \"changed\": true, \"cmd\": \"uptime -p\", \"delta\": \"0:00:00.074039\", \"end\": \"2022-01-09 15:05:18.006283\", \"item\": \"uptime -p\", \"rc\": 0, \"start\": \"2022-01-09 15:05:17.932244\", \"stderr\": \"\", \"stderr_lines\": [], \"stdout\": \"up 3 weeks, 2 days, 19 hours, 42 minutes\", \"stdout_lines\": [\"up 3 weeks, 2 days, 19 hours, 42 minutes\"]} PLAY RECAP ************************************************************************************************************************ node1 : ok=1 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 node2 : ok=1 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 迭代hash哈希列表： 列表元素为字典 - name: task1 shell: cmd: \"{{ item.cmd }}\" creates: \"{{ item['condition'] }}\" # 两种引用方式均可 loop: - { cmd: 'hostname', condition: '/tmp' } # 这个循环将被跳过 - { cmd: 'uptime', condition: '/aaa' } 示例： [root@master ansible]# cat loop.yaml --- - name: loop hosts: all gather_facts: no tasks: - name: task1 shell: cmd: \"{{ item.cmd }}\" creates: \"{{ item.condition }}\" loop: - { cmd: 'hostname', condition: '/tmp' } # 这个循环将被跳过，[\"skipped, since /tmp exists\"]，任务没有跳过 - { cmd: 'uptime', condition: '/aaa' } [root@master ansible]# [root@master ansible]# ansible-playbook -v loop.yaml Using /etc/ansible/ansible.cfg as config file PLAY [loop] *********************************************************************************************************************** TASK [task1] ********************************************************************************************************************** ok: [node2] =\u003e (item={u'cmd': u'hostname', u'condition': u'/tmp'}) =\u003e {\"ansible_facts\": {\"discovered_interpreter_python\": \"/usr/bin/python\"}, \"ansible_loop_var\": \"item\", \"changed\": false, \"cmd\": \"hostname\", \"item\": {\"cmd\": \"hostname\", \"condition\": \"/tmp\"}, \"rc\": 0, \"stdout\": \"skipped, since /tmp exists\", \"stdout_lines\": [\"skipped, since /tmp exists\"]} changed: [node2] =\u003e (item={u'cmd': u'uptime', u'condition': u'/aaa'}) =\u003e {\"ansible_loop_var\": \"item\", \"changed\": true, \"cmd\": \"uptime\", \"delta\": \"0:00:00.024675\", \"end\": \"2022-01-09 15:21:23.286758\", \"item\": {\"cmd\": \"uptime\", \"condition\": \"/aaa\"}, \"rc\": 0, \"start\": \"2022-01-09 15:21:23.262083\", \"stderr\":","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:7:1","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"迭代字典 loop指令无法直接迭代字典，需要使用过滤器dict2items进行转换，如下： - name: Using dict2items ansible.builtin.debug: msg: \"{{ item.key }} - {{ item.value }}\" loop: \"{{ tag_data | dict2items }}\" vars: tag_data: Environment: dev Application: payment 上例中，通过迭代tag_data来打印它的key和value。 when指令和loop指令同时使用时，先进行循环，再在每个循环中进行条件判断。 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:7:2","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"notify和handlers ansible中的一个重要概念changed，它表示目标状态是否发生改变，即本次任务是否执行、执行后是否影响结果。如果changed=1，则表示目标状态发生改变；如果changed=0，则表示目标状态未发生改变，或者任务没有执行。 ansible若监视到changed=1，就会触发notify指令所定义的handler。handler，也是一个task，只是定义在handlers中，需要notify来触发执行。 handlers的使用与tasks使用一样，notify和hanlders中任务名称必须一样。 **当一个play中所有任务都执行完成后，handler才会执行。**好处是可以多次触发notify，但最后只执行一次对应的handler。 示例： --- - name: notify and handlers hosts: all gather_facts: no tasks: - name: task1 shell: uptime notify: hello handlers: - name: hello debug: msg: \"hello world\" 执行结果： [root@master ansible]# ansible-playbook notify.yaml PLAY [notify and handlers] ******************************************************************************************************** TASK [task1] ********************************************************************************************************************** changed: [node2] changed: [node1] RUNNING HANDLER [hello] *********************************************************************************************************** ok: [node2] =\u003e {} MSG: hello world ok: [node1] =\u003e {} MSG: hello world PLAY RECAP ************************************************************************************************************************ node1 : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 node2 : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:8:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"组织playbook 将所有play全部写在一个yaml文件中，固然可行，但是可读性、维护性太差。 比较好的做法是，将同类任务的play放在一个文件中。多个任务，则写成多个文件，最后使用一个入口文件来引用这些任务文件。 假设入口文件名为main.yaml，在该文件中使用import_playbook指令引用其它playbook： --- - import_playbook: \"init_server/aaa.yaml\" - import_playbook: \"init_server/bbb.yaml\" - import_playbook: \"init_server/ccc.yaml\" - import_playbook: \"init_server/ddd.yaml\" 执行方式不变：ansible-playbook main.yaml ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:9:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"组织各类内容：task、handler、变量 上面介绍了使用playbook指令来引入多个playbook文件，从而提高可读性和维护性。 其实，ansible还提供了更加规范的方式，来组织更多的内容，即role和colllection，collection这里暂不涉及。 ansible可组织的内容包括： playbook task variable handler（handler也是一个task，只是编写在handlers内部） role 可组织的意思是说，可将相同内容定义在同一个文件中，然后使用相关指令来引入指定文件内容。 引入palybook：import_playbook 引入task或handler：import_tasks、include_tasks 引入variable：vars_files、include_vars 引入role：import_role、include_role、roles import和include两种引入方式有所区别，前者为静态加载（在playbook解析的阶段，内容将写入到引入的位置），后者为动态加载（解析阶段不引入，而是在执行阶段才引入）。 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:10:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"组织tasks 可将task单独写在一个文件中，然后在play里使用import_tasks、include_tasks模块引入。 示例： 编写一个tasks文件tasks.yaml： --- - name: task1 debug: msg: \"hello\" - name: task2 debug: msg: \"world\" 在playbook中引入： --- - name: play1 hosts: node1 gather_facts: no tasks: - name: task1 \u0026 task2 import_tasks: tasks.yaml # include_tasks模块也行 在循环中引入tasks文件，必须使用include_tasks指令 --- - name: play1 hosts: node1 gather_facts: no tasks: - name: loop tasks include_tasks: tasks.yaml loop: - one - two ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:10:1","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"组织handlers 一般情况下playbook的handlers如下，在task中使用handler的任务名来触发 --- - name: play1 hosts: node1 gather_facts: no tasks: - name: task1 shell: uptime notify: h1 - name: task2 shell: date notify: h2 handlers: - name: h1 debug: msg: \"run h1\" - name: h2 debug: msg: \"run h2\" 可将handler单独编写在一个文件中，如下： $ cat handler1.yaml --- - name: handler1 debug: msg: \"run handler1\" $ cat handler2.yaml --- - name: handler2 debug: msg: \"run handler2\" 然后在playbook中使用import_tasks或include_tasks指令来引入，同时在notify中修改对应的handler名： --- - name: play1 hosts: node1 gather_facts: no tasks: - name: task1 shell: uptime notify: handler1 # handler1为静态引入，notify使用handler名 - name: task2 shell: date notify: h2 # handler2为动态引入，notify使用引入的任务名 handlers: - name: h1 import_tasks: handler1.yaml # import_tasks静态引入 - name: h2 include_tasks: handler2.yaml # include_tasks动态引入 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:10:2","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"组织变量 前面已经介绍了如何在playbook中使用var指令直接设置变量，除了这个方法，ansible还支持将变量单独放在一个文件中，然后在play中使用vars_files指令或include_vars模块来引入该变量文件。也可以在命令行中，使用-e选项（–extra_vars）来设置变量或引入变量文件。 vars_files是play级别的指令，用于play中，在playbook解析阶段引入变量文件； include_vars是任务模块（类似模块一样），用在tasks中定义一个引入变量的任务，只有该任务执行之后，才会创建变量； -e选项在命令行中，全局有效； vars_files示例 变量文件varfile.yaml，变量的定义一样，使用yaml或json格式，可采用字典或列表的形式。 --- foo: a: hello b: world playbook文件如下，使用vars_files指令来引入： --- - name: play1 hosts: node1 gather_facts: no vars_files: - varfile.yaml # 多个变量文件，使用列表形式即可 tasks: - name: task1 debug: msg: \"{{foo.a}} {{foo.b}}\" include_vars模块 include_vars是模块提供的功能，它是一个手动创建的任务，和shell、debug等模块一样。所以只有当任务执行完后，相关变量才会创建。 下面介绍几个用法。 引入一个文件： --- - name: play1 hosts: node1 gather_facts: no vars_files: - varfile.yaml tasks: - name: task1 include_vars: varfile.yaml # 引入之后，可在后续的任务中使用 - name: task2 debug: msg: \"{{foo.a}} {{foo.b}}\" 引入多个文件，可采用循环： - name: task1 include_vars: \"{{ item }}\" loop: - varfile1.yaml - varfile2.yaml 还可以引入目录，使用条件和其它参数控制引入的变量文件。这里不展开了，该模块有很多参数和用法，具体可参考官网： https://docs.ansible.com/ansible/latest/collections/ansible/builtin/include_vars_module.html#ansible-collections-ansible-builtin-include-vars-module -e选项 ansible-playbook命令的-e选项或–extra-vars选项也可以用来定义变量或引入变量文件： # 定义单个变量 $ ansible-playbook -e 'var1=\"value1\"' xxx.yml # 定义多个变量 $ ansible-playbook -e 'var1=\"value1\" var2=\"value2\"' xxx.yml # 引入单个变量文件 $ ansible-playbook -e '@varfile1.yml' xxx.yml # 引入多个变量文件 $ ansible-playbook -e '@varfile1.yml' -e '@varfile2.yml' xxx.yml ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:10:3","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"使用role 上面将各类内容放在单独的文件中，然后使用相关指令或模块将其引入。ansible中，有一种更为规范的组织方式，即role。 使用role，即可无需手动使用这些指令或模块了。按照role指定的文件或目录存放对应的内容，ansible就会自动引入。 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:11:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"role的文件结构 ansible-galaxy init role1命令，可以快速创建一个role框架。 $ cd /etc/ansible/roles $ ansible-galaxy init role01 $ tree role01 role01 ├── defaults │ └── main.yml ├── files # 外部文件，放入此处的文件，在role的各种任务中直接无需使用全路径 ├── handlers │ └── main.yml # 存放handler ├── meta │ └── main.yml # 该role依赖的先行role。定义在此处的role将在该role运行前执行 ├── README.md ├── tasks │ └── main.yml # 存放任务 ├── templates # 模板文件，放入此处的文件，在role的各种任务中无需使用全路径 ├── tests │ ├── inventory │ └── test.yml └── vars └── main.yml # 存放变量 在相应目录及文件下编写对应内容，然后还需要提供一个入口playbook文件。在入口playbook文件中，使用import_roles、include_role、roles指令来引入role。最后使用ansible-playbook命令执行入口文件，即可执行定义在role中的各种任务了。 enter.yml文件如下： --- - name: enter for all roles hosts: node1 gather_facts: no roles: - role01 # 多个role可使用列表一起列出 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:11:1","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"编写一个role 定义role的变量 etc/ansible/roles/role01/vars/main.yml文件是role定义变量或引入变量文件的地方。 etc/ansible/roles/role01/defaults/main.yml文件是role定义默认变量的地方，优先级较低，当然也可以引入文件。 --- # vars file for role01 foo1: a: hello b: world 定义role的task /etc/ansible/roles/role01/tasks/main.yml文件是role定义task或者引入task文件的地方。 --- # tasks file for role01 - name: task1 debug: msg: \"{{ foo1.a }} {{ foo1.b }}\" notify: handler1 changed_when: true # 该指令使得chenged=1，触发notify 定义role的handler /etc/ansible/roles/role01/handles/main.yml文件是role定义handler或者引入handler文件的地方。 --- # handlers file for role01 - name: handler1 debug: msg: \"run handler1\" 执行： $ ansible-playbook enter.yml PLAY [enter for all roles] ********************************************************************************************************** TASK [role01 : task1] *************************************************************************************************************** changed: [node1] =\u003e {} MSG: hello world RUNNING HANDLER [role01 : handler1] ************************************************************************************************* ok: [node1] =\u003e {} MSG: run handler1 PLAY RECAP ************************************************************************************************************************** node1 : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:11:2","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"playbook的执行顺序 playbook从上往下执行各个play，在每个play内，从上往下执行各个task。 一个节点执行任务的顺序如下： 解析配置/etc/ansible/ansible.cfg 解析inventory gather_facts任务 pre_tasks任务 pre_tasks任务触发的handler roles指令加载的role task指令中的任务 roles和tasks触发的handler post_tasks指令中的任务 post_tasks中任务触发的handler 多个节点时，ansible在所有节点上执行完成前一个任务后，才进入下一个任务的执行流程。handlers是在所有节点上的所有任务执行完成后，开始执行。 从inventory中选择执行play的相关主机 连接到远程主机，通常使用ssh方式 拷贝相关模块到远程主机，并开始执行 ","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:12:0","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"理解委托任务 委托是指将原本在一个节点上执行的任务，委托给另一个节点执行。 要想理解委托，需要先了解ansible任务的执行过程：默认情况下，ansible先选择执行任务的主机，后连接该主机，再拷贝相关模块，并在该远程主机上执行模块。 但是在任务中进行了委托后，实际连接主机和执行模块动作将发生改变。比如将node1主机的任务委托给node2，ansible会根据hosts指令选择远程主机node1后，然后根据delegate_to指令，连接到node2节点，并将相关模块拷贝到node2并在node2上执行。 以下使用dalegate_to指令做个演示 test.yaml文件： --- - name: play1 hosts: node1 gather_facts: no tasks: - name: task1 shell: hostname delegate_to: node2 # 委托node2执行shell模块 执行ansible-playbook -vvv test.yaml，然后查看具体的执行日志。 再将delegate_to指令去除，执行ansible-playbook -vvv test.yaml命令查看不委托的执行过程，两者对比很容易发现ansible连接的主机为委托的主机。 $ ansible-playbook -vvv test.yaml 打印输出日志如下，也可在/var/log/ansible.log中查看。 ansible-playbook 2.9.25 config file = /etc/ansible/ansible.cfg configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python2.7/site-packages/ansible executable location = /usr/bin/ansible-playbook python version = 2.7.5 (default, Oct 14 2020, 14:45:30) [GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] Using /etc/ansible/ansible.cfg as config file host_list declined parsing /etc/ansible/hosts as it did not pass its verify_file() method script declined parsing /etc/ansible/hosts as it did not pass its verify_file() method auto declined parsing /etc/ansible/hosts as it did not pass its verify_file() method Parsed /etc/ansible/hosts inventory source with ini plugin Skipping callback 'actionable', as we already have a stdout callback. Skipping callback 'counter_enabled', as we already have a stdout callback. Skipping callback 'debug', as we already have a stdout callback. Skipping callback 'dense', as we already have a stdout callback. Skipping callback 'dense', as we already have a stdout callback. Skipping callback 'full_skip', as we already have a stdout callback. Skipping callback 'json', as we already have a stdout callback. Skipping callback 'minimal', as we already have a stdout callback. Skipping callback 'null', as we already have a stdout callback. Skipping callback 'oneline', as we already have a stdout callback. Skipping callback 'selective', as we already have a stdout callback. Skipping callback 'skippy', as we already have a stdout callback. Skipping callback 'stderr', as we already have a stdout callback. Skipping callback 'unixy', as we already have a stdout callback. Skipping callback 'yaml', as we already have a stdout callback. PLAYBOOK: test.yaml ***************************************************************************************************************** 1 plays in test.yaml PLAY [play1] ************************************************************************************************************************ META: ran handlers TASK [task1] ************************************************************************************************************************ task path: /etc/ansible/test.yaml:6 \u003cnode2\u003e ESTABLISH SSH CONNECTION FOR USER: None \u003cnode2\u003e SSH: EXEC ssh -C -o ControlMaster=auto -o ControlPersist=60s -o Port=22 -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/0d67807d8c node2 '/bin/sh -c '\"'\"'echo ~ \u0026\u0026 sleep 0'\"'\"'' \u003cnode2\u003e (0, '/root\\n', '') \u003cnode2\u003e ESTABLISH SSH CONNECTION FOR USER: None \u003cnode2\u003e SSH: EXEC ssh -C -o ControlMaster=auto -o ControlPersist=60s -o Port=22 -o KbdInteractiveAuthentication=no -o PreferredAuthentications=gssapi-with-mic,gssapi-keyex,hostbased,publickey -o PasswordAuthentication=no -o ConnectTimeout=10 -o ControlPath=/root/.ansible/cp/0d67807d8c node2 '/bin/sh -c '\"'\"'( umask 77 \u0026\u0026 mkdir -p \"` echo /root/.ansible/tmp `\"\u0026\u0026 mkdir \"` echo /root/.ansible/tmp/ansible-tmp-1642857067.57-71643-202799162287554 `\" \u0026\u0026 echo ansible-tmp-1642857067.57-71643-202799162287554=\"` echo /root/.ansible/tmp/ansible-tmp-1642857067.57-71643-202799162287554 `\" ) \u0026\u0026 sleep 0'\"'\"'' \u003cnode2\u003e (0, 'ansible-tmp-1642857067.57-71643-202799162287554=/root/.ansible/tmp/ans","date":"2022-04-22","objectID":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/:12:1","tags":["ansible"],"title":"ansible基础教程","uri":"/ansible%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"},{"categories":["工具"],"content":"批量免密登录 no_pass.sh:只需要运行脚本，输入目标端服务器用户名和密码即可。ip根据目标端网段修改。 #!/bin/bash read -p 'input user: ' USER echo \"$USER\" read -s -p 'input pass: ' PASS rm -f /root/.ssh/id_rsa (ssh-keygen -P \"\" -f /root/.ssh/id_rsa) \u0026\u003e/dev/null for i in {5..7} do IP_host=172.18.0.${i} ping -c 1 -w 1 ${IP_host} \u0026\u003e/dev/null if [ $? -eq 0 ];then (sshpass -p ${PASS} ssh-copy-id -o StrictHostKeyChecking=no ${IP_host}) \u0026\u003e/dev/null echo -e \"\\e[1;32m ${IP_host} ok \\e[0m\" fi done ","date":"2022-04-18","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/:1:0","tags":["shell"],"title":"shell脚本应用（长期更新）","uri":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"categories":["工具"],"content":"计算内存使用占比 vi memory_info.sh \u0026\u0026 chmod +x memory_info.sh #!/bin/bash MEM_TOTAL=`free -h |awk 'NR==2{print $2}'` MEM_USE=`free -h |awk 'NR==2{print $3}'` MEM_USED=`free | grep -i mem |awk '{print $3/$2*100\"%\"}'` MEM_FREE=`free -h |awk 'NR==2{print $4}'` MEM_FREED=`free | grep -i mem |awk '{print $4/$2*100\"%\"}'` MEM_BUFF_CACHE=`free -h |awk 'NR==2{print $6}'` MEM_BUFF_CACHED=`free | grep -i mem |awk '{print $6/$2*100 \"%\"}'` MEM_SHARE=`free -h |awk 'NR==2{print $5}'` MEM_SHARED=`free | grep -i mem |awk '{print $5/$2*100 \"%\"}'` MEM_ZONE=`head -3 /proc/meminfo | awk 'NR==1{t=$2}NR==2{f=$2;print(t-f)*100/t\"%\"}'` echo -e \"\\t\\e[1;32m内存总量: $MEM_TOTAL \\e[0m\" echo -e \"\\t\\e[1;32m内存总量减剩余内存(所有已使用)占比: $MEM_ZONE \\e[0m\" echo -e \"\\t\\e[1;32m已使用: $MEM_USE 占比: $MEM_USED \\e[0m\" echo -e \"\\t\\e[1;32m剩 余: $MEM_FREE 占比: $MEM_FREED \\e[0m\" echo -e \"\\t\\e[1;32m共 享: $MEM_SHARE 占比: $MEM_SHARED \\e[0m\" echo -e \"\\t\\e[1;32m缓冲区: $MEM_BUFF_CACHE 占比: $MEM_BUFF_CACHED \\e[0m\" 执行后的结果 root@ccb07fbb3515:~# ./memoryinfo.sh 内存总量: 1.8Gi 内存总量减剩余内存(所有已使用)占比: 93.9799% 已使用: 695Mi 占比: 38.0057% 剩 余: 110Mi 占比: 6.01987% 共 享: 157Mi 占比: 8.59889% 缓冲区: 1.0Gi 占比: 55.9744% ","date":"2022-04-18","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/:2:0","tags":["shell"],"title":"shell脚本应用（长期更新）","uri":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"categories":["工具"],"content":"巡检报告 system_check.sh巡检结果在当前用户log文件夹下 #!/bin/bash # @Author: localhost # @Date: 2021-03-16 09:56:57 # @Last Modified by: localhost # @Last Modified time: 2021-03-16 11:06:31 # @E-mail: localhost@163.com #!/bin/bash #主机信息每日巡检 IPADDR=$(ifconfig eth0|grep 'inet addr'|awk -F '[ :]' '{print $13}') #环境变量PATH没设好，在cron里执行时有很多命令会找不到 export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin source /etc/profile [ $(id -u) -gt 0 ] \u0026\u0026 echo \"请用root用户执行此脚本！\" \u0026\u0026 exit 1 centosVersion=$(awk '{print $(NF-1)}' /etc/redhat-release) VERSION=\"2020-03-16\" #日志相关 PROGPATH=`echo $0 | sed -e 's,[\\\\/][^\\\\/][^\\\\/]*$,,'` [ -f $PROGPATH ] \u0026\u0026 PROGPATH=\".\" LOGPATH=\"$PROGPATH/log\" [ -e $LOGPATH ] || mkdir $LOGPATH RESULTFILE=\"$LOGPATH/HostDailyCheck-$IPADDR-`date +%Y%m%d`.txt\" #定义报表的全局变量 report_DateTime=\"\" #日期 ok report_Hostname=\"\" #主机名 ok report_OSRelease=\"\" #发行版本 ok report_Kernel=\"\" #内核 ok report_Language=\"\" #语言/编码 ok report_LastReboot=\"\" #最近启动时间 ok report_Uptime=\"\" #运行时间（天） ok report_CPUs=\"\" #CPU数量 ok report_CPUType=\"\" #CPU类型 ok report_Arch=\"\" #CPU架构 ok report_MemTotal=\"\" #内存总容量(MB) ok report_MemFree=\"\" #内存剩余(MB) ok report_MemUsedPercent=\"\" #内存使用率% ok report_DiskTotal=\"\" #硬盘总容量(GB) ok report_DiskFree=\"\" #硬盘剩余(GB) ok report_DiskUsedPercent=\"\" #硬盘使用率% ok report_InodeTotal=\"\" #Inode总量 ok report_InodeFree=\"\" #Inode剩余 ok report_InodeUsedPercent=\"\" #Inode使用率 ok report_IP=\"\" #IP地址 ok report_MAC=\"\" #MAC地址 ok report_Gateway=\"\" #默认网关 ok report_DNS=\"\" #DNS ok report_Listen=\"\" #监听 ok report_Selinux=\"\" #Selinux ok report_Firewall=\"\" #防火墙 ok report_USERs=\"\" #用户 ok report_USEREmptyPassword=\"\" #空密码用户 ok report_USERTheSameUID=\"\" #相同ID的用户 ok report_PasswordExpiry=\"\" #密码过期（天） ok report_RootUser=\"\" #root用户 ok report_Sudoers=\"\" #sudo授权 ok report_SSHAuthorized=\"\" #SSH信任主机 ok report_SSHDProtocolVersion=\"\" #SSH协议版本 ok report_SSHDPermitRootLogin=\"\" #允许root远程登录 ok report_DefunctProsess=\"\" #僵尸进程数量 ok report_SelfInitiatedService=\"\" #自启动服务数量 ok report_SelfInitiatedProgram=\"\" #自启动程序数量 ok report_RuningService=\"\" #运行中服务数 ok report_Crontab=\"\" #计划任务数 ok report_Syslog=\"\" #日志服务 ok report_SNMP=\"\" #SNMP OK report_NTP=\"\" #NTP ok report_JDK=\"\" #JDK版本 ok function version(){ echo \"\" echo \"\" echo \"系统巡检脚本：Version $VERSION\" } function getCpuStatus(){ echo \"\" echo \"\" echo \"############################ CPU检查 #############################\" Physical_CPUs=$(grep \"physical id\" /proc/cpuinfo| sort | uniq | wc -l) Virt_CPUs=$(grep \"processor\" /proc/cpuinfo | wc -l) CPU_Kernels=$(grep \"cores\" /proc/cpuinfo|uniq| awk -F ': ' '{print $2}') CPU_Type=$(grep \"model name\" /proc/cpuinfo | awk -F ': ' '{print $2}' | sort | uniq) CPU_Arch=$(uname -m) echo \"物理CPU个数:$Physical_CPUs\" echo \"逻辑CPU个数:$Virt_CPUs\" echo \"每CPU核心数:$CPU_Kernels\" echo \" CPU型号:$CPU_Type\" echo \" CPU架构:$CPU_Arch\" #报表信息 report_CPUs=$Virt_CPUs #CPU数量 report_CPUType=$CPU_Type #CPU类型 report_Arch=$CPU_Arch #CPU架构 } function getMemStatus(){ echo \"\" echo \"\" echo \"############################ 内存检查 ############################\" if [[ $centosVersion \u003c 7 ]];then free -mo else free -h fi #报表信息 MemTotal=$(grep MemTotal /proc/meminfo| awk '{print $2}') #KB MemFree=$(grep MemFree /proc/meminfo| awk '{print $2}') #KB let MemUsed=MemTotal-MemFree MemPercent=$(awk \"BEGIN {if($MemTotal==0){printf 100}else{printf \\\"%.2f\\\",$MemUsed*100/$MemTotal}}\") report_MemTotal=\"$((MemTotal/1024))\"\"MB\" #内存总容量(MB) report_MemFree=\"$((MemFree/1024))\"\"MB\" #内存剩余(MB) report_MemUsedPercent=\"$(awk \"BEGIN {if($MemTotal==0){printf 100}else{printf \\\"%.2f\\\",$MemUsed*100/$MemTotal}}\")\"\"%\" #内存使用率% } function getDiskStatus(){ echo \"\" echo \"\" echo \"############################ 磁盘检查 ############################\" df -hiP | sed 's/Mounted on/Mounted/'\u003e /tmp/inode df -hTP | sed 's/Mounted on/Mounted/'\u003e /tmp/disk join /tmp/disk /tmp/inode | awk '{print $1,$2,\"|\",$3,$4,$5,$6,\"|\",$8,$9,$10,$11,\"|\",$12}'| column -t #报表信息 diskdata=$(df -TP | sed '1d' | awk '$2!=\"tmpfs\"{print}') #KB disktotal=$(echo \"$diskdata\" | awk '{total+=$3}END{print total}') #KB diskused=$(echo \"$diskdata\" | awk '{t","date":"2022-04-18","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/:3:0","tags":["shell"],"title":"shell脚本应用（长期更新）","uri":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"categories":["工具"],"content":"从一个文件夹中的所有文件加.tmp，转移到另一个目录下再去掉.tmp。 #! /bin/bash PRE_HOME=/iflytek/sl_export_pre EXP_HOME=/iflytek/sl_export function nameadd() { cd $PRE_HOME for filename in `ls *.*` do echo $filename | mv $filename $filename\".tmp\" done sleep 1 mv *.tmp $EXP_HOME } function namesub() { cd $EXP_HOME for filename in `ls *.tmp` do echo $filename | mv $filename `sed 's/.tmp//g'` done } nameadd sleep 1 namesub ","date":"2022-04-18","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/:3:1","tags":["shell"],"title":"shell脚本应用（长期更新）","uri":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"categories":["工具"],"content":"同时设置定时任务，定时执行。 15 8,10,12,15,17,19 * * * ","date":"2022-04-18","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/:3:2","tags":["shell"],"title":"shell脚本应用（长期更新）","uri":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"categories":["工具"],"content":"定时重启进程配合crontab 使用 #!/bin/bash #!/bin/sh date +'%Y-%m-%d %H:%M:%S' PID=`ps -ef | grep '/tmpdisk/siphole_back -c /etc/siphole/siphole_back_3.conf' | grep -v \"grep\" | awk '{print $2}'` kill -9 $PID /tmpdisk/siphole_back -c /etc/siphole/siphole_back_3.conf crontab 59 23 * * * /tmpdisk/restart_back3.sh \u003e\u003e /tmpdisk/restart_back.txt 是否执行成功会输出到日志/tmpdisk/restart_back.txt ","date":"2022-04-18","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/:3:3","tags":["shell"],"title":"shell脚本应用（长期更新）","uri":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"categories":["工具"],"content":"使用awk将两个单词位置互换 文本 # cat a.txt tian po 处理 awk '{temp=$1;$1=$2;$2=temp;print $0}' a.txt po tian ","date":"2022-04-18","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/:3:4","tags":["shell"],"title":"shell脚本应用（长期更新）","uri":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"categories":["工具"],"content":"取出文本中指定行指定位置的字段内容 文本如下 # cat a.txt root 4041836 4040563 0 09:23 pts/0 00:00:00 journalctl _PID=2726353 -f root 4041863 4040563 0 09:23 pts/0 00:00:00 journalctl _PID=3371956 -f 处理 awk 'NR==2 {print $2}' a.txt 4041863 分析 在 awk 命令中，NR 是一个内置变量，代表当前正在处理的行数。每次 awk 处理一行文本时，NR 的值都会增加 1。您可以使用 NR 来判断处理的是文件的第几行，并根据需要对特定行执行操作。如果当前行的行号（即 NR 的值）等于 2，则会打印指定的消息。 ","date":"2022-04-18","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/:3:5","tags":["shell"],"title":"shell脚本应用（长期更新）","uri":"/shell%E8%84%9A%E6%9C%AC%E5%BA%94%E7%94%A8%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0/"},{"categories":["工具"],"content":"需求 通过vpn直接访问内网容器ip可以直接登录，不再需要先登入公网IP再跳转到内网容器内部。 ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:1:0","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"访问示意图 互联网（openvpn client）--\u003e（公网ip）服务器（私网ip:172.18.0.10）--\u003e服务器端容器（内网172.18.0.8） ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:1:1","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"openvpn服务端配置 ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:2:0","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"拉取镜像 docker pull kylemanna/openvpn ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:2:1","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"创建映射目录 mkdir -pv /data/openvpn/conf ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:2:2","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"生成配置文件 docker run -v /data/openvpn:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u udp://10.10.10.10 ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:2:3","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"生成密钥文件 要求输入私钥密码 docker run -v /data/openvpn:/etc/openvpn --rm -it kylemanna/openvpn ovpn_initpki Enter PEM pass phrase: 098poilkj. # 输入私钥密码 Verifying - Enter PEM pass phrase: 098poilkj. # 重新输入一次密码 Common Name (eg: your user,host,or server name) [Easy-RSA CA]: # 输入一个CA名称。可以不用输入，直接回车 Enter pass phrase for /etc/openvpn/pki/private/ca.key: 123456 # 输入刚才设置的私钥密码，完成后在输入一次 ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:2:4","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"生成客户端证书 test1改成其他名字 docker run -v /data/openvpn:/etc/openvpn --rm -it kylemanna/openvpn easyrsa build-client-full test1 nopass Enter pass phrase for /etc/openvpn/pki/private/ca.key: 098poilkj. # 输入刚才设置的密码 ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:2:5","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"导出客户端配置 docker run -v /data/openvpn:/etc/openvpn --rm kylemanna/openvpn ovpn_getclient test1 \u003e /data/openvpn/conf/test1.ovpn ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:2:6","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"启动openvpn docker run --name openvpn -v /data/openvpn:/etc/openvpn -d -p 1194:1194/udp --cap-add=NET_ADMIN kylemanna/openvpn ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:2:7","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"openvpn用户管理 ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:3:0","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"添加用户脚本 vim add_user.sh #!/bin/bash read -p \"please your username: \" NAME docker run -v /data/openvpn:/etc/openvpn --rm -it kylemanna/openvpn easyrsa build-client-full $NAME nopass docker run -v /data/openvpn:/etc/openvpn --rm kylemanna/openvpn ovpn_getclient $NAME \u003e /data/openvpn/conf/\"$NAME\".ovpn docker restart openvpn ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:3:1","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"删除用户脚本 vim del_user.sh #!/bin/bash read -p \"Delete username: \" DNAME docker run -v /data/openvpn:/etc/openvpn --rm -it kylemanna/openvpn easyrsa revoke $DNAME docker run -v /data/openvpn:/etc/openvpn --rm -it kylemanna/openvpn easyrsa gen-crl docker run -v /data/openvpn:/etc/openvpn --rm -it kylemanna/openvpn rm -f /etc/openvpn/pki/reqs/\"DNAME\".req docker run -v /data/openvpn:/etc/openvpn --rm -it kylemanna/openvpn rm -f /etc/openvpn/pki/private/\"DNAME\".key docker run -v /data/openvpn:/etc/openvpn --rm -it kylemanna/openvpn rm -f /etc/openvpn/pki/issued/\"DNAME\".crt docker restart openvpn ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:3:2","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"添加用户 ./add_user.sh # 输入要添加的用户名，回车后输入刚才创建的私钥密码 创建的证书在/data/openvpn/conf目录下。 ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:3:3","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"openvpn客户端配置 官网下载客户端 从服务端把证书拷贝到桌面上，并将证书test1.ovpn直接导入到客户端内。然后输入容器内部IP就可以直接访问docker内部容器了。 ","date":"2022-04-17","objectID":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/:4:0","tags":["openvpn"],"title":"使用docker搭建openvpn","uri":"/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAopenvpn/"},{"categories":["工具"],"content":"ansible模块官方手册 模块 ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:1:0","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"模块筛选 $ ansible-doc -l | grep 'copy' vsphere_copy Copy a file to a VMware datastore win_copy Copies files to remote locations on windows hosts bigip_file_copy Manage files in datastores on a BIG-IP ec2_ami_copy copies AMI between AWS regions, return new image id win_robocopy Synchronizes the contents of two directories using Robocopy copy Copy files to remote locations na_ontap_lun_copy NetApp ONTAP copy LUNs icx_copy Transfer files from or to remote Ruckus ICX 7000 series switches unarchive Unpacks an archive after (optionally) copying it from the local machine postgresql_copy Copy data between a file/program and a PostgreSQL table ec2_snapshot_copy copies an EC2 snapshot and returns the new Snapshot ID nxos_file_copy Copy a file to a remote NXOS device netapp_e_volume_copy NetApp E-Series create volume copy pairs 详细的模块描述手册 ansible-doc copy 只包含模块参数用法的模块描述手册 ansible-doc -s copy ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:1:1","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"连接行为变量 官网链接 常见的解释 Inventory变量名 含义 ansible_host ansible连接节点时的IP地址 ansible_port 连接对方的端口号，ssh连接时默认为22 ansible_user 连接对方主机时使用的主机名。不指定时，将使用执行ansible或ansible-playbook命令的用户 ansible_password 连接时的用户密码 ansible_connection 连接类型，有效值包括smart、ssh、paramiko、local、docker、winrm，默认为smart。smart表示智能选择ssh和paramiko，当SSH支持ControlPersist(即持久连接)时使用ssh，否则使用paramiko。local和docker是非基于ssh连接的方式，winrm是连接windows的插件 ansible_ssh_private_key_file 指定密钥认证ssh连接时的私钥文件 ansible_ssh_common_args 提供给ssh、sftp、scp命令的额外参数 ansible_become 允许进行权限提升 ansible_become_method 指定提升权限的方式，例如可使用sudo/su/runas等方式 ansible_become_user 提升为哪个用户的权限，默认提升为root ansible_become_password 提升为指定用户权限时的密码 ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:1:2","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"yaml与json格式转换 链接 也可以用yq将yaml转换成json 格式。 ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:1:3","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"ansible关于lookup的插件 参考 ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:1:4","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"ansible支持的magic variables 官网 ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:1:5","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"sh模式下没有ip ifconfig 命令如何看IP？ hostname -I | awk ‘{print $1}’ ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:1:6","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"没有telnet 工具如何测试端口？ (echo \u003e/dev/tcp/172.18.0.1/6666) \u0026\u003e/dev/null \u0026\u0026 echo \"open\" || echo \"closed\" 开放 open 未开放 closed ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:1:7","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"ansible告警 [WARNING]: Platform linux on host node3 is using the discovered Python interpreter at /usr/bin/python3.7, but future installation of another Python interpreter could change this. See https://docs.ansible.com/ansible/2.9/reference_appendices/interpreter_discovery.html for more information. ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:2:0","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"处理方式 关闭告警 vim /etc/ansible/ansible.cfg [defaults] interpreter_python=auto_silent ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:2:1","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"debain ansible所有版本 https://packages.debian.org/buster-backports/all/ansible/download ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:3:0","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"ansible rpm包所有版本 https://releases.ansible.com/ansible/rpm/release/epel-7-x86_64/ ","date":"2022-04-15","objectID":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/:4:0","tags":["ansible"],"title":"ansible相关参考资料","uri":"/ansible%E7%9B%B8%E5%85%B3%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"},{"categories":["工具"],"content":"查看docker镜像的dockerfile 将\u003cIMAGE ID\u003e替换为待查看Dockerfile的镜像ID。 docker history \u003cIMAGE ID\u003e --format \"{{.CreatedBy}}\" --no-trunc |tac | awk '{if($3~/nop/){for(i=1;i\u003c=3;i++){$i=\"\"};print substr($0,4)}else{print \"RUN\",$0}}' 对比 [root@localhost ~]# docker history f1396d3fa7b5 --format \"{{.CreatedBy}}\" --no-trunc |tac | awk '{if($3~/nop/){for(i=1;i\u003c=3;i++){$i=\"\"};print substr($0,4)}else{print \"RUN\",$0}}' ADD file:be998d04a8927e9c4b105995e3b9d6800ea798807389f7c5921c0f4774328e21 in / CMD [\"bash\"] COPY file:d3994e70cf156a17b1ad3dae5c75ed40c6d5c73a0d1b4c6b94620f1cd76b0943 in /etc/apt/sources.list RUN /bin/sh -c apt update;apt install -y vim net-tools procps openssh-server python3.7 RUN /bin/sh -c sed -i 's/^#PermitRootLogin.*/PermitRootLogin yes/g' /etc/ssh/sshd_config;cp /usr/bin/python3.7 /usr/bin/python CMD [\"/bin/bash\"] 原Dockerfile FROM debian:10 COPY sources.list /etc/apt/sources.list RUN apt update;apt install -y vim net-tools procps openssh-server python3.7 RUN sed -i 's/^#PermitRootLogin.*/PermitRootLogin yes/g' /etc/ssh/sshd_config;cp /usr/bin/python3.7 /usr/bin/python CMD [\"/bin/bash\"] ","date":"2022-04-15","objectID":"/docker%E5%86%B7%E9%97%A8%E6%8A%80%E5%B7%A7/:1:0","tags":["docker技巧"],"title":"docker冷门技巧","uri":"/docker%E5%86%B7%E9%97%A8%E6%8A%80%E5%B7%A7/"},{"categories":["工具"],"content":"创建容器时指定主机名 加--hostname参数，--network指定网络。 docker run --name aa --hostname kafka_node -p 2181:2181 -v /home/htht/kafka/logs:/home/kafka/logs -v /home/htht/kafka/k-datas:/home/kafka/k-datas --network=my_net1 --ip 172.18.0.3 kafka:0.1 ","date":"2022-04-15","objectID":"/docker%E5%86%B7%E9%97%A8%E6%8A%80%E5%B7%A7/:2:0","tags":["docker技巧"],"title":"docker冷门技巧","uri":"/docker%E5%86%B7%E9%97%A8%E6%8A%80%E5%B7%A7/"},{"categories":["工具"],"content":"全文件压缩与解压 ","date":"2022-04-14","objectID":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/:1:0","tags":["tar"],"title":"压缩与解压缩","uri":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"},{"categories":["工具"],"content":"压缩 tar -zcvf 文件名.tgz 源文件 ","date":"2022-04-14","objectID":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/:1:1","tags":["tar"],"title":"压缩与解压缩","uri":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"},{"categories":["工具"],"content":"解压 先创建解压目录 mkdir -p /root/a 再将文件指定压缩到该目录内 tar -zxvf 文件名.tgz -C /root/a ","date":"2022-04-14","objectID":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/:1:2","tags":["tar"],"title":"压缩与解压缩","uri":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"},{"categories":["工具"],"content":"排除日志文件的压缩与解压 ","date":"2022-04-14","objectID":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/:2:0","tags":["tar"],"title":"压缩与解压缩","uri":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"},{"categories":["工具"],"content":"压缩 注意--exclude=参数要放到打包目录之前。 排除xxx/logs文件，其余都压缩。 tar -zcvf xxx.tgz --exclude=xxx/logs xxx 例如：打包/var/log/*下所有文件除了/var/log/landscape文件夹之外。 tar -zcvf exclude-log.tgz --exclude=/var/log/landscape /var/log/* ","date":"2022-04-14","objectID":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/:2:1","tags":["tar"],"title":"压缩与解压缩","uri":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"},{"categories":["工具"],"content":"解压到指定文件夹 tar -zxvf 文件名.tgz -C /root/a ","date":"2022-04-14","objectID":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/:2:2","tags":["tar"],"title":"压缩与解压缩","uri":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"},{"categories":["工具"],"content":"同时压缩多个文件夹 多个路径用空格隔开 tar -zcvf myfile.tgz /etc/adduser.conf /var/log/docker.log 解压到指定文件夹内（该文件夹必须存在！） tar -zxvf myfile.tgz -C /root/a ","date":"2022-04-14","objectID":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/:3:0","tags":["tar"],"title":"压缩与解压缩","uri":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"},{"categories":["工具"],"content":"只显示压缩内容不解压 tar -tvf myfile.tgz 或者 vim myfile.tgz ","date":"2022-04-14","objectID":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/:4:0","tags":["tar"],"title":"压缩与解压缩","uri":"/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E8%A7%A3%E5%8E%8B/"},{"categories":["编程"],"content":"模拟ssh执行远程命令 ","date":"2022-04-12","objectID":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:1:0","tags":["python"],"title":"模拟ssh执行远程命令","uri":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"服务端 from socket import * import subprocess server = socket(AF_INET, SOCK_STREAM) server.bind(('127.0.0.1', 8090)) server.listen(5) while True: conn, client_addr = server.accept() print(client_addr) while True: try: cmd = conn.recv(1024) if not cmd:break obj = subprocess.Popen(cmd.decode('utf-8'), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE ) stdout = obj.stdout.read() stderr = obj.stderr.read() cmd_res = stdout+stderr print(len(cmd_res)) conn.send(cmd_res) except ConnectionResetError: break conn.close() server.close() ","date":"2022-04-12","objectID":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:1:1","tags":["python"],"title":"模拟ssh执行远程命令","uri":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"客户端 from socket import * client = socket(AF_INET, SOCK_STREAM) client.connect(('127.0.0.1', 8090)) while True: cmd = input('\u003e\u003e: ').strip() if not cmd:continue client.send(cmd.encode('utf-8')) data = client.recv(1024) print(data.decode('gbk')) #环境时windows收包后要转成gbk格式。 client.close() ","date":"2022-04-12","objectID":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:1:2","tags":["python"],"title":"模拟ssh执行远程命令","uri":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"粘包现象 ","date":"2022-04-12","objectID":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:0","tags":["python"],"title":"模拟ssh执行远程命令","uri":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"什么是粘包？ 须知：只有TCP有粘包现象，UDP永远不会粘包。 首先需要掌握一个socket收发消息的原理 发送端可以是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据，也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），一条消息有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议，这也是容易出现粘包问题的原因。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。 怎样定义消息呢？可以认为对方一次性write/send的数据为一个消息，需要明白的是当对方send一条信息的时候，无论底层怎样分段分片，TCP协议层会把构成整条消息的数据段排序完成后才呈现在内核缓冲区。 例如基于TCP的套接字客户端往服务端上传文件，发送时文件内容是按照一段一段的字节流发送的，在接收方看了，根本不知道该文件的字节流从何处开始，在何处结束。 所谓粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的。 此外，发送方引起的粘包是由TCP协议本身造成的，TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一个TCP段。若连续几次需要send的数据都很少，通常TCP会根据优化算法把这些数据合成一个TCP段后一次发送出去，这样接收方就收到了粘包数据。 ","date":"2022-04-12","objectID":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:1","tags":["python"],"title":"模拟ssh执行远程命令","uri":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"TCP与UDP TCP（transport control protocol，传输控制协议）是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发往接收端的包，更有效的发到对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样，接收端，就难于分辨出来了，必须提供科学的拆包机制。 即面向流的通信是无消息保护边界的。 UDP（user datagram protocol，用户数据报协议）是无连接的，面向消息的，提供高效率服务。不会使用块的合并优化算法，, 由于UDP支持的是一对多的模式，所以接收端的skbuff(套接字缓冲区）采用了链式结构来记录每一个到达的UDP包，在每个UDP包中就有了消息头（消息来源地址，端口等信息），这样，对于接收端来说，就容易进行区分处理了。 即面向消息的通信是有消息保护边界的。 tcp是基于数据流的，于是收发的消息不能为空，这就需要在客户端和服务端都添加空消息的处理机制，防止程序卡住，而udp是基于数据报的，即便是你输入的是空内容（直接回车），那也不是空消息，udp协议会帮你封装上消息头。 udp的recvfrom是阻塞的，一个recvfrom(x)必须对唯一一个sendinto(y),收完了x个字节的数据就算完成,若是y\u003ex数据就丢失，这意味着udp根本不会粘包，但是会丢数据，不可靠。 TCP的协议数据不会丢，没有收完包，下次接收，会继续上次继续接收，己端总是在收到ack时才会清除缓冲区内容。数据是可靠的，但是会粘包。 ","date":"2022-04-12","objectID":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:2","tags":["python"],"title":"模拟ssh执行远程命令","uri":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"两种情况下会发生粘包 发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包） 运行上面的服务端和客户端代码看TCP粘包现象。 结果： #服务端 ('127.0.0.1', 3221) 21944 #一共21944个字节数据，只收了1024个字节数据。剩下的就会粘包。 393 393 #客户端 执行tasklist 相当于打印windows的任务管理器,然后再执行dir查看有哪些文件。 \u003e\u003e: tasklist 映像名称 PID 会话名 会话# 内存使用 ========================= ======== ================ =========== ============ System Idle Process 0 Services 0 8 K System 4 Services 0 144 K Secure System 88 Services 0 73,304 K Registry 156 Services 0 93,616 K smss.exe 528 Services 0 1,256 K csrss.exe 880 Services 0 5,200 K wininit.exe 980 Services 0 6,700 K csrss.exe 988 Console 1 7,392 K services.exe 784 Services 0 12,104 K LsaIso.exe 816 Services 0 3,352 K lsass.exe 808 Services 0 24,360 K winlogon \u003e\u003e: dir .exe 1064 Console 1 13,052 K svchost.exe 1192 Services 0 35,916 K fontdrvhost.exe 1228 Console 1 14,864 K fontdrvhost.exe 1236 Services 0 4,444 K WUDFHost.exe 1244 Services 0 18,332 K svchost.exe 1360 Services 0 18,016 K svchost.exe 1408 Services 0 9,484 K dwm.exe 1512 Console 1 154,792 K svchost.exe 1644 Services 0 9,572 K svchost.exe 1656 Services 0 13,208 K svchost.exe 1664 Services 0 14,728 K svchost.exe 1680 Services 0 11,348 K svchost.exe 1708 Services 0 5,540 K svchost.exe 发现dir显示的不是当前目录下的内容，仿佛是上一次执行tasklist后内容没显示全。 接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） 。 ","date":"2022-04-12","objectID":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:3","tags":["python"],"title":"模拟ssh执行远程命令","uri":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["编程"],"content":"拆包的发生情况 当发送端缓冲区的长度大于网卡的MTU时，TCP会将这次发送的数据拆成几个数据包发送出去。 补充问题一：为何TCP是可靠传输，UDP是不可靠传输 TCP在数据传输时，发送端先把数据发送到自己的缓存中，然后协议控制将缓存中的数据发往对端，对端返回一个ack=1，发送端则清理缓存中的数据，对端返回ack=0，则重新发送数据，所以TCP是可靠的。 而udp发送数据，对端是不会返回确认信息的，因此不可靠。 补充问题二：send(字节流)和recv(1024)及sendall recv里指定的1024意思是从缓存里一次拿出1024个字节的数据 send的字节流是先放入己端缓存，然后由协议控制将缓存内容发往对端，如果待发送的字节流大小大于缓存剩余空间，那么数据丢失，用sendall就会循环调用send，数据不会丢失。 ","date":"2022-04-12","objectID":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/:2:4","tags":["python"],"title":"模拟ssh执行远程命令","uri":"/%E6%A8%A1%E6%8B%9Fssh%E6%89%A7%E8%A1%8C%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4/"},{"categories":["工具"],"content":"应用场景 Ansible是一个基于Python开发的配置管理和应用部署工具，现在也在自动化管理领域大放异彩。它融合了众多老牌运维工具的优点，Pubbet和Saltstack能实现的功能，Ansible基本上都可以实现。 Ansible能批量配置、部署、管理一大堆的主机。比如以前需要切换到每个主机上执行的一或多个操作，使用Ansible只需在固定的一台Ansible控制节点上去完成所有主机的操作。 ","date":"2022-04-12","objectID":"/ansible/:1:0","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"ansible主控端搭建 ","date":"2022-04-12","objectID":"/ansible/:2:0","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"基于docker构建一个ansible镜像 编写Dockerfile FROM debian:10 COPY sources.list /etc/apt/sources.list RUN apt update;apt install -y ansible sshpass vim net-tools procps RUN sed -i 's/^#host_key_checking.*/host_key_checking = False/g' /etc/ansible/ansible.cfg CMD [\"/bin/bash\"] 说明：基于debain10搭建的基础ansible镜像包。 创建sources.list文件 cat \u003c\u003cEOF \u003e sources.list deb http://mirrors.ustc.edu.cn/debian/ buster main deb-src http://mirrors.ustc.edu.cn/debian/ buster main deb http://mirrors.ustc.edu.cn/debian-security buster/updates main deb-src http://mirrors.ustc.edu.cn/debian-security buster/updates main # buster-updates, previously known as 'volatile' deb http://mirrors.ustc.edu.cn/debian/ buster-updates main deb-src http://mirrors.ustc.edu.cn/debian/ buster-updates main deb http://mirrors.ustc.edu.cn/debian/ buster-backports main non-free contrib deb-src http://mirrors.ustc.edu.cn/debian/ buster-backports main non-free contrib EOF 注意：sources.list是一个源配置文件，和Dockerfile文件在同一级。 FROM 意思就是使用哪个基础镜像 COPY 就是复制本地的哪个文件到容器镜像 RUN 就是执行一个Linux命令 CMD 就是设置容器启动的时候需要运行什么程序 开始构建 语法 docker build -t ${镜像名称:版本} . 例如 docker build -t debian10/ansible . 当不设置版本的时候，默认会给予latest的一个版本标签。 注意构建过程中报错信息，根据报错信息更改Dockerfile文件内容。 验证镜像 [root@localhost ~]# docker images | grep ansible debain10/ansible latest 03216dab3d76 23 minutes ago 349MB ","date":"2022-04-12","objectID":"/ansible/:2:1","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"主控端容器创建 docker run -it --name ansible-control --privilaged=true -d debain10/ansible sh 查看容器是否正常启动 docker ps ccb07fbb3515 debain10/ansible \"sh\" 25 minutes ago Up 25 minutes ansible-control 进入容器 docker exec -it ansible-control bash 查看ansible版本 root@ccb07fbb3515:/etc/ansible# ansible --version ansible 2.7.7 config file = /etc/ansible/ansible.cfg configured module search path = ['/root/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python3/dist-packages/ansible executable location = /usr/bin/ansible python version = 3.7.3 (default, Jan 22 2021, 20:04:44) [GCC 8.3.0] ","date":"2022-04-12","objectID":"/ansible/:2:2","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"ansible被控节点搭建 ","date":"2022-04-12","objectID":"/ansible/:3:0","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"使用Dockerfile创建被控节点镜像 Dockerfile文件内容如下： FROM debian:10 COPY sources.list /etc/apt/sources.list RUN apt update;apt install -y vim net-tools procps openssh-server python3.7 RUN sed -i 's/^#PermitRootLogin.*/PermitRootLogin yes/g' /etc/ssh/sshd_config;cp /usr/bin/python3.7 /usr/bin/python CMD [\"/bin/bash\"] 这里有一个坑，被控节点中必须安装python，ansible默认会去/usr/bin内找python执行文件。如果没有就会报错。这里安装镜像时就默认安装了python3.7。并将执行文件复制为/usr/bin/python。 当然openssh-server是必备的，ansible就是基于ssh服务控制服务器的。 ","date":"2022-04-12","objectID":"/ansible/:3:1","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"创建sources.list文件(同主控端) ","date":"2022-04-12","objectID":"/ansible/:3:2","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"开始构建 docker build -t debian10/ansible-node . ","date":"2022-04-12","objectID":"/ansible/:3:3","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"创建3个被控端容器 docker run -it --name ansible-node1 --privilaged=true -d debain10/ansible init docker run -it --name ansible-node2 --privilaged=true -d debain10/ansible init docker run -it --name ansible-node3 --privilaged=true -d debain10/ansible init ","date":"2022-04-12","objectID":"/ansible/:3:4","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"分别进入容器并修改root密码 #密码统一修改为123456 echo \"123456\" | passwd --stdin root #debain10试了下不生效 #使用以下命令更改 passwd root 123456 最后可以看到一个主控端和3个被控端容器。 e8e005edfab9 debain/ansible-node \"init\" About an hour ago Up About an hour ansible-node3 cd03436b2424 debain/ansible-node \"init\" About an hour ago Up About an hour ansible-node2 88bf589578f5 debain/ansible-node \"init\" About an hour ago Up About an hour ansible-node1 ccb07fbb3515 debain10/ansible \"sh\" About an hour ago Up About an hour ansible-control ","date":"2022-04-12","objectID":"/ansible/:3:5","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"在控制端添加所有被控端主机信息 有两种方法 ","date":"2022-04-12","objectID":"/ansible/:4:0","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"一种明文方式(不安全) 在/etc/ansible/hosts文件添加下面的内容（覆盖） node1 ansible_ssh_host=172.18.0.5 ansible_ssh_port=22 ansible_ssh_pass=1 node2 ansible_ssh_host=172.18.0.6 ansible_ssh_port=22 ansible_ssh_pass=1 node3 ansible_ssh_host=172.18.0.7 ansible_ssh_port=22 ansible_ssh_pass=1 [hello] node1 node2 node3 ","date":"2022-04-12","objectID":"/ansible/:4:1","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"另一种密文方式（推荐） 使用openssl生成随机密码 openssl rand -out vault_password_file -base64 128 #cat vault_password_file eBqrIFYQ7XDJKjTywZwc26KElu1NQwwx5su3pzj21c4H33RQUV4kslL+UHVEJzxN sYIEbklwL7la+sugcSoK5PutqZ79bXnvT7FkEk2pMFNUO4W13/R3pH1AFAddAvsC h+YG1mxTCUsNbCwgtngCkAe9cBcLbkbLMVxjQ+dZym4= #最小化权限并上锁。 chmod a-w vault_password_file chattr +i vault_password_file 删除文件前先解锁 chattr -i vault_password_file 关于openssl补充： openssl生成随机数 openssl rand [-out file] [-rand file(s)] [-base64] [-hex] num 常用选项有： -out file：将生成的随机数保存至指定文件中 -base64：使用base64 编码格式 -hex：使用16进制编码格式 使用ansible-vault生成加密后的字符串 root@ccb07fbb3515:~# ansible-vault encrypt_string \"123456\" -name ansible_ssh_pass The number of --name options do not match the number of args. The last named variable will be \"ame\". The rest will not have names. # The encrypted version of variable (\"ame\", the string #1 from the command line args). ame: !vault | $ANSIBLE_VAULT;1.1;AES256 35643865643061373962376261653765333233333839353937643134643437396262646338363965 3366666561653365663164386536363963353961313362350a626662366361303434383665306531 34386161363965363634626663343832363664623139336665313131623732343437633439386264 6534663962663337640a363166383137613835383966396431326165663732646337653235646239 3534 # The encrypted version of the string #2 from the command line args.) !vault | $ANSIBLE_VAULT;1.1;AES256 34306239353764383165316133636366633131366332326362323830613638633263353638656562 3736396133633063623863623739326132383062373533300a613036646534353033363134383532 66333366633537643737333065313866396137663965393530653262616132633236663561336164 3633393361616162340a343931653762613765366339356632366135326464336532313562643432 38386533653231626365303837653831346263646464633430643765396239366334 Encryption successful 最后修改主机文件/etc/ansible/hosts配置(使用yaml风格) --- all: hosts: node1: ansible_host: 172.18.0.5 ansible_ssh_port: 22 ansible_ssh_pass: !vault | $ANSIBLE_VAULT;1.1;AES256 35643865643061373962376261653765333233333839353937643134643437396262646338363965 3366666561653365663164386536363963353961313362350a626662366361303434383665306531 34386161363965363634626663343832363664623139336665313131623732343437633439386264 6534663962663337640a363166383137613835383966396431326165663732646337653235646239 3534 node2: ansible_host: 172.18.0.6 ansible_ssh_port: 22 ansible_ssh_pass: !vault | $ANSIBLE_VAULT;1.1;AES256 35643865643061373962376261653765333233333839353937643134643437396262646338363965 3366666561653365663164386536363963353961313362350a626662366361303434383665306531 34386161363965363634626663343832363664623139336665313131623732343437633439386264 6534663962663337640a363166383137613835383966396431326165663732646337653235646239 3534 node3: ansible_host: 172.18.0.7 ansible_ssh_port: 22 ansible_ssh_pass: !vault | $ANSIBLE_VAULT;1.1;AES256 35643865643061373962376261653765333233333839353937643134643437396262646338363965 3366666561653365663164386536363963353961313362350a626662366361303434383665306531 34386161363965363634626663343832363664623139336665313131623732343437633439386264 6534663962663337640a363166383137613835383966396431326165663732646337653235646239 3534 ... yaml格式参考官网 这里的ssh端口还有另一种写法 ansible_port: 22 测试 root@ccb07fbb3515:/etc/ansible# ansible all -m ping node1 | SUCCESS =\u003e { \"changed\": false, \"ping\": \"pong\" } node3 | SUCCESS =\u003e { \"changed\": false, \"ping\": \"pong\" } node2 | SUCCESS =\u003e { \"changed\": false, \"ping\": \"pong\" } 重启其中一个主机的服务 root@ccb07fbb3515:/etc/ansible# ansible node1 -m command -a \"systemctl restart cron\" node1 | CHANGED | rc=0 \u003e\u003e 查看所有主机的内核版本 ansible all -m command -a \"uname -a\" node1 | CHANGED | rc=0 \u003e\u003e Linux cd03436b2424 4.18.0-147.5.1.el8_1.x86_64 #1 SMP Wed Feb 5 02:00:39 UTC 2020 x86_64 GNU/Linux node2 | CHANGED | rc=0 \u003e\u003e Linux e8e005edfab9 4.18.0-147.5.1.el8_1.x86_64 #1 SMP Wed Feb 5 02:00:39 UTC 2020 x86_64 GNU/Linux node3 | CHANGED | rc=0 \u003e\u003e Linux 88bf589578f5 4.18.0-147.5.1.el8_1.x86_64 #1 SMP Wed Feb 5 02:00:39 UTC 2020 x86_64 GNU/Linux ","date":"2022-04-12","objectID":"/ansible/:4:2","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"最后还可以免密登录 主控端使用ssh-keygen生成公钥和私钥，通过sshpass传递到被控端。输入被控端用户名和密码。 #!/bin/bash read -p 'input user: ' USER echo \"$USER\" read -s -p 'input pass: ' PASS rm -f /root/.ssh/id_rsa (ssh-keygen -P \"\" -f /root/.ssh/id_rsa) \u0026\u003e/dev/null for i in {5..7} do IP_host=172.18.0.${i} ping -c 1 -w 1 ${IP_host} \u0026\u003e/dev/null if [ $? -eq 0 ];then (sshpass -p ${PASS} ssh-copy-id -o StrictHostKeyChecking=no ${IP_host}) \u0026\u003e/dev/null echo -e \"\\e[1;32m ${IP_host} ok \\e[0m\" fi done 然后ansible的配置文件hosts里可以不写密码了。 --- web: #组名1 hosts: node1: #被控主机1 ansible_host: 172.18.0.5 ansible_ssh_port: 22 node2: #被控主机2 ansible_host: 172.18.0.6 ansible_ssh_port: 22 apache: #组名2 hosts: node3: #被控主机3 ansible_host: 172.18.0.7 ansible_ssh_port: 22 node4: #被控主机4 ansible_host: 172.18.0.8 ansible_ssh_port: 22 ... ","date":"2022-04-12","objectID":"/ansible/:4:3","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"Ansible参数补全功能 从Ansible 2.9版本开始，ansible支持命令的选项补全功能，它依赖于python的argcomplete插件 aptitude install python-argcomplete -y #安装 activate-global-python-argcomplete #激活 激活后，就可以按两次tab补全命令和选项了。 ","date":"2022-04-12","objectID":"/ansible/:5:0","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"ansible升级到特定版本 ","date":"2022-04-12","objectID":"/ansible/:6:0","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"卸载 查看当前版本 ansible --version ansible 2.7.7 安装debain包管理器aptitude,它可以自动解决包依赖问题。 apt install aptitude -y 卸载旧版本的ansible aptitude remove ansible* 查看ansible依赖包是否没卸载干净 apt list | grep ansible* ","date":"2022-04-12","objectID":"/ansible/:6:1","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"安装新版本 debain 系统下ansible所有版本 https://packages.debian.org/buster-backports/all/ansible/download 本次下载2.9.16版本的安装包进行升级 wget http://ftp.cn.debian.org/debian/pool/main/a/ansible/ansible_2.9.16+dfsg-1~bpo10+2_all.deb 安装 aptitude install ansible_2.9.16+dfsg-1~bpo10+2_all.deb 最新版支持python3，可以下载。 aptitude install python3 ","date":"2022-04-12","objectID":"/ansible/:6:2","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"查询 ansible --version ansible 2.9.16 config file = /etc/ansible/ansible.cfg configured module search path = ['/root/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python3/dist-packages/ansible executable location = /usr/bin/ansible python version = 3.7.3 (default, Jan 22 2021, 20:04:44) [GCC 8.3.0] ","date":"2022-04-12","objectID":"/ansible/:6:3","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"其他 ","date":"2022-04-12","objectID":"/ansible/:7:0","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["工具"],"content":"关于debain10系统鼠标右键粘连的解决方法 编辑 vim 的默认配置文件 vi /usr/share/vim/vim81/defaults.vim #第79行 if has('mouse') set mouse=a endif #set mouse=a 改为set mouse-=a 保存退出 ","date":"2022-04-12","objectID":"/ansible/:7:1","tags":["ansible"],"title":"ansible基本环境搭建及升级版本","uri":"/ansible/"},{"categories":["编程"],"content":"简单套接字通信 ","date":"2022-04-11","objectID":"/%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E7%AE%80%E5%8D%95%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/:1:0","tags":["python"],"title":"基于tcp的简单套接字通信","uri":"/%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E7%AE%80%E5%8D%95%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"categories":["编程"],"content":"服务端 import socket #买手机 phone = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #tcp协议 #绑定手机 # phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) phone.bind(('127.0.0.1', 9000)) #0-65535 #开机 phone.listen(5) #等待电话连接 print('staring....') conn, client_addr=phone.accept() #(conn,client_addr) .accept()会阻塞，等待建立连接。 print(conn, client_addr) #收、发消息 data = conn.recv(1024) #1024bytes? .recv()也会阻塞。等着接收数据。 conn.send(data.upper()) #.send()不会阻塞，只是发给缓存就结束了。 #挂电话连接 conn.close() #关机 phone.close() ","date":"2022-04-11","objectID":"/%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E7%AE%80%E5%8D%95%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/:1:1","tags":["python"],"title":"基于tcp的简单套接字通信","uri":"/%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E7%AE%80%E5%8D%95%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"categories":["编程"],"content":"客户端 import socket #买手机 phone=socket.socket(socket.AF_INET, socket.SOCK_STREAM) #拨电话 phone.connect(('127.0.0.1', 9000)) #发收消息 phone.send(\"hello\".encode('utf-8')) data = phone.recv(1024) print(data) #挂电话 phone.close() 结果： #服务端 staring.... \u003csocket.socket fd=360, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 9000), raddr=('127.0.0.1', 18455)\u003e ('127.0.0.1', 18455) #客户端 b'HELLO' 优化：加上通信循环 服务端 import socket phone = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #tcp协议 # phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) phone.bind(('127.0.0.1', 9000)) #0-65535 phone.listen(5) print('staring....') conn, client_addr=phone.accept() #(conn,client_addr) print(conn, client_addr) while True: data = conn.recv(1024) #1024bytes? print('客户端信息', data) conn.send(data.upper()) conn.close() phone.close() 客户端 import socket phone=socket.socket(socket.AF_INET, socket.SOCK_STREAM) phone.connect(('127.0.0.1', 9000)) while True: #通信循环 msg=input('\u003e\u003e: ').strip() if not msg: continue #防止发送空信息 phone.send(msg.encode('utf-8')) data = phone.recv(1024) print(data) phone.close() 防止服务端死掉，添加链接循环。并捕捉异常信号，防止客户端突然断掉导致服务端死掉。相当于服务端释放无效链接。 服务端 import socket phone = socket.socket(socket.AF_INET, socket.SOCK_STREAM) #tcp协议 # phone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) phone.bind(('127.0.0.1', 9000)) #0-65535 phone.listen(5) print('staring....') while True: #链接循环 conn, client_addr=phone.accept() #(conn,client_addr) print(client_addr) while True: #通信循环 try: data = conn.recv(1024) #1024bytes? if not data:break #针对的是Linux系统，因为linux不会抛异常。windows会抛异常。 print('客户端信息', data) conn.send(data.upper()) except ConnectionResetError: break conn.close() phone.close() 客户端 import socket phone=socket.socket(socket.AF_INET, socket.SOCK_STREAM) phone.connect(('127.0.0.1', 9000)) while True: #通信循环 msg=input('\u003e\u003e: ').strip() if not msg: continue #防止发送空信息 phone.send(msg.encode('utf-8')) data = phone.recv(1024) print(data) phone.close() 效果，客户端突然死掉后，服务端会释放链接。当再次有新客户端来连接时，服务端会再开新链接，释放旧链接。 #服务端 staring.... ('127.0.0.1', 18939) ('127.0.0.1', 18940) ('127.0.0.1', 18941) ('127.0.0.1', 18944) #客户端 \u003e\u003e: Process finished with exit code -1 #windows会查到链接 TCP 127.0.0.1:9000 127.0.0.1:18944 ESTABLISHED TCP 127.0.0.1:18944 127.0.0.1:9000 ESTABLISHED ","date":"2022-04-11","objectID":"/%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E7%AE%80%E5%8D%95%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/:1:2","tags":["python"],"title":"基于tcp的简单套接字通信","uri":"/%E5%9F%BA%E4%BA%8Etcp%E7%9A%84%E7%AE%80%E5%8D%95%E5%A5%97%E6%8E%A5%E5%AD%97%E9%80%9A%E4%BF%A1/"},{"categories":["编程"],"content":"集合的相关特性 ","date":"2022-04-11","objectID":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/:1:0","tags":["python"],"title":"集合的相关特性","uri":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"},{"categories":["编程"],"content":"去重 s = {1,2,2,2,2,2,3,3,3,4,4,4,5} print(s) #{1,2,3,4,5} 确保不要将集合与字典混淆，字典也用花括号括起来。 my_set = {1,2,3} my_dict = {\"term\": \"definition\", \"term2\": \"definition2\"} ","date":"2022-04-11","objectID":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/:1:1","tags":["python"],"title":"集合的相关特性","uri":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"},{"categories":["编程"],"content":"set() 将其他数据类型转换成集合类型 l = [1,2,3,4] s = set(l) print(s) #{1,2,3,4} ","date":"2022-04-11","objectID":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/:1:2","tags":["python"],"title":"集合的相关特性","uri":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"},{"categories":["编程"],"content":"并集(.union()) 联合是一个新集合，包含所有原始集合中的元素。这可以被认为是两个或多个集合的总和。 a = {1,2,3} b = {3,4,5} c = a.union(b) print(c) #{1,2,3,4,5} ","date":"2022-04-11","objectID":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/:1:3","tags":["python"],"title":"集合的相关特性","uri":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"},{"categories":["编程"],"content":"交集(.intersection()) 交集标识多个集合之间的共同元素或重叠。 a = {1,2,3} b = {3,4,5} c = a.intersection(b) print(c) #{3} ","date":"2022-04-11","objectID":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/:1:4","tags":["python"],"title":"集合的相关特性","uri":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"},{"categories":["编程"],"content":"差集(.difference()) 差异标识存在于基集中而不存在于另一个基集中的值。a集合中有而b集合中没有的部分。 a = {1,2,3} b = {3,4,5} c = a.difference(b) print(c) #{1,2} ","date":"2022-04-11","objectID":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/:1:5","tags":["python"],"title":"集合的相关特性","uri":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"},{"categories":["编程"],"content":"对称差集(.symmetric_difference) 从并集中减去交集剩下的就是对称差集 a = {1,2,3} b = {3,4,5} c = a.symmetric_difference(b) print(c) #{1,2,4,5} ","date":"2022-04-11","objectID":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/:1:6","tags":["python"],"title":"集合的相关特性","uri":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"},{"categories":["编程"],"content":"子集判断 .issubset()和issuperset()方法返回布尔值True或者False 子集是一个集合，其中所有元素都存在于更大的集合中 a = {1,2,3,4,5} b = {3,4,5} c = a.issubset(b) print(c) #a是b的子集吗？ 结果是 False a、b集合调换位置 a = {1,2,3,4,5} b = {3,4,5} c = b.issubset(a) print(c) #b是a的子集吗？ 结果是 True ","date":"2022-04-11","objectID":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/:1:7","tags":["python"],"title":"集合的相关特性","uri":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"},{"categories":["编程"],"content":"超集判断 超集与子集相反。如果提供的参数的所有元素都存在于其中，则基集被声明为超集。 a = {1,2,3,4,5} b = {3,4,5} c = a.issuperset(b) print(c) # True ","date":"2022-04-11","objectID":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/:1:8","tags":["python"],"title":"集合的相关特性","uri":"/%E9%9B%86%E5%90%88%E7%9A%84%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/"},{"categories":["编程"],"content":"异常 ","date":"2022-04-09","objectID":"/%E5%BC%82%E5%B8%B8/:1:0","tags":["python"],"title":"异常","uri":"/%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"什么是异常？ 异常是错误发生的信号，一旦程序出错，就会产生一个异常，应用程序未处理该异常，异常便会抛出，程序随之终止。 ","date":"2022-04-09","objectID":"/%E5%BC%82%E5%B8%B8/:1:1","tags":["python"],"title":"异常","uri":"/%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"常见异常类型 语法错误应该在程序运行之前就修正 if 1\u003e2 print(\"xxxxxx\") 逻辑错误 x #NameError l=[10000] #IndexError class foo: pass Foo.x #AttributeError: k={'x':1} k['y'] #KeyError res1=1/0 res2=1+'str' #ZeroDivisionError:无法完成计算 for i in 3: pass #TypeError:int类型不可迭代 num=input(\"\u003e\u003e: \") #输入hello int(num) #ValueError ","date":"2022-04-09","objectID":"/%E5%BC%82%E5%B8%B8/:1:2","tags":["python"],"title":"异常","uri":"/%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"如何处理异常 #基本语法为 try: 被检测的代码块 except 异常类型： try中一旦检测到异常，就执行这个位置的逻辑 #举例 try: f=open('a.txt') g=(line.strip() for line in f) print(next(g)) print(next(g)) print(next(g)) print(next(g)) print(next(g)) except StopIteration: f.close() 异常类只能用来处理指定的异常情况，如果非指定异常则无法处理。 s1 = 'hello' try: int(s1) except IndexError as e: # 未捕获到异常，程序直接报错 print e 多分支 s1 = 'hello' try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e) 万能异常Exception s1 = 'hello' try: int(s1) except Exception as e: print(e) 多分支异常与万能异常 如果你想要的效果是，无论出现什么异常，我们统一丢弃，或者使用同一段代码逻辑去处理他们。 如果你想要的效果是，对于不同的异常我们需要定制不同的处理逻辑，那就需要用到多分支了。 s1 = 'hello' try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e) except Exception as e: print(e) 异常的其他结构 s1 = 'hello' try: int(s1) except IndexError as e: print(e) except KeyError as e: print(e) except ValueError as e: print(e) #except Exception as e: # print(e) else: print('try内代码块没有异常则执行我') finally: print('无论异常与否,都会执行该模块,通常是进行清理工作') 主动触发异常 try: raise TypeError('类型错误') except Exception as e: print(e) 自定义异常 class EgonException(BaseException): def __init__(self,msg): self.msg=msg def __str__(self): return self.msg try: raise EgonException('类型错误') except EgonException as e: print(e) 断言:assert 条件 assert 1 == 1 assert 1 == 2 总结try..except 1：把错误处理和真正的工作分开来 2：代码更易组织，更清晰，复杂的工作任务更容易实现 3：毫无疑问，更安全了，不至于由于一些小的疏忽而使程序意外崩溃了 多分支异常处理 功能：判断打开的文件是否存在，不存在则捕获异常，存在则每2秒逐行读取文件内容。 import time try: f = open(\"123.txt\",'r') try: while True: content = f.readline() if len(content) == 0: break time.sleep(2) print(content) finally: f.close() print(\"文件关闭\") except Exception as result: print(\"发生异常。。。。\") ","date":"2022-04-09","objectID":"/%E5%BC%82%E5%B8%B8/:1:3","tags":["python"],"title":"异常","uri":"/%E5%BC%82%E5%B8%B8/"},{"categories":["编程"],"content":"封装与反射 片面理解：封装相当于隐藏。 ","date":"2022-04-09","objectID":"/%E5%B0%81%E8%A3%85/:1:0","tags":["python"],"title":"封装","uri":"/%E5%B0%81%E8%A3%85/"},{"categories":["编程"],"content":"如何将属性隐藏（设置成私有）？ 用双下划线开头方式将属性隐藏起来。 1.__开头的属性只是一种语法意义上的变形，并不会真的限制外部的访问。_类名__属性名可以访问但毫无意义。 2.这种变形只在类的定义阶段发送一次，类定义之后再新增的__开头的属性不会变形。 3.这种隐藏只对外不对内，因为类内部定义的属性在类定义阶段统一发生变形。 class Foo: __N=0 def __init__(self): self.__X=10 def __foo(self): #相当于_Foo__foo() print('from A') def bar(self): self.__foo() f = Foo() #类实例化，f是对象。 f.bar() #结果 'from A'。内部调用了__foo()验证第3条。 f.__foo() #报错。AttributeError: 'Foo' object has no attribute '__foo'，属性被隐藏，外部不可调用。验证第一条外部不能访问隐藏属性。 # 可以用f._Foo__foo()调用，但毫无意义。验证第1条。 f.__N=10 print(f.__N) #验证第二条。类定义时已经定义了__N=0,而__N=10是在类定义之后。此时可以调用__N.结果为10 封装应用 class People: def __init__(self,name,age): # self.__name=name # self.__age=age self.set_info(name,age) def tell_info(self): print(\"姓名：\u003c%s\u003e 年龄：\u003c%s\u003e\"%(self.__name,self.__age)) def set_info(self,name,age): if type(name) is not str: #判断name是否是str类型 raise TypeError('name must be str') if type(age) is not int: #判断age是否是int类型 raise TypeError('age must be int') self.__name=name self.__age=age p=People(12312323,18) #TypeError: name must be str p.tell_info() 核心思想：通过设置set_info()方法统一接口，把name、age隐藏。用户只需要调用tell_info()方法，不需要了解其中的过程。 ","date":"2022-04-09","objectID":"/%E5%B0%81%E8%A3%85/:1:1","tags":["python"],"title":"封装","uri":"/%E5%B0%81%E8%A3%85/"},{"categories":["编程"],"content":"封装之property property是一种特殊属性，访问它时会执行一段功能（函数）然后返回值。 成人的BMI数值： 过轻：低于18.5 正常：18.5-23.9 过重：24-27 肥胖：28-32 非常肥胖, 高于32 体质指数（BMI）=体重（kg）÷身高^2（m） EX：70kg÷（1.75×1.75）=22.86 class People: def __init__(self,name,age,height,weight): self.name=name self.age=age self.height=height self.weight=weight @property def bmi(self): return self.weight / (self.height ** 2) jack=People('jack',18,1.80,75) # jack.height=1.82 print(jack.bmi) bmi应该是不断变化的，是一种数据属性。 为什么要用property 将一个类的函数定义成特性以后，对象再去使用的时候ojb.name，根本无法察觉自己的name是执行了一个而函数然后计算出来，这种特性的使用方式遵循了统一访问的原则。 class People: def __init__(self,name): self.__name = name #将所有的数据属性都隐藏起来 @property def name(self): return self.__name #obj.name访问的是self.__name（这也是真实值的存放位置） jack=Pepole('jack') #类实例化 print(jack.name) #jack 此时名字不能修改,修改会报异常。 jack.name='smith' #AttributeError: can't set attribute 怎样可以修改呢？ 设置同名的属性.setter()方法 class People: def __init__(self,name): self.__name = name @property def name(self): return self.__name @name.setter def name(self,obj): if type(obj) is not str: #在设定值之前进行类型检查 raise TypeError(\"name must be str\") self.__name=obj jack=Pepole('jack') jack.name='smith' print(jack.name) #smith 如何删除属性呢？ 添加同名属性.deleter class People: def __init__(self,name): self.__name = name @property def name(self): return self.__name @name.setter def name(self,obj): if type(obj) is not str: #在设定值之前进行类型检查 raise TypeError(\"name must be str\") self.__name=obj @name.deleter def name(self,obj): del self.__name jack=Pepole('jack') jack.name='smith' del jack.name print(jack.name) #AttributeError: 'People' object has no attribute '_People__name' 成功删除了。 ","date":"2022-04-09","objectID":"/%E5%B0%81%E8%A3%85/:1:2","tags":["python"],"title":"封装","uri":"/%E5%B0%81%E8%A3%85/"},{"categories":["编程"],"content":"反射 ","date":"2022-04-09","objectID":"/%E5%B0%81%E8%A3%85/:2:0","tags":["python"],"title":"封装","uri":"/%E5%B0%81%E8%A3%85/"},{"categories":["编程"],"content":"内置函数补充 isinstance判断类型 issubclass:判断是不是子类 l=[] print(type(l) is list) print(isinstance(l,list)) #True class Foo: pass class Bar(Foo): pass print(issubclass(Bar,Foo)) #True 反射 通过字符串映射或修改程序运行时的状态、属性、方法有以下4个方法： hasattr(obj,name_str):判断一个对象里是否有对应的name_str字符串的方法 setattr(obj,y,v)：设置属性,相当于obj.y=v getattr(obj,name_str,default=None)：根据字符串name_str去获取obj对象里的方法内存地址 delattr(x,y)：删除某种属性 class Foo: def __init__(self,name): self.name=name def f1(self): print('from f1') obj=Foo('jack') # print(obj.name) #等同于obj.__dict__['name'] #hasattr print(hasattr(obj,'name')) #True print(hasattr(obj,'f1')) #True #setattr setattr(obj,'x',1) print(obj.__dict__) #结果是：{'name': 'jack', 'x': 1} #getattr if hasattr(obj, 'f1'): f = getattr(obj, 'f1') # f=obj.f1 # print(f) #\u003cbound method Foo.f1 of \u003c__main__.Foo object at 0x000002A8A3677DC0\u003e\u003e f() #from f1 #delattr delattr(obj,'name') print(obj.__dict__) #{'x': 1} ","date":"2022-04-09","objectID":"/%E5%B0%81%E8%A3%85/:2:1","tags":["python"],"title":"封装","uri":"/%E5%B0%81%E8%A3%85/"},{"categories":["编程"],"content":"类的内置方法 __str__：改变对象字符串显示 不使用__str__显示 class People: def __init__(self,name,age): self.name=name self.age=age jack=People('jack',18) print(jack) #\u003c__main__.People object at 0x000001D7DEF31310\u003e 使用之后可以自定义显示内容 class People: def __init__(self,name,age): self.name=name self.age=age def __str__(self): return '\u003cname: %s,age: %s\u003e' %(self.name,self.age) jack=People('jack',18) print(jack) #\u003cname: jack,age: 18\u003e __del__：析构方法，当对象在内存种被释放时，自动触发执行。 注：如果产生的对象仅仅只是python程序级别的（用户级），那么无需定义__del__,如果产生的对象的同时还会向操作系统发起系统调用，即一个对象有用户级与内核级两种资源，比如（打开一个文件，创建一个数据库链接），则必须在清除对象的同时回收系统资源，这就用到了__del__。 class Foo: def __del__(self): print('执行我啦') f1=Foo() del f1 print(\"------\u003e\") 结果： 执行我啦 ------\u003e 如果去掉del f1那么结果又不一样了。 class Foo: def __del__(self): print('执行我啦') f1=Foo() print(\"------\u003e\") 结果 ------\u003e 执行我啦 ","date":"2022-04-09","objectID":"/%E5%B0%81%E8%A3%85/:3:0","tags":["python"],"title":"封装","uri":"/%E5%B0%81%E8%A3%85/"},{"categories":["工具"],"content":"ftp基本配置 系统：centos7 安装vsftpd 、ftp客户端 yum install vsftpd -y yum install ftp -y [root@localhost vsftpd]# rpm -qa | grep ftp vsftpd-sysvinit-3.0.2-29.el7_9.x86_64 vsftpd-3.0.2-29.el7_9.x86_64 ftp-0.17-67.el7.x86_64 防火墙设置 firewall-cmd --list-services //查看防火墙允许的服务。 firewall-cmd --add-service=ftp --permanent //永久开放ftp服务 firewall-cmd --add-port=20/tcp --permanent firewall-cmd --add-port=21/tcp --permanent //允许外网访问 firewall-cmd --reload //重新载入配置 setsebool ftpd_full_access 1 //selinux设置 setsebool tftp_home_dir 1 创建用户，登录 useradd test passwd test ftp localhost #ftp本地测试 [root@localhost vsftpd]# ftp localhost Trying ::1... ftp: connect to address ::1Connection refused Trying 127.0.0.1... Connected to localhost (127.0.0.1). 220 Welcome to blah FTP service. Name (localhost:root): test 331 Please specify the password. Password: 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u003e 局域网测试： 虚拟机IP:10.4.7.140 ftp：21被动模式 接下来在windows平台用FileZilla Client软件登陆. 连接成功： 系统账号默认登陆是在账号的家目录，可以切换到其它目录。 到这里，基本的vsftpd搭建成功。 开机自启vsftpd systemctl enable vsftpd ","date":"2022-04-02","objectID":"/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/:0:1","tags":["vsftp"],"title":"vsftpd相关配置","uri":"/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"vsftpd 被动模式普通用户登录配置 主程序：/usr/sbin/vsftpd 主配置文件：/etc/vsftpd/vsftpd.conf 数据根目录：/var/ftp 就算是经验丰富的老手也会做好备份工作 cp /etc/vsftpd/vsftpd.conf /etc/vsftpd/vsftpd.conf.bak anonymous_enable=NO //设定不允许匿名访问 local_enable=YES //设定本地用户可以访问 write_enable=YES //设定可以进行写操作 local_umask=022 //设定上传后文件的权限掩码 anon_upload_enable=NO //禁止匿名用户上传 anon_mkdir_write_enable=NO //禁止匿名用户建立目录 dirmessage_enable=YES //设定开启目录标语功能 xferlog_enable=YES //设定开启日志记录功能 connect_from_port_20=YES //设定端口20进行数据连接(主动模式) chown_uploads=NO //设定禁止上传文件更改宿主 #chown_username=whoever xferlog_file=/var/log/xferlog //设定Vsftpd的服务日志保存路径。 xferlog_std_format=YES //设定日志使用标准的记录格式。 #idle_session_timeout=600 //设定空闲连接超时时间，单位为秒，这里默认 #data_connection_timeout=120 //设定空闲连接超时时间，单位为秒，这里默认。 #nopriv_user=ftptest async_abor_enable=YES //设定支持异步传输功能。 ascii_upload_enable=YES ascii_download_enable=YES //设定支持ASCII模式的上传和下载功能。 ftpd_banner=Welcome to blah FTP service. //设定Vsftpd的登陆标语。 #deny_email_enable=YES // (default follows) #banned_email_file=/etc/vsftpd/banned_emails chroot_local_user=YES chroot_list_enable=YES //禁止用户登出自己的FTP主目录。 chroot_list_file=/etc/vsftpd/chroot_list //这个文件里的用户不受限制，不限制在本目录。 ls_recurse_enable=NO //禁止用户登陆FTP后使用\"ls -R\"的命令。 该命令会对服务器性能造成巨大开销。 #listen=NO #listen_ipv6=YES userlist_enable=YES //设定userlist_file中的用户将不得使用FTP。 tcp_wrappers=YES //设定支持TCP Wrappers allow_writeable_chroot=YES //这个可以解决chroot权限问题 pasv_enable=YES pasv_min_port=40000 pasv_max_port=40080 pasv_promiscuous=YES systemctl restart vsftpd //重启vsftpd服务 如果登录失败提示500，需要在服务器上创建chroot_list把test加进列表 echo test \u003e\u003e /etc/vsftpd/chroot_list 创建另一个用户aaa。目前test 和aaa都可以登录ftp 由于test加入到了chroot_list列表中，可以随意切换目录。而aaa用户不在了列表中，只能在aaa用户家目录中活动，不能自由切换目录。 ———————————————— 解释：chroot_local_user=YES将所有用户限定在主目录内，chroot_list_enable=YES表示要启用chroot_list_file, 因为chroot_local_user=YES，即全体用户都被“限定在主目录内”,所以总是作为“例外列表”的chroot_list_file这时列出的是那些不会被限制在主目录下的用户。 ","date":"2022-04-02","objectID":"/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/:0:2","tags":["vsftp"],"title":"vsftpd相关配置","uri":"/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"vsftpd 匿名用户登录配置 建立虚拟FTP用户数据库文件 建立一个虚拟用户名单文件，这个文件就是来记录vsftpd虚拟用户的用户名和口令的数据文件，我这里给它命名为vuser.list，保存在/etc/vsftpd/目录下。一行账号，一行密码 $ vim vuser.list vuser 123456 安装Berkeley DB #有db_load 命令可以忽略。 yum install libdb-utils-5.3.21-25.el7.x86_64 安装后在/etc/vsftpd/目录下执行。 db_load -T -t hash -f vuser.list vuser.db//生成用户加密文件 chmod 600 vuser.db //敏感文件限制只允许属主读写 创建虚拟用户及虚拟用户的家目录 useradd -d /var/vusers -s /sbin/nologin vftp //创建系统用户vftp，并制定其家目录为/var/vusers chmod -Rf 755 /var/vusers/ //修改目录的权限使得其他用户也可以访问。 建立支持虚拟用户的PAM认证文件 vsftpd的pam文件在/etc/pam.d/目录下，先做备份工作。 cp vsftpd vsftpd.bak vim vsftpd 重要：先注释掉所有的内容后添加以下内容： auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/vuser //此句用于检查用户密码，数据库文件不要写后缀.db account required /lib64/security/pam_userdb.so db=/etc/vsftpd/vuser //此句用于检查用户是否在有效期内，数据库支持虚拟用户的PAM认证文件。 在vsftpd.conf中添加支持配置 guest_enable=YES //开启虚拟用户模式 guest_username=vftp //指定虚拟用户账号 pam_service_name=vsftpd //指定pam文件 user_config_dir=/etc/vsftpd/vusers_profile //指定虚拟用户的权限配置目录。 virtual_use_local_privs=NO //虚拟用户和匿名用户有相同的权限 为虚拟用户设置不同的权限。 mkdir -p /etc/vsftpd/vusers_profile/新建虚拟用户目录 vim /etc/vsftpd/vusers_profile/vuser/新建虚拟用户配置文件，文件名要和上面的虚拟用户名单里的账号名字对等。 mkdir -p /var/vusers/vuser/创建虚拟用户家目录 local_root=/var/vusers/vuser //虚拟账号的家目录 write_enable=YES anonymous_enable=NO local_umask=022 anon_upload_enable=YES //上传权限 anon_mkdir_write_enable=YES //创建文件和目录的权限 anon_other_write_enable=YES //删除文件和目录的权限 anon_world_readable_only=YES //当文件的“其他人”有读权限的时候可以下载 download_enable=YES //下载权限 保存配置，重启服务。 systemctl restart vsftpd 登录查看： 此处/指的是vuser用户家目录而不是根目录。 本实验中匿名用户登录后有查看下载权限，没有创建文件权限。并且限制了只能查看匿名用户的家目录，不能切换到其他目录。 vsftpd传输模式 主动模式：服务端主动连客户端 在主动模式下，FTP客户端从任意端口5150（端口号\u003e1023）发起一个FTP请求，并携带自己监听的端口号5151（发送的端口号+1=监听端口号）；随后服务器返回确认，然后从服务器本地的20端口主动发起连接请求到客户端的监听端口5151，最后客户端返回确认。 被动模式：客户端主动连服务端 在被动模式中，命令连接和数据连接都由客户端来发起，如上图所示，客户端用随机命令端口5150向服务器的21命令端口发送一个PASV请求，然后服务器返回数据端口3267，告诉客户端我在哪个端口监听数据连接。然后客户端向服务器的监听端口3268发起数据连接，最后服务器回复确认。 **vsftpd默认是被动模式。**所以客户端要设置被动模式连接，如果到现在还没连接成功的看客户端有没有设置被动传输模式。 FTP工作原理介绍 文件传输协议：File Transfer Protocol 早期的三个应用级协议之一，基于C/S结构 数据传输格式：二进制（默认）和文本 双通道协议：命令和数据连接 两种模式：从服务器角度 主动(PORT style)：服务器主动连接 命令（控制）：客户端：随机port —\u003e 服务器：21/tcp 数据：客户端：随机port \u003c—服务器：20/tcp 被动(PASV style)：客户端主动连接 命令（控制）：客户端：随机port —\u003e 服务器：21/tcp 数据：客户端：随机port —\u003e 服务器：随机port /tcp 范例：服务器被动模式数据端口 227 Entering Passive Mode (172,16,0,1,224,59) 服务器数据端口为：224*256+59 FTP服务状态码： 1XX：信息 125：数据连接打开 2XX：成功类状态 200：命令OK 230：登录成功 3XX：补充类 331：用户名OK 4XX：客户端错误 425：不能打开数据连接 5XX：服务器错误 530：不能登录 用户认证： 匿名用户：ftp,anonymous,对应Linux用户ftp ​ 系统用户：Linux用户,用户/etc/passwd,密码/etc/shadow ​ 虚拟用户：特定服务的专用用户，独立的用户/密码文件 vsftpd 软件介绍 由 vsftpd 包提供，不再由xinetd管理 用户认证配置文件：/etc/pam.d/vsftpd 启动服务相关文件： /usr/lib/systemd/system/vsftpd.service /etc/rc.d/init.d/vsftpd 配置文件： /etc/vsftpd/vsftpd.conf 帮助：man 5 vsftpd.conf 配置文件格式： option=value 注意：= 前后不要有空格 用户和其共享目录 匿名用户（映射为系统用户ftp ）共享文件位置：/var/ftp 系统用户共享文件位置：用户家目录 虚拟用户共享文件位置：为其映射的系统用户的家目录 ","date":"2022-04-02","objectID":"/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/:0:3","tags":["vsftp"],"title":"vsftpd相关配置","uri":"/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"提高vsftp的访问速度 vsftp连接时很慢，因为默认开启了reverse_lookup（反向解析）. 在(vsftpd.conf)主文件中添加 reverse_lookup_enable=NO 重启vsftpd服务 systemctl restart vsftpd ","date":"2022-04-02","objectID":"/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/:0:4","tags":["vsftp"],"title":"vsftpd相关配置","uri":"/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"},{"categories":["工具"],"content":"需求 1.设立管理员用户拥有所有权限（上传、下载、文件删除）。 2.其他用户只允许下载，不允许上传、文件修改和删除。 3.禁止使用匿名用户登录 用户名 权限说明 admin 管理员，可以上传、下载、新建文件夹、删除和更改文件和文件夹名。 upload 可以上传、新建文件夹。不可以下载，不能删除文件和文件夹，不能重命名原有文件和文件夹。 download 只能下载，不能进行其他操作。 实验环境 centos7.9 x86_64 以上三个虚拟用户均不允许登录系统，并且使用ftp时会被锁定在指定目录内不可进入系统其他目录。 安装配置vsftpd yum -y install vsftpd cd /etc/vsftpd/ cp vsftpd.conf vsftpd.conf.bak #先备份 添加一个不能登录系统用户，用来做虚拟用户映射。 useradd www2013 -s /sbin/nologin -d /home/www2013 passwd www2013 创建虚拟用户列表，分别是upload、download和admin touch /etc/vsftpd/vu_list.txt cat \u003e\u003evu_list\u003c\u003ceof upload 111111 download 111111 admin 111111 eof 查看列表内容 #cat /etc/vsftpd/vu_list.txt upload 111111 download 111111 admin 111111 创建db文件 保存虚拟帐号和密码的文本文件无法被系统帐号直接调用，需要创建用于系统认证的db文件 db_load -T -t hash -f /etc/vsftpd/vu_list.txt /etc/vsftpd/vu_list.db -T 用于轻松地将文本文件导入数据库。 -t 表示指定底层访问方法。 hash 是我们指定的底层访问方法。 -f 表示从指定文件中读取。 指定的文件是vu_list.txt 我们正在创建或添加的数据库是vu_list.db 注意：创建db文件需要db4支持，如果系统没安装请安装 yum -y install db4 db4-devel db4-utils 修改db文件的权限，以免被非法用户修改 chmod 600 /etc/vsftpd/vu_list.db 并删除vu_list.txt 文件 rm vu_list.txt 添加新用户时，只需使用vi新建一个vu_list.txt 文件，然后重新运行db_load命令，即可将新用户添加到数据库中。 配置PAM文件 由于服务器通过调用系统PAM模块来对客户端进行身份验证，因此需要修改指定的配置文件来调整认证方式。PAM模块的配置文件路径为：/etc/pam.d/,这个目录下存放只许多与用户认证有关的配置文件。 备份原文件 cp /etc/pam.d/vsftpd /etc/pam.d/vsftpd.old 编辑vsftpd文件，除了#%PAM-1.0其他都注释掉，然后再添加。 32位系统添加： auth required /lib/security/pam_userdb.so db=/etc/vsftpd/vu_list account required /lib/security/pam_userdb.so db=/etc/vsftpd/vu_list 64位系统添加： auth required /lib64/security/pam_userdb.so db=/etc/vsftpd/vu_list account required /lib64/security/pam_userdb.so db=/etc/vsftpd/vu_list 创建虚拟用户配置文件 #创建conf文件夹 cd /etc/vsftpd mkdir conf cd conf #创建admin用户的配置文件 cat \u003e\u003eadmin\u003c\u003c EOF anon_world_readable_only=NO write_enable=YES anon_mkdir_write_enable=YES anon_other_write_enable=YES anon_upload_enable=YES EOF #创建upload用户的配置文件 cat \u003e\u003eupload\u003c\u003c EOF write_enable=YES anon_upload_enable=YES anon_mkdir_write_enable=YES anon_world_readable_only=NO download_enable=NO EOF #创建download用户的配置文件 cat \u003e\u003edownload\u003c\u003c EOF anon_world_readable_only=NO EOF 修改vsftpd.conf文件 vi vsftpd.conf #修改内容如下 anonymous_enable=NO local_enable=YES anon_mkdir_write_enable=NO dirmessage_enable=YES xferlog_enable=YES connect_from_port_20=YES chown_uploads=NO chroot_local_user=YES chroot_list_enable=YES chroot_list_file=/etc/vsftpd/chroot_list allow_writeable_chroot=YES xferlog_file=/var/log/vsftpd.log xferlog_std_format=YES nopriv_user=www2013 async_abor_enable=YES ascii_upload_enable=YES ascii_download_enable=YES ftpd_banner=Welcome to blah FTP service ^_^ ls_recurse_enable=NO listen=YES pam_service_name=vsftpd userlist_enable=YES tcp_wrappers=YES local_root=/home/www2013 guest_enable=YES guest_username=www2013 virtual_use_local_privs=YES user_config_dir=/etc/vsftpd/conf reverse_lookup_enable=NO 注意 guest_username要和之前建立的不能登陆的系统用户匹配。 chroot_list_enable和chroot_local_user取值的不同组合情况 参数 取值 取值 取值 取值 chroot_list_enable YES YES NO NO chroot_local_user YES NO YES NO 意义 文件中列出的用户根目录为系统根目录，其它用户根目录为自己主目录。 文件中列出的用户根目录为自己主目录，其它用户根目录为系统根目录。 全部用户根目录都是自己主目录。 全部用户根目录都是系统根目录。 禁锢系统用户 禁锢所有系统用户在家目录中 chroot_local_user=YES 禁锢系统用户，默认NO，即不禁锢。 禁锢或不禁锢特定的系统用户在家目录中，与上面设置功能相反 chroot_list_enable=YES #默认是NO ​ chroot_list_file=/etc/vsftpd/chroot_list #默认值 当chroot_local_user=YES和chroot_list_enable=YES时，则chroot_list中用户不禁锢，即白名单 当chroot_local_user=NO和chroot_list_enable=YES时，则chroot_list中用户禁锢，即黑名单 设置ssl，提高安全性。 vi /etc/vsftpd/vsftpd.conf添加到文件末尾。 rsa_cert_file=/etc/vsftpd/vsftpd.pem rsa_private_key_file=/etc/vsftpd/vsftpd.key ssl_enable=YES allow_anon_ssl=NO force_local_data_ssl=YES force_local_logins_ssl=YES ssl_tlsv1=YES ssl_sslv2=NO ssl_sslv3=NO pasv_min_port=7000 pasv_max_port=7500 设置RSA证书 openssl req -x509 -nodes -days 3650 -newkey rsa:2048 -keyout /etc/vsftpd/vsftpd.key -out /etc/vsftpd/vsftpd.pem 第一个字段是国家代码字段，填写您所在国家的两个字母代码： Country Name (2 letter code) [XX]: 接下来是州或省，通过输入全名而不是缩写来填写： State or Province Name (full name) []: 接下来是地区名称。这是你的城市： Locality Name (eg, city) [Default City]: 接下来是公司或组织名称。您可以将此留空或根据需要填写： Organization Name (eg, company) [Default Company Ltd","date":"2022-04-02","objectID":"/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/:0:5","tags":["vsftp"],"title":"vsftpd相关配置","uri":"/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/"},{"categories":["编程"],"content":"文件处理流程 1.打开文件，得到文件句柄并赋值给一个变量 2.通过句柄对文件进行操作 3.关闭文件 ","date":"2022-03-31","objectID":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:0","tags":["python"],"title":"python文件处理","uri":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["编程"],"content":"两种文件操作方式 直接操作（需要手动关闭文件） #1. 打开文件，得到文件句柄并赋值给一个变量 f=open('a.txt','r',encoding='utf-8') #默认打开模式就为r #2. 通过句柄对文件进行操作 data=f.read() #3. 关闭文件 f.close() 使用with关键字（推荐！自动关闭文件无需手动操作） #可用用with同时打开多个文件，用逗号分隔开即可 with open('a.txt','r',encoding='utf-8') as read_f,open('b.txt','w',encoding='utf-8') as write_f: data=read_f.read() write_f.write(data) 注意：若要保证不乱码，文件以什么方式存的，就要以什么方式打开。 f=open('a.txt','r',encoding='utf-8') linux默认编码'utf-8' windows默认编码 'gbk' ","date":"2022-03-31","objectID":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:1","tags":["python"],"title":"python文件处理","uri":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["编程"],"content":"python2中文件打开 #首先在python3中操作文件只有一种选择，那就是open() #而在python2中则有两种方式：file()与open() 两者都能够打开文件，对文件进行操作，也具有相似的用法和参数，但是，这两种文件打开方式有本质的区别，file为文件类，用file()来打开文件，相当于这是在构造文件类，而用open()打开文件，是用python的内建函数来操作，我们一般使用open()打开文件进行操作，而用file当做一个类型，比如type(f) is file。 ","date":"2022-03-31","objectID":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:2","tags":["python"],"title":"python文件处理","uri":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["编程"],"content":"打开文件的模式 基础 打开文件的模式有(默认为文本模式) r，只读模式【默认模式，文件必须存在，文件存在文件内指针直接跳到文件开头,不存在则抛出异常】 w，只写模式【不可读；不存在则创建；存在则清空内容,文件指针跑到文件开头.】 a，之追加写模式【不可读；不存在则创建；存在则只追加内容，文件存在会将文件指针直接移动到文件末尾】 强调 在文件不关闭的情况下,连续的写入，后写的内容一定跟在前写内容的后面。 如果重新以w模式打开文件，则会清空文件内容。 a与w相同与异同 相同点：在打开的文件不关闭的情况下，连续的写入，新写的内容总会跟在前写的内容之后 不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后。 对于非文本文件，我们只能使用b模式，“b\"表示以字节的方式操作（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、图片文件的jgp格式、视频文件的avi格式） rb wb ab 注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码 在平时工作中，我们只单纯使用r/w/a，要么只读，要么只写，一般不用可读可写的模式。 大前提: tb模式均不能单独使用,必须与r/w/a之一结合使用。 t（默认的）：文本模式 1. 读写文件都是以字符串为单位的 2. 只能针对文本文件 3. 必须指定encoding参数 b：二进制模式: 1.读写文件都是以bytes/二进制为单位的 2. 可以针对所有文件 3. 一定不能指定encoding参数 强调：b模式对比t模式 1、在操作纯文本文件方面t模式帮我们省去了编码与解码的环节，b模式则需要手动编码与解码，所以此时t模式更为方便。 2、针对非文本文件（如图片、视频、音频等）只能使用b模式。 拓展 \"+\" 表示可以同时读写某个文件 r+， 读写【可读，可写】 w+，写读【可读，可写】 a+， 写读【可读，可写】 x， 只写模式【不可读；不存在则创建，存在则报错】 x+ ，写读【可读，可写】 回车与换行 \\n 换行 \\r 回车 ","date":"2022-03-31","objectID":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:3","tags":["python"],"title":"python文件处理","uri":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["编程"],"content":"操作文件的方法 基础 f.read() #读取所有内容,光标移动到文件末尾。 f.readline() #读取一行内容,光标移动到第二行首部。 f.readlines() #读取每一行内容,存放于列表中。 f.write('11111\\n222\\n') #针对文本模式的写,需要自己写换行符。 f.writelines('11111\\n222\\n'.encode('utf-8')) #针对b模式的写,需要自己写换行符。 f.writelines(['333\\n','444\\n']) #文件模式 f.writelines([bytes('333\\n',encoding='utf-8'),'444\\n'.encode('utf-8')]) #b模式 拓展 f.readable() #文件是否可读 f.writeable() #文件是否可写 f.closed #文件是否关闭 f.encoding() #如果文件打开模式为b,则没有该属性。 f.flush() #立刻将文件内容从内存刷到硬盘 f.name #显示文件名 f.tell() #显示当前光标位置 f.seek(0) #重置光标位置,光标会跳到第一行行首。 ","date":"2022-03-31","objectID":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:4","tags":["python"],"title":"python文件处理","uri":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["编程"],"content":"文件内光标移动 read(3) 文件打开方式为文本模式时，代表读取3个字符。 文件打开方式为b模式时，代表读取3个字节。 其余的文件内光标移动都是以字节为单位如seek，tell，truncate。 注意 seek有三种移动方式0，1，2，其中1和2必须在b模式下进行，但无论哪种模式，都是以bytes为单位移动的. truncate是截断文件，所以文件的打开方式必须可写，但是不能用w或w+等方式打开，因为那样直接清空文件了，所以truncate要在r+或a或a+等模式下测试效果。 之前文件内指针的移动都是由读/写操作而被动触发的，若想读取文件某一特定位置的数据，则需要用f.seek方法主动控制文件内指针的移动，详细用法如下： f.seek(指针移动的字节数,模式控制): 模式控制: 0: 默认的模式,该模式代表指针移动的字节数是以文件开头为参照的 1: 该模式代表指针移动的字节数是以当前所在的位置为参照的 2: 该模式代表指针移动的字节数是以文件末尾的位置为参照的 强调:其中0模式可以在t或者b模式使用,而1跟2模式只能在b模式下用 0模式 # a.txt用utf-8编码，内容如下（abc各占1个字节，中文“你好”各占3个字节） abc你好 # 0模式的使用 with open('a.txt',mode='rt',encoding='utf-8') as f: f.seek(3,0) # 参照文件开头移动了3个字节 print(f.tell()) # 查看当前文件指针距离文件开头的位置，输出结果为3 print(f.read()) # 从第3个字节的位置读到文件末尾，输出结果为：你好 # 注意：由于在t模式下，会将读取的内容自动解码，所以必须保证读取的内容是一个完整中文数据，否则解码失败 with open('a.txt',mode='rb') as f: f.seek(6,0) print(f.read().decode('utf-8')) #输出结果为: 好 1模式 1模式 with open('a.txt',mode='rb') as f: f.seek(3,1) # 从当前位置往后移动3个字节，而此时的当前位置就是文件开头 print(f.tell()) # 输出结果为：3 f.seek(4,1) # 从当前位置往后移动4个字节，而此时的当前位置为3 print(f.tell()) # 输出结果为：7 练习：使用seek()实现shell中tail -f （文件日志追加功能） import time with open('access.log','rb') as f: f.seek(0, 2) while True: line = f.readline() if line: print(line.decode('utf-8')) else: time.sleep(0.2) 练习编写文件copy工具 方法1 src_file=input('源文件路径: ').strip() dst_file=input('目标文件路径: ').strip() with open(r'%s' %src_file,mode='rb') as read_f,open(r'%s' %dst_file,mode='wb') as write_f: for line in read_f: # print(line) write_f.write(line) 方法2 #任意文件拷贝 import sys #引入sys模块 _, src_file, dst_file = sys.argv #传参，_表示占位符。 with open(src_file, 'rb') as read_f,\\ open(dst_file, 'wb') as write_f: for line in read_f: write_f.write(line) #print(sys.argv) #使用方式 python D:\\pccharmcode\\begin.py 源文件路径 目的文件路径 ","date":"2022-03-31","objectID":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:5","tags":["python"],"title":"python文件处理","uri":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["编程"],"content":"文件的修改 文件的数据是存放于硬盘上的，因而只存在覆盖、不存在修改这么一说，我们平时看到的修改文件，都是模拟出来的效果，具体的说有两种实现方式： 方式一：将硬盘存放的该文件的内容全部加载到内存，在内存中是可以修改的，修改完毕后，再由内存覆盖到硬盘（word，vim，nodpad++等编辑器） import os with open('a.txt') as read_f,open('.a.txt.swap','w') as write_f: data=read_f.read() #全部读入内存,如果文件很大,会很卡 data=data.replace('alex','SB') #在内存中完成修改 write_f.write(data) #一次性写入新文件 os.remove('a.txt') os.rename('.a.txt.swap','a.txt') 方式二：将硬盘存放的该文件的内容一行一行地读入内存，修改完毕就写入新文件，最后用新文件覆盖源文件 import os with open('a.txt') as read_f,open('.a.txt.swap','w') as write_f: for line in read_f: #读 line=line.replace('alex','SB') #替换 write_f.write(line) #写入 os.remove('a.txt') os.rename('.a.txt.swap','a.txt') ","date":"2022-03-31","objectID":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:6","tags":["python"],"title":"python文件处理","uri":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["编程"],"content":"文件的逐行读取并打印行号 f = open(\"test.txt\",\"r\") content = f.readlines() i = 1 for temp in content: print(\"%d:%s\"%(i,temp)) i += 1 输出 1:hello world! 2:hello world! 3:hello world! 4:hello world! 5:hello world! ","date":"2022-03-31","objectID":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/:1:7","tags":["python"],"title":"python文件处理","uri":"/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/"},{"categories":["问题"],"content":"描述Linux下软链接和硬链接的区别 实践：当前所在路径/root 准备工作 echo 123 \u003e /tmpdisk/a.txt echo 123 \u003e /tmpdisk/b.txt mkdir -p /tmpdisk/ylink mkdir -p /tmpdisk/rlink 分别创建软链接和硬链接 ln -s /tmpdisk/a.txt ra.txt ln /tmpdisk/b.txt yb.txt ln /tmpdisk/ylink ylink #创建失败，硬链接不允许文件夹创建。ln: '/tmpdisk/ylink': hard link not allowed for directory ln -s /tmpdisk/rlink rlink 查看inode节点 [root@43f873a76b81 ~]# ls -li total 8 84271555 -rw------- 1 root root 3302 May 31 2018 anaconda-ks.cfg 87108116 lrwxrwxrwx 1 root root 14 Mar 28 06:18 ra.txt -\u003e /tmpdisk/a.txt 87108117 lrwxrwxrwx 1 root root 14 Mar 28 06:18 rlink -\u003e /tmpdisk/rlink 1588983 -rw-r--r-- 2 root root 4 Mar 28 05:27 yb.txt [root@43f873a76b81 ~]# ls -li /tmpdisk/ total 8 1588982 -rw-r--r-- 1 root root 4 Mar 28 05:26 a.txt 1588983 -rw-r--r-- 2 root root 4 Mar 28 05:27 b.txt 1588941 drwxr-xr-x 2 root root 6 Mar 28 06:13 rlink 1588940 drwxr-xr-x 2 root root 6 Mar 28 06:13 ylink 发现硬链接的原文件和链接文件inode一致。都为1588983。 软链接相当于快捷方式 ln -s 源文件路径 链接文件路径 链接文件路径--------\u003e源文件路径 总结： 默认不带参数的情况下，ln创建的是硬链接，带-s参数的ln命令创建的是软链接。 硬链接文件与源文件的inode节点号相同，软链接文件的inode节点号，与源文件不同。 ln命令不能对目录创建硬链接，但可以创建软链接。对目录的软链接会经常使用到 删除软链接文件，对源文件和硬链接文件无 任何影响。 删除文件的硬链接文件，对源文件及软链接文件无任何影响。 删除链接文件的源文件，对硬链接文件无影响，会导致其软链接失效（红底白字闪烁）。 同时删除源文件及其硬链接文件，整个文件才会被真正的删除。 很多硬件设备的快照功能，使用的就是列斯硬链接的原理 软链接可以跨文件系统，硬链接不可以跨文件系统。 ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:1:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"Linux 如何查找具有相同 inode 号的文件? ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:2:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"通过 inode号查找 find / -xdev -inum \u003cinode_num\u003e 2\u003e/dev/null find -L / -xdev -inum \u003cinode_num\u003e 2\u003e/dev/null ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:2:1","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"通过文件名查找 find / -xdev -samefile \u003cfile_name\u003e 2\u003e/dev/null find -L / -xdev -samefile \u003cfile_name\u003e 2\u003e/dev/null 其中 -xdev 表示不跨越文件系统查找 -L 表示考虑符号链接(软链接) 实例 查找源文件为/tmpdisk/a.txt的链接文件 [root@43f873a76b81 ~]# find / -xdev -samefile /tmpdisk/b.txt /root/yb.txt /tmpdisk/b.txt [root@43f873a76b81 ~]# ll -i /root/yb.txt /tmpdisk/b.txt 1588983 -rw-r--r-- 2 root root 4 Mar 28 05:27 /root/yb.txt 1588983 -rw-r--r-- 2 root root 4 Mar 28 05:27 /tmpdisk/b.txt ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:2:2","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"linux常见的系统日志文件都有哪些，各自的用途？ /var/log/messages 内核及公共消息日志 /var/log/cron 计划任务日志 /var/log/dmesg 系统引导日志 /var/log/maillog 邮件系统日志 /var/log/secure 记录与访问限制相关日志 /var/log/yum.log 使用yum安装软件的日志 ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:3:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"常见Linux开机设置文件 /etc/fstab 实现开机自动挂载 /etc/initab 定义开机进入默认级别的配置文件 /etc/rc.local 定义开机自定义任务的配置文件 ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:4:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"请描述Linux系统优化的12个步骤 1.不用root直接登陆系统改用普通用户登录。 2.禁止ssh远程，可以更改默认远程连接ssh服务及禁止root远程连接。 vi /etc/ssh/sshd_config PermitRootLogin no Port 22 #改为其他端口 重启sshd服务 systemctl restart sshd.service 3.时间同步：定时更新服务器时间 每天12点同步一次。 crontab -e 0 12 * * * * /usr/sbin/ntpdate 192.168.0.1 设置ntp开机启动并启动ntp systemctl enable ntpd systemctl start ntpd 定时任务验证 https://crontab.guru/ 4.关闭selinux及iptables(iptables工作场景如有wan ip,一般要打开，高并发除外) iptables是firewalld的子模块。 systemctl stop firewalld.service 关闭服务 systemctl status firewalld.service 查看服务状态 systemctl disable firewalld.service 设置开机默认关闭防火墙 永久关闭selinux /etc/selinux/config 将SELINUX=enforcing 改为SELINUX=disabled 临时关闭 getenforce 获取状态 setenforce 0 关闭 #0关闭，1开启 5.配置yum更新源，从国内更新下载安装rpm包。 备份 mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup 下载新的 CentOS-Base.repo 到 /etc/yum.repos.d/ wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 或者 curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo 运行yum makecache生成缓存 yum makecache 6.调整文件描述符的数量，进程及文件的打开都会消耗文件描述符。 内核（kernel）利用文件描述符（file descriptor）来访问文件。文件描述符是非负整数。打开现存文件或新建文件时，内核会返回一个文件描述符。读写文件也需要使用文件描述符来指定待读写的文件。通俗来讲，因为linux一切皆文件，所以占用文件描述符超过了系统或者用户要求的最大值，就无法再打开了，文件描述符主要是系统级和用户级。查看方式如下 sysctl -a|grep fs.file-max 查看系统级文件描述符数量 ulimit -n 查看用户级文件描述符数量 用户级限制：ulimit命令看到的是用户级的最大文件描述符限制，也就是说每一个用户登录后执行的程序占用文件描述符的总数不能超过这个限制 系统级限制：sysctl命令与proc文件系统中查看到的数值是一样的，这属于系统级限制，它是限制所有用户打开文件描述符的总数. 修改用户级文件描述符(需要root权限或root用户) vi /etc/security/limits.conf。修改文件描述符，应该注意字段下是否存在nofile字段，如果存在直接修改，不存在在末尾添加保存即可。 * hard nofile 4096 * soft nofile 2048 修改系统级文件描述符(需要root权限或root用户)： vi /etc/sysctl.conf 找到fs.file-max，将fs.file-max值修改，保存即可。 sysctl -p #加载内核参数使修改生效 7.定时自动清理/var/spool/clientmquene/目录垃圾文件，防止节点被占满（c6.4默认没有Sendmail，因此可以不配。） 8.精简开机启动服务(crond、sshd、network、rsyslog) 9.Linux内核参数优化/etc/sysctl.conf，执行sysctl -P生效。 10.更改字符集，支持中文，但是还是建议使用英文，防止乱码问题出现。linux默认编码为utf-8 11.锁定关键系统文件 chattr +i /etc/passwd /etc/shadow /etc/group /etc/gshadow /etc/inittab 处理以上内容后，把chattr改名，就更安全了。 12.清空/etc/issue去除系统及内核版本登录前的屏幕显示。 ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:5:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"请给出查看当前哪些在线用户的Linux命令 w #显示目前系统登录用户 who #显示目前已登陆用户信息 last #列出当前与过去登录系统的用户相关信息 lastlog #检查某特定用户上次登录时间 whoami #打印与当前生效的用户ID关联的用户名 finger #用户信息查找程序 id #显示指定用户或当前用户的用户信息与组信息 ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:6:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"输出重定向相关 /dev/null是特殊的字符设备文件，表示黑洞设备或空设备 \u003e或者1\u003e #输出重定向：把前面输出的东西输入到后面的文件中，会删除文件原有内容。 \u003e\u003e或者1\u003e\u003e #追加重定向：把前面输出的东西追加到后边的文件中，不会删除文件原有内容。 \u003c或者\u003c0 #输入重定向：输入重定向用于改变命令的输入，指定输入内容那个，后跟文件名。 \u003c\u003c或者\u003c\u003c0 #输入重定向：后跟字符串，用来表示“输入结束”，也可以用ctrl+d来结束输入。 2\u003e #错误重定向：把错误信息输入到后边的文件中，会删除文件原有内容。 2\u003e\u003e #错误追加重定向：把错误信息追加到后边的文件中，不会删除文件原有内容。 标准输入（stdin）: 0 使用 \u003c或者\u003c\u003c 标准输出（stdout）: 1 使用 \u003e或者\u003e\u003e。正常的输出 标准错误输出（stderr）:2 使用2\u003e 或者2\u003e\u003e 特殊： 2\u003e\u00261 就是把标准错误重定向到标准输出（\u003e\u0026） \u003e/dev/null 2\u003e\u00261 等价于1\u003e/dev/null 2\u003e/dev/null 例如：找到文件，忽略错误输出结果。 find / -name python3.6 2\u003e/dev/null /usr/bin/python3.6 /usr/lib/python3.6 /usr/lib64/python3.6 /usr/local/lib/python3.6 /usr/local/lib64/python3.6 ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:7:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"sed常见用法 删除文件ra.txt的第2行内容。 sed -i '2d' ra.txt 将文件yb.txt中的5555改为8080 sed -i 's/5555/8080/g' yb.txt 使用-e同时更改多个文件。 sed -i -e 's/6666/9999/g' a.txt b.txt ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:8:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"$0、dirname和、basename有什么作用？具体举个例子。 ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:9:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"z.sh文件 #!/bin/bash echo \"#############\" echo \"# this is '$0' test#\" echo \"#############\" echo $0 echo echo \"###############\" echo \"# this is 'dirname' test#\" echo \"############@@#\" cd `dirname $0` \u0026\u0026 pwd echo echo \"###############\" echo \"# this is 'basename' test#\" echo \"####################\" echo `basename $0` 执行结果 ############# # this is 'z.sh' test# ############# z.sh ############### # this is 'dirname' test# ############@@# /tmpdisk ############### # this is 'basename' test# #################### z.sh 总结： dirname获取脚本路径名 basename获取脚本名 $0获取脚本名和脚本路径名 ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:10:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"用nohup把一个脚本放后台运行 nohup sh test.sh \u003e filename 2\u003e\u00261 \u0026 ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:11:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"有1-9的数字，echo输出1-9的数字时，屏蔽0-5数字再输出 echo '1234567890' | sed 's/[0-5]//g' ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:12:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["问题"],"content":"如何用wget和curl监控web是否正常 wget 常用命令参数 --spider 模拟爬虫的行为去访问网站，但不会下载网页 -q --quite 安静的访问，禁止输出，类似-o /dev/null -o --output-file=FILE 记录到输出文件 -T --timeout=SECONDS 访问网站的超时时间 -t -tries=NUMBER 重试次数 curl 常用命令参数 -I/--header　显示响应头信息 -m/--max-time\u003cseconds\u003e 访问超时时间 -o/--output\u003cfile\u003e 记录访问信息到文件 -s/--silent 静默模式访问，不输出信息 -w/--write-output\u003cformat\u003e 以固定格式输出，例如%{http_code},输出状态码 wget [root@43f873a76b81 tmpdisk]# wget -T 5 -q -t 2 --spider www.qq.com [root@43f873a76b81 tmpdisk]# echo $? 0 curl [root@43f873a76b81 tmpdisk]# curl -o /dev/null -s -w %{http_code} https://www.baidu.com 200 ","date":"2022-03-28","objectID":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/:13:0","tags":["常见问题"],"title":"常见问题总结","uri":"/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"},{"categories":["编程"],"content":"面向过程与面向对象 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:1:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"面向过程 核心就是过程二字，过程即解决问题的步骤，就是先干什么再干什么 基于该思想写程序就好比在设计一条流水线，是一种机械式的思维方式 优点：复杂的过程流程化，进而简单化 缺点：扩展性差 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:1:1","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"面向对象 核心是对象二字，对象是特征与技能的结合体 基于该思想编写程序就好比在创造一个世界，世界是由一个个对象组成的，是一种“上帝式” 的思维方式 优点：可拓展性强 缺点：编程复杂高，容易出现过度设计 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:1:2","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"类 对象是特征与技能的结合体，类就是一系列对象相似的特征与技能的结合体。 在现实世界中：一定是现有的一个个具体存在的对象，后总结出的类。 在程序中：一定保证先定义类，后产生对象。 类体代码在类的定义阶段就会立刻执行。 在程序中特征用变量标识，技能用函数标识。 因而类中最常见的无非是：变量和函数的定义 Student是类名，school是特征，def定义的函数都是技能。 class Student: school = 'taiyang' def learn(self): print('is learning') def sleep(self): print('is sleeping') def choose_course(self): print('choose course') print(Student.__dict__) 查看 print(Student.school) #数据属性是所有对象共享的 print(Student.learn) #函数属性是绑定给对象用的 新增 Student.country = 'china' print(Student.country) 删除 del Student.country print(Student.country) 注意 类中可以有任意python代码，这些代码在类定义阶段便会执行 因而会产生新的名称空间，用来存放类的变量名与函数名，可以通过Student.__dict__查看 对于经典类来说我们可以通过该字典操作类名称空间的名字（新式类有限制），但python为我们提供专门的.语法。 点是访问属性的语法，类中定义的名字，都是类的属性。 程序中类的用法 .专门用来访问属性，本质操作的就是__dict__ Student.school 等于经典类的操作Student.__dict__['school'] Student.school='taiyang'等于经典类的操作Student.__dict__['school']=‘taiyang’ Student.x=1等于经典的类的操作Student.__dict__['x']=1 del Student.x等于经典的类的操作Student.__dict__.pop('x') python中类内置的特殊属性 类名.__name__# 类的名字(字符串) 类名.__doc__# 类的文档字符串 类名.__base__# 类的第一个父类(在讲继承时会讲) 类名.__bases__# 类所有父类构成的元组(在讲继承时会讲) 类名.__dict__# 类的字典属性 类名.__module__# 类定义所在的模块 类名.__class__# 实例对应的类(仅新式类中) ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:1:3","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"如何绑定到对象独有特征？ 调用类的过程又称为实例化 得到一个返回值，即对象，该对象是一个空对象。 示例： 改写： class Student: school = 'taiyang' def __init__(self, name, sex, age): #在调用类时会自动触发执行。 self.Name = name self.Sex = sex self.Age = age def learn(self): print('is learning') def sleep(self): print('is sleeping') def choose_course(self): print('choose course') #实例化三个对象 stu1 = Student('jack', '男', 18) stu2 = Student('smith', '男', 28) stu3 = Student('john', '女', 30) #调用对象特有属性。 print(stu1.Name) #jack print(stu2.Name) #smith ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:2:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"属性查找与绑定方法 class Student: school = 'taiyang' def learn(self, x, y): print('%s is learning' %self.Name) print(x, y) def sleep(self): print('is sleeping') def choose_course(self): print('choose course') def __init__(self, name, sex, age): self.Name = name self.Sex = sex self.Age = age #1.查找一个对象的属性顺序是：先找对象自己的__dict__，再找类的__dict__。 stu1 = Student('jack', '男', 18) stu2 = Student('smith', '男', 28) stu3 = Student('john', '女', 30) print(stu1.__dict__) #{'Name': 'jack', 'Sex': '男', 'Age': 18} print(stu1.Name, stu1.Age, stu1.Sex) #jack 18 男 #2.类的数据属性是所有对象共享，所有对象都指向同一个内存地址。 print(Student.school, id(Student.school)) #taiyang 2061253245552 print(stu1.school, id(stu1.school)) #taiyang 2061253245552 print(stu2.school, id(stu2.school)) #taiyang 2061253245552 print(stu3.school, id(stu3.school)) #taiyang 2061253245552 #3.类中定义的函数是绑定给对象使用的。 # 不同对象就是不同绑定方法。 # 绑定给谁，就应该由谁来调用,谁来调用就会把谁当作第一个参数传给对应的函数。 print(Student.learn) #\u003cfunction Student.learn at 0x0000026B2F04F9D0\u003e print(stu1.learn) #\u003cbound method Student.learn of \u003c__main__.Student object at 0x0000026B2F05EFD0\u003e\u003e print(stu2.learn) #\u003cbound method Student.learn of \u003c__main__.Student object at 0x00000227AB11EF10\u003e\u003e print(stu3.learn) #\u003cbound method Student.learn of \u003c__main__.Student object at 0x00000227AB11ED00\u003e\u003e stu1.learn(1, 2) #等于Student.learn(stu1, 1, 2) stu2.learn(3, 4) stu3.learn(5, 6) 解析： stu1.learn #stu1对象绑定公共函数属性learn Student.learn #Student类访问公共函数属性learn 它们都可以加括号访问公共函数属性learn python中一切皆为对象，且python3中类与类型是一个概念，类型就是类。 #类型dict就是类dict \u003e\u003e\u003e list \u003cclass 'list'\u003e #实例化的到3个对象l1,l2,l3 \u003e\u003e\u003e l1=list() \u003e\u003e\u003e l2=list() \u003e\u003e\u003e l3=list() #三个对象都有绑定方法append,是相同的功能,但内存地址不同 \u003e\u003e\u003e l1.append \u003cbuilt-in method append of list object at 0x10b482b48\u003e \u003e\u003e\u003e l2.append \u003cbuilt-in method append of list object at 0x10b482b88\u003e \u003e\u003e\u003e l3.append \u003cbuilt-in method append of list object at 0x10b482bc8\u003e #操作绑定方法l1.append(3),就是在往l1添加3,绝对不会将3添加到l2或l3 \u003e\u003e\u003e l1.append(3) \u003e\u003e\u003e l1 [3] \u003e\u003e\u003e l2 [] \u003e\u003e\u003e l3 [] #调用类list.append(l3,111)等同于l3.append(111) \u003e\u003e\u003e list.append(l3,111) #l3.append(111) \u003e\u003e\u003e l3 [111] ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:3:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"对象之间的交互 小练习: class Garen: #定义英雄盖伦的类，不同的玩家可以用它实例出自己英雄; camp = 'demacia' #所有玩家的英雄(盖伦)的阵营都是Demacia; def __init__(self,nickname,life_value,aggresivity): self.nickname=nickname #为自己的盖伦起个别名; self.life_value=life_value #英雄都有自己的生命值; self.aggresivity=aggresivity #英雄都有自己的攻击力; def attack(self,enemy): enemy.life_value-=self.aggresivity #根据自己的攻击力，攻击敌人就减掉敌人的生命值。 class Riven: camp = 'Noxus' #所有玩家的英雄(锐雯)的阵营都是Noxus; def __init__(self,nickname,life_value,aggresivity): self.nickname=nickname #为自己的锐雯起个别名; self.life_value=life_value #英雄都有自己的生命值; self.aggresivity=aggresivity #英雄都有自己的攻击力; def attack(self,enemy): #普通攻击技能，enemy是敌人; enemy.life_value-=self.aggresivity #根据自己的攻击力，攻击敌人就减掉敌人的生命值。 def fire(self,enemy): enemy.life_value-=100 #实例出俩英雄 g1=Garen('草丛猥琐男', 1000,100) r1=Riven('猛男雯雯',200,500) #交互 print(r1.life_value) #攻击之前锐雯血量 200 g1.attack(r1) #盖伦攻击锐雯 print(r1.life_value) #攻击之后锐雯剩余血量 100 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:4:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"总结 1.站的角度不同，定义出的类是截然不同的 2.现实中的类并不完全等于程序中的类，比如现实中的公司类，在程序中有时需要拆分成部门类，业务类。 3.有时为了编程需求，程序中也可能会定义现实中不存在的类，比如策略类，现实中并不存在，但是在程序中却是一个很常见的类。 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:5:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"从代码级别看面向对象 #在没有学习类这个概念时，数据与功能是分离的 def exc1(host,port,db,charset): conn=connect(host,port,db,charset) conn.execute(sql) return xxx def exc2(host,port,db,charset,proc_name) conn=connect(host,port,db,charset) conn.call_proc(sql) return xxx #每次调用都需要重复传入一堆参数 exc1('127.0.0.1',3306,'db1','utf8','select * from tb1;') exc2('127.0.0.1',3306,'db1','utf8','存储过程的名字') #我们能想到的解决方法是，把这些变量都定义成全局变量. HOST=‘127.0.0.1’ PORT=3306 DB=‘db1’ CHARSET=‘utf8’ def exc1(host,port,db,charset): conn=connect(host,port,db,charset) conn.execute(sql) return xxx def exc2(host,port,db,charset,proc_name) conn=connect(host,port,db,charset) conn.call_proc(sql) return xxx exc1(HOST,PORT,DB,CHARSET,'select * from tb1;') exc2(HOST,PORT,DB,CHARSET,'存储过程的名字') 但是2的解决方法也是有问题的，按照2的思路，我们将会定义一大堆全局变量，这些全局变量并没有做任何区分，即能够被所有功能使用，然而事实上只有HOST，PORT，DB，CHARSET是给exc1和exc2这两个功能用的。言外之意：我们必须找出一种能够将数据与操作数据的方法组合到一起的解决方法，这就是我们说的类了. class MySQLHandler: def __init__(self,host,port,db,charset='utf8'): self.host=host self.port=port self.db=db self.charset=charset def exc1(self,sql): conn=connect(self.host,self.port,self.db,self.charset) res=conn.execute(sql) return res def exc2(self,sql): conn=connect(self.host,self.port,self.db,self.charset) res=conn.call_proc(sql) return res obj=MySQLHandler('127.0.0.1',3306,'db1') obj.exc1('select * from tb1;') obj.exc2('存储过程的名字') #改进 class MySQLHandler: def __init__(self,host,port,db,charset='utf8'): self.host=host self.port=port self.db=db self.charset=charset self.conn=connect(self.host,self.port,self.db,self.charset) def exc1(self,sql): return self.conn.execute(sql) def exc2(self,sql): return self.conn.call_proc(sql) obj=MySQLHandler('127.0.0.1',3306,'db1') obj.exc1('select * from tb1;') obj.exc2('存储过程的名字') ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:6:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"继承与派生 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:7:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"什么是继承？ 继承是一种创建新类的方式，新建的类可以继承一个或多个父类（python支持多继承），父类又可称作基类或超类，新建的类称为派生类或子类。 子类会“遗传”父类的属性，从而解决代码重用的问题。 python中类的继承分为：单继承和多继承 class ParentClass1: #定义父类 pass class ParentClass2: #定义父类 pass class SubClass1(ParentClass1): #单继承，基类是ParentClass1，派生类是SubClass pass class SubClass2(ParentClass1,ParentClass2): #python支持多继承，用逗号分隔开多个继承的类 pass ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:7:1","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"查看继承 SubClass1.__bases__ #__base__只查看从左到右继承的第一个子类，__bases__则是查看所有继承的父类 (\u003cclass '__main__.ParentClass1'\u003e,) SubClass2.__bases__ (\u003cclass '__main__.ParentClass1'\u003e, \u003cclass '__main__.ParentClass2'\u003e) 提示：如果没有指定基类，python的类会默认继承object类，object是所有python类的基类，他提供了一些常见的方法（如__str__）的实现。 ParentClass1.__bases__ (\u003cclass 'object'\u003e,) ParentClass2.__bases__ (\u003cclass 'object'\u003e,) ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:7:2","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"经典类与新式类 在python2 中类分为两种： 1.经典类: 指的是没有继承object类的类，以及该类的子类。 2.新式类：指的是继承object类的类，以及该类的子类。 在python3中类统一为新式类 继承描述的是子类和父类之间的关系，是一种什么是什么的关系。要找出这种关系，必须先抽象再继承。 抽象即抽取类似或者说比较像的部分。 继承：是基于抽象的结果，通过编程语言去实现它，肯定是先经历抽象这个过程，才能通过继承的方式去表达出抽象的结构。 抽象只是分析和设计的过程中，一个动作或者说一种技巧，通过抽象可以得到类。 在开发程序的过程中，如果我们定义了一个类A，然后又想新建立另外一个类B，但是类B的大部分内容与类A的相同时 我们不可能从头开始写一个类B，这就用到了类的继承的概念。 通过继承的方式新建类B，让B继承A，B会‘遗传’A的所有属性(数据属性和函数属性)，实现代码重用。 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:7:3","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"练习 定义两个类Student类和Teacher类，都有相同的数据属性（都在同一个学校），也有相同的函数属性。姓名、性别、年龄。 class Student: school='qinghua' def __init__(self, name, sex, age): self.name=name self.sex=sex self.age=age def learn(self): print('%s is learing'%self.name) class Teacher: school='qinghua' def __init__(self, name, sex, age): self.name=name self.sex=sex self.age=age def teach(self): print('%s is teaching'%self.name) 使用继承，把相同部分提取出来，单独做成父类。学生和老师类都作为子类继承父类的所有属性。 class People: school='qinghua' def __init__(self, name, sex, age): self.name=name self.sex=sex self.age=age class Student(People): def learn(self): print('%s is learing'%self.name) class Teacher(People): def teach(self): print('%s is teaching'%self.name) #初始化 stu1=Student('jack','man',18) teacher1=Teacher('john','woman',20) #Student和Teacher作为子类继承了父类People类的所有属性。可以直接调用。 print(stu1.__dict__) {'name': 'jack', 'sex': 'man', 'age': 18} ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:7:4","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"派生 当在父类中找不到所需的属性时，子类可以定义属于自己的特征。 class People: school='qinghua' def __init__(self, name, sex, age): self.name=name self.sex=sex self.age=age def tell_info(self): print('\u003c名字:%s 性别:%s 年龄:%s\u003e '%(self.name, self.sex, self.age)) class Student(People): def learn(self): print('%s is learing'%self.name) def tell_info(self): print(\"我是学生:\", end='') print('\u003c名字:%s 性别:%s 年龄:%s\u003e '%(self.name,self.sex,self.age)) class Teacher(People): def teach(self): print('%s is teaching'%self.name) def tell_info(self): print(\"我是老师:\", end='') print('\u003c名字:%s 性别:%s 年龄:%s\u003e '%(self.name,self.sex,self.age)) #初始化 stu1=Student('jack','man',18) teacher1=Teacher('john','woman',20) #调用tell_info()函数属性 stu1.tell_info() teacher1.tell_info() 我是学生:\u003c名字:jack 性别:man 年龄:18\u003e 我是老师:\u003c名字:john 性别:woman 年龄:20\u003e tell_info函数属性查找顺序 stu1对象自己有没有--\u003estu1所在的类（Student）有没有--\u003e发现有直接调用。 如果没有--\u003e查找父类（People）有没有（有直接调用，没有直接抛出异常） 异常：AttributeError: 'Student' object has no attribute 'tell_info' ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:7:5","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"子类重用父类方法 在子类派生出的新方法中，往往需要重用父类的方法，我们有两种实现方式： 1.“指名道姓”，即父类名.父类方法()跟继承没关系。和函数调用类似。 Student类中除了继承父类的name sex age 方法之外，还派生出自己的新方法course stu_id class People: school = 'qinghua' def __init__(self, name, sex, age): self.name = name self.sex = sex self.age = age def tell_info(self): print('\u003c名字:%s 性别:%s 年龄:%s\u003e '%(self.name, self.sex, self.age)) class Student(People): def __init__(self, name, sex, age, course, stu_id): People.__init__(self, name, sex, age) self.course = course self.stu_id = stu_id def learn(self): print(\"%s is learning.\"%(self.name)) def tell_info(self): print(\"我是学生: \", end='') People.tell_info(self) stu1 = Student('jack', 'man', 18,'python',1) stu1.tell_info() #结果 我是学生: \u003c名字:jack 性别:man 年龄:18\u003e 2.使用super()，依赖于继承。依循mro列表从当前类的下一个类开始查找。 在python2中super(自己的类名, self)，而在python3中super()函数中可以不传参。 class People: school = 'qinghua' def __init__(self, name, sex, age): self.name = name self.sex = sex self.age = age def tell_info(self): print('\u003c名字:%s 性别:%s 年龄:%s\u003e '%(self.name, self.sex, self.age)) class Student(People): def __init__(self, name, sex, age, course, stu_id): super(Student, self).__init__(name, sex, age) self.course = course self.stu_id = stu_id def learn(self): print(\"%s is learning.\"%(self.name)) def tell_info(self): print(\"我是学生: \", end='') super(Student, self).tell_info() stu1 = Student('jack', 'man', 18,'python',1) stu1.tell_info() #结果 我是学生: \u003c名字:jack 性别:man 年龄:18\u003e 示例。问结果是什么？ class Foo: def f2(self): print(\"======\u003ef2\") def f1(self): print('Foo f1') super().f2() class Bar: def f2(self): print('Bar f2') class Sub(Foo, Bar): pass s=Sub() s.f1() 解析： 先查看子类Sub()的mro方法 print(Sub.mro()) #[\u003cclass '__main__.Sub'\u003e, \u003cclass '__main__.Foo'\u003e, \u003cclass '__main__.Bar'\u003e, \u003cclass 'object'\u003e] 寻找f1()时的顺序 对象s-\u003e对象所在类Sub-\u003e类Sub左侧父类Foo-\u003e找到f1(),并打印'Foo f1'。遇到super()，super()遵循mro列表继续查找f2().当前在Foo类。-\u003e找到Foo下一个类Bar中有f2方法，打印'Bar f2'-\u003e查找结束 #最终结果 Foo f1 Bar f2 即使super()所在类中有同名函数属性f2()也不会调用，只会调用当前所在类的下一个类中的方法。 即使没有直接继承关系，`super`仍然会按照`mro`继续往后查找。这就是为什么super所在的类有同名的f2函数也不会调用的原因。 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:8:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"组合与重用 组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合。 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:9:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"继承与组合的区别 继承：什么是什么 组合：什么有什么 组合示例1 class People: school = 'qinghua' def __init__(self, name, sex, age): self.name = name self.sex = sex self.age = age def tell_info(self): print('\u003c名字:%s 性别:%s 年龄:%s\u003e '%(self.name, self.sex, self.age)) class Student(People): def __init__(self, name, sex, age, course, stu_id): People.__init__(self, name, sex, age) self.course = course self.stu_id = stu_id def learn(self): print(\"%s is learning.\"%(self.name)) def tell_info(self): print(\"我是学生: \", end='') People.tell_info(self) class Teacher(People): def __init__(self, name, sex, age, level, salary): People.__init__(self, name, sex, age) self.level = level self.salary = salary def teach(self): print(\"%s is teaching.\"%(self.name)) def tell_info(self): print('我是老师：', end='') People.tell_info(self) class Date: def __init__(self, year, mon, day): self.year = year self.mon = mon self.day = day def tell_info(self): print('出生日期是:\u003c%s-%s-%s\u003e'%(self.year, self.mon, self.day)) stu1 = Student('jack', 'man', 18,'python',1) date_obj1 = Date(1995, 10, 2) stu1.birth = date_obj1 teacher1 = Teacher('smith', 'women', 20, 10, 4000) date_obj2 = Date(1980, 1, 1) teacher1.birth = date_obj2 stu1.birth.tell_info() teacher1.birth.tell_info() 解析： Teacher类和Stuent类都有共同的属性生日，所以单独创建Date类。 #初始化Date类 date_obj1 = Date(1995, 10, 2) #学生1的生日是date_obj1 stu1.birth = date_obj1 #调用学生1的tell_info方法 stu1.birth.tell_info() 组合示例2 class People: def __init__(self,name,age,sex): self.name=name self.age=age self.sex=sex class Course: def __init__(self,name,period,price): self.name=name self.period=period self.price=price def tell_info(self): print('\u003c%s %s %s\u003e' %(self.name,self.period,self.price)) class Teacher(People): def __init__(self,name,age,sex,job_title): People.__init__(self,name,age,sex) self.job_title=job_title self.course=[] self.students=[] class Student(People): def __init__(self,name,age,sex): People.__init__(self,name,age,sex) self.course=[] eg=Teacher('eg',18,'male','霸道金牌讲师') s1=Student('牛二',18,'female') python=Course('python','3mons',3000.0) linux=Course('linux','3mons',3000.0) #为老师eg和学生s1添加课程 eg.course.append(python) eg.course.append(linux) s1.course.append(python) #为老师eg添加学生s1 eg.students.append(s1) #查看老师的课程 for obj in eg.course: obj.tell_info() #结果 \u003cpython 3mons 3000.0\u003e \u003clinux 3mons 3000.0\u003e #查看学生的课程 for i in s1.course: i.tell_info() #结果 \u003cpython 3mons 3000.0\u003e 解析: 学生选课之前课程为空，课程有Python和Linux可以选择，学生选择Python。为学生分配导师，最后查看学生所选的课程。 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:9:1","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"抽象类 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:10:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"什么是抽象类？ 抽象类是一个特殊类，只能被继承不能实例化。 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:10:1","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"为什么要有抽象类？ 如果说类是从一堆对象中抽取相同的内容而来的，那么抽象类就是从一类中抽取相同的内容而来的，内容包括数据属性和函数属性。 从实现角度来看，抽象类与普通类的不同之处在于：抽象类中只能有抽象方法（没有实现功能），该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的。 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:10:2","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"在python中实现抽象类 import abc class Animal(metaclass=abc.ABCMeta): @abc.abstractmethod def eat(self): pass @abc.abstractmethod def run(self): pass class People(Animal): pass class pig(Animal): pass peol=People() #TypeError: Can't instantiate abstract class People with abstract methods eat, run 解析： 引用abc模块实现java中接口功能。抽象化（Animal）类下面的子类必须使用父类（Animal）定义好的功能，名称也不能改。 要在抽象类中定义抽象方法，我们必须使用装饰器：@abstractmethod。内置abc模块包含这两者。 作用是强制子类来使用定义好的功能。 如果子类不使用抽象类中定义的功能，将不能进行实例化。异常如上段代码所示。 定义好功能后就能实例化正常调用了。 import abc class Animal(metaclass=abc.ABCMeta): @abc.abstractmethod def eat(self): pass @abc.abstractmethod def run(self): pass class People(Animal): def eat(self): print(\"He is eatting\") def run(self): print(\"He is running\") class pig(Animal): pass peol=People() #实例化 peol.eat() #调用eat()。He is eatting peol.run() #调用run()。He is running Linux中一切皆文件。用抽象类定义一套模板。 import abc class File(metaclass=abc.ABCMeta): @abc.abstractmethod def read(self): pass def write(self): pass class Disk(File): def read(self): print(\"disk read\") def write(self): print(\"disk write\") class Process(File): def read(self): print(\"process read\") def write(self): print(\"process write\") d=Disk p=Process d.read() d.write() ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:10:3","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"继承的原理 属性的查找有两种方法：深度优先和广度优先。 python2中默认是经典类（深度优先），而python3中默认是新式类（广度优先）。 class A(object): def test(self): print('from A') class B(A): def test(self): print('from B') class C(A): def test(self): print('from C') class D(B): def test(self): print('from D') class E(C): def test(self): print('from E') class F(D,E): # def test(self): # print('from F') pass f1=F() f1.test() print(F.__mro__) #只有新式才有这个属性可以查看线性列表，经典类没有这个属性 #(\u003cclass '__main__.F'\u003e, \u003cclass '__main__.D'\u003e, \u003cclass '__main__.B'\u003e, \u003cclass '__main__.E'\u003e, \u003cclass '__main__.C'\u003e, \u003cclass '__main__.A'\u003e, \u003cclass 'object'\u003e) #新式类继承顺序:F-\u003eD-\u003eB-\u003eE-\u003eC-\u003eA #经典类继承顺序:F-\u003eD-\u003eB-\u003eA-\u003eE-\u003eC #python3中统一都是新式类 #pyhon2中才分新式类与经典类 为了实现继承,python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。 而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则: 1.子类会先于父类被检查 2.多个父类会根据它们在列表中的顺序被检查 3.如果对下一个类存在两个合法的选择,选择第一个父类。（查找顺序都是从左到右） ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:11:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"多态与多态性 ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:12:0","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"什么是多态？ 同一种事物的不同形态。如：水。有水蒸气、冰、还有液态水三种形态。 peo=People() dog=Dog() pig=Pig() #peo、dog、pig都是动物,只要是动物肯定有talk方法 #于是我们可以不用考虑它们三者的具体是什么类型,而直接使用 peo.talk() dog.talk() pig.talk() #更进一步,我们可以定义一个统一的接口来使用 def func(obj): obj.talk() ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:12:1","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"多态的好处 1.增加了程序的灵活性 以不变应万变，不论对象千变万化，使用者都是同一种形式去调用，如func(animal) 2.增加了程序额可扩展性 通过继承animal类创建了一个新的类，使用者无需更改自己的代码，还是用func(animal)去调用。 \u003e\u003e\u003e class Cat(Animal): #属于动物的另外一种形态：猫 ... def talk(self): ... print('say miao') ... \u003e\u003e\u003e def func(animal): #对于使用者来说，自己的代码根本无需改动 ... animal.talk() ... \u003e\u003e\u003e cat1=Cat() #实例出一只猫 \u003e\u003e\u003e func(cat1) #甚至连调用方式也无需改变，就能调用猫的talk功能 say miao ''' 这样我们新增了一个形态Cat，由Cat类产生的实例cat1，使用者可以在完全不需要修改自己代码的情况下。使用和人、狗、猪一样的方式调用cat1的talk方法，即func(cat1) ''' ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:12:2","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"鸭子类型 Python崇尚鸭子类型，即‘如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子’ python程序员通常根据这种行为来编写程序。例如，如果想编写现有对象的自定义版本，可以继承该对象 也可以创建一个外观和行为像，但与它无任何关系的全新对象，后者通常用于保存程序组件的松耦合度。 例1：利用标准库中定义的各种‘与文件类似’的对象，尽管这些对象的工作方式像文件，但他们没有继承内置文件对象的方法. #二者都像鸭子,二者看起来都像文件,因而就可以当文件一样去用 class TxtFile: def read(self): pass def write(self): pass class DiskFile: def read(self): pass def write(self): pass 例2：其实大家一直在享受着多态性带来的好处，比如Python的序列类型有多种形态：字符串，列表，元组，多态性体现如下 #str,list,tuple都是序列类型 s=str('hello') l=list([1,2,3]) t=tuple((4,5,6)) #我们可以在不考虑三者类型的前提下使用s,l,t s.__len__() l.__len__() t.__len__() len(s) len(l) len(t) ","date":"2022-03-27","objectID":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/:12:3","tags":["python"],"title":"类和对象","uri":"/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"},{"categories":["编程"],"content":"什么是序列化？ 我们把对象（变量）从内存中变成可存储或传输的过程称之为序列化。在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。 ","date":"2022-03-26","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:1:0","tags":["python"],"title":"序列化与反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["编程"],"content":"为什么要序列化？ 持久保存状态 内存是无法永久保存数据的，当程序运行了一段时间，我们断电或者重启程序，内存中关于这个程序的之前一段时间的数据（有结构）都被清空了。在断电或重启程序之前将程序当前内存中所有的数据都保存下来（保存到文件中），以便于下次程序执行能够从文件中载入之前的数据，然后继续执行，这就是序列化。 跨平台数据交互 序列化之后，不仅可以把序列化后的内容写入磁盘，还可以通过网络传输到别的机器上，如果收发的双方约定好实用一种序列化的格式，那么便打破了平台/语言差异化带来的限制，实现了跨平台数据交互。 反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 ","date":"2022-03-26","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:2:0","tags":["python"],"title":"序列化与反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["编程"],"content":"如何序列化之json和pickle json反序列化 如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下： json类型 python类型 {} dic [] list “string” str 1234.56 int或float true/false True/False null None 内存中结构化的数据-\u003e格式json-\u003e字符串-\u003e保存到文件中或基于网络传输 序列化 python-\u003ejson json.dumps() json.dump() 反序列化 json-\u003epython json.loads() json.load() ","date":"2022-03-26","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:3:0","tags":["python"],"title":"序列化与反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["编程"],"content":"练习 需求1 把user = {'name': 'jack', 'age': 20, 'sex': 'male'}序列化。保存为user_new.json 序列化 #1.使用dumps import json user = {'name': 'jack', 'age': 20, 'sex': 'male'} with open('user_new.json', 'w', encoding='utf-8') as f: f.write(json.dumps(user)) #结果 {\"name\": \"jack\", \"age\": 20, \"sex\": \"male\"} #2.使用dump import json user = {'name': 'jack', 'age': 20, 'sex': 'male'} json.dump(user, open('user_new.json', 'w', encoding='utf-8')) 使用dumps和使用dump效果一样。 需求2： 把刚刚序列化后的文件user_new.json反序列化，并查询key所对应的值。 #使用loads反序列化 import json with open('user_new.json', 'r', encoding='utf-8') as f: user=json.loads(f.read()) print(user['name']) #结果：jack #使用load反序列化 import json user=json.load(open('user_new.json', 'r', encoding='utf-8')) print(user['name']) #结果：jack 以上都是序列化和反序列化文件，自定义的字符串能不能进行序列化和反序列化？ s = '{\"Name\": \"jack\", \"Hobby\": \"play\", \"age\": 20}' print(json.loads(s)) #结果 {'Name': 'jack', 'Hobby': 'play', 'age': 20} 注意 import json dct=\"{'1':111}\"#json 不认单引号 dct=str({\"1\":111})#报错,因为生成的数据还是单引号:{'one': 1} dct='{\"1\":\"111\"}' print(json.loads(dct)) 总结 无论数据是怎样创建的，只要满足json格式，就可以json.loads出来,不一定非要dumps的数据才能loads ","date":"2022-03-26","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:3:1","tags":["python"],"title":"序列化与反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["编程"],"content":"pickle反序列化 json并不是所有类型的数据都能序列化。比如集合类型，这时候需要使用pickle模块了。 pickle会把所有类型转换成bytes类型。 Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。 s={1,2,3,4,5} print(pickle.dumps(s)) #结果 b'\\x80\\x04\\x95\\x0f\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8f\\x94(K\\x01K\\x02K\\x03K\\x04K\\x05\\x90.' 将集合存入文件再序列化 import pickle s = {1, 2, 3, 4, 5} #方式1 with open('s.plk', 'wb') as f: f.write(pickle.dumps(s)) #方式2 pickle.dump(s, open('s.plk', 'wb')) 反序列化文件 import pickle #方式1 with open('s.plk', 'rb') as f: s = pickle.loads(f.read()) print(s) #方式2 s = pickle.load(open('s.plk', 'rb')) print(s) ","date":"2022-03-26","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:4:0","tags":["python"],"title":"序列化与反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["编程"],"content":"shelve模块 shelve模块比pickle模块简单，只有一个open函数，返回类似字典的对象，可读可写;key必须为字符串，而值可以是python所支持的数据类型 打开一个文件的同时会创建3个同名文件。.bak .dat .dir结尾。 #创建 import shelve f = shelve.open('db.sh1') f['stu1']={'name':'jack','age':20} f.close() #查询 print(f['stu1']['name']) ","date":"2022-03-26","objectID":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/:5:0","tags":["python"],"title":"序列化与反序列化","uri":"/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"categories":["编程"],"content":"日志模块角色 1.Logger:产生日志 2.Filter:几乎不用 3.Handler: 接收Logger传过来的日志，进行日志格式化，可以打印到终端，也可以打印到文件 4.Formatter：日志格式 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:1:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"日志模块相关说明 可在logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有. filename：用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。 filemode：文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。 format：指定handler使用的日志显示格式。 datefmt：指定日期时间格式。 level：设置rootlogger的日志级别 stream：用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:2:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"format参数中可能用到的格式化串 %(name)s Logger的名字 %(levelno)s 数字形式的日志级别 %(levelname)s 文本形式的日志级别 %(pathname)s 调用日志输出函数的模块的完整路径名，可能没有 %(filename)s 调用日志输出函数的模块的文件名 %(module)s 调用日志输出函数的模块名 %(funcName)s 调用日志输出函数的函数名 %(lineno)d 调用日志输出函数的语句所在的代码行 %(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示 %(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数 %(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒 %(thread)d 线程ID。可能没有 %(threadName)s 线程名。可能没有 %(process)d 进程ID。可能没有 %(message)s用户输出的消息 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:2:1","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"日志打印实现过程 import logging #1.Logger:产生日志 logger1=logging.getLogger('访问日志') #2.Handler: 接收Logger传过来的日志，进行日志格式化，可以打印到终端，也可以打印到文件 sh=logging.StreamHandler() #打印到终端 fh1=logging.FileHandler('s1.log', encoding='utf-8') #打印到文件 fh2=logging.FileHandler('s2.log', encoding='utf-8') #3.Formatter：日志格式 formatter1=logging.Formatter( fmt='%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p' ) formatter2=logging.Formatter( fmt='%(asctime)s : %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p' ) formatter3=logging.Formatter( fmt='%(asctime)s : %(module)s : %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p' ) #4.为Handler绑定日志格式 sh.setFormatter(formatter1) fh1.setFormatter(formatter2) fh2.setFormatter(formatter3) #5.为logger 绑定handler logger1.addHandler(sh) logger1.addHandler(fh1) logger1.addHandler(fh2) #6.设置日志级别:logger 对象的日志级别应该\u003c=handler的日志级别 #logger1.setLevel(30) logger1.setLevel(10) sh.setLevel(10) fh1.setLevel(10) fh2.setLevel(10) #7.测试 logger1.debug('测试者玩') logger1.info('运行还算正常') logger1.warning('可能要有bug了') logger1.error('不好了，真出bug了') logger1.critical('推到重写') 去注释版 import logging logger1=logging.getLogger('访问日志') sh=logging.StreamHandler() fh1=logging.FileHandler('s1.log', encoding='utf-8') fh2=logging.FileHandler('s2.log', encoding='utf-8') formatter1=logging.Formatter( fmt='%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p' ) formatter2=logging.Formatter( fmt='%(asctime)s : %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p' ) formatter3=logging.Formatter( fmt='%(asctime)s : %(module)s : %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p' ) sh.setFormatter(formatter1) fh1.setFormatter(formatter2) fh2.setFormatter(formatter3) logger1.addHandler(sh) logger1.addHandler(fh1) logger1.addHandler(fh2) #logger1.setLevel(30) logger1.setLevel(10) sh.setLevel(10) fh1.setLevel(10) fh2.setLevel(10) 测试 logger1.debug('测试者玩') logger1.info('运行还算正常') logger1.warning('可能要有bug了') logger1.error('不好了，真出bug了') logger1.critical('推到重写') 结果： s1.log 2022-03-22 20:26:58 PM : 测试者玩 2022-03-22 20:26:58 PM : 运行还算正常 2022-03-22 20:26:58 PM : 可能要有bug了 2022-03-22 20:26:58 PM : 不好了，真出bug了 2022-03-22 20:26:58 PM : 推到重写 s2.log 2022-03-22 20:26:58 PM : my_logging : 测试者玩 2022-03-22 20:26:58 PM : my_logging : 运行还算正常 2022-03-22 20:26:58 PM : my_logging : 可能要有bug了 2022-03-22 20:26:58 PM : my_logging : 不好了，真出bug了 2022-03-22 20:26:58 PM : my_logging : 推到重写 终端 2022-03-26 11:32:48 AM - 访问日志 - INFO - my_logging: 运行还算正常 2022-03-26 11:32:48 AM - 访问日志 - WARNING - my_logging: 可能要有bug了 2022-03-26 11:32:48 AM - 访问日志 - ERROR - my_logging: 不好了，真出bug了 2022-03-26 11:32:48 AM - 访问日志 - CRITICAL - my_logging: 推到重写 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:3:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"日志的继承关系（了解） 练习 import logging #1.Logger:产生日志 logger1=logging.getLogger('root') logger2=logging.getLogger('root.child1') logger3=logging.getLogger('root.child1.child2') #2.Handler: 接收Logger传过来的日志，进行日志格式化，可以打印到终端，也可以打印到文件 sh=logging.StreamHandler() #打印到终端 #3.Formatter：日志格式 formatter1=logging.Formatter( fmt='%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p' ) #4.为Handler绑定日志格式 sh.setFormatter(formatter1) #5.为logger 绑定handler logger1.addHandler(sh) logger2.addHandler(sh) logger3.addHandler(sh) #6.设置日志级别:logger 对象的日志级别应该\u003c=handler的日志级别 #logger1.setLevel(30) logger1.setLevel(10) logger2.setLevel(10) logger3.setLevel(10) sh.setLevel(10) #7.测试 logger1.debug('爷爷') logger2.debug('爸爸') logger3.debug('孙子') 结果 2022-03-22 21:00:30 PM - root - DEBUG - my_logging_child: 爷爷 2022-03-22 21:00:30 PM - root.child1 - DEBUG - my_logging_child: 爸爸 2022-03-22 21:00:30 PM - root.child1 - DEBUG - my_logging_child: 爸爸 2022-03-22 21:00:30 PM - root.child1.child2 - DEBUG - my_logging_child: 孙子 2022-03-22 21:00:30 PM - root.child1.child2 - DEBUG - my_logging_child: 孙子 2022-03-22 21:00:30 PM - root.child1.child2 - DEBUG - my_logging_child: 孙子 去注释版 import logging logger1=logging.getLogger('root') logger2=logging.getLogger('root.child1') logger3=logging.getLogger('root.child1.child2') sh=logging.StreamHandler() formatter1=logging.Formatter( fmt='%(asctime)s - %(name)s - %(levelname)s - %(module)s: %(message)s', datefmt='%Y-%m-%d %H:%M:%S %p' ) sh.setFormatter(formatter1) logger1.addHandler(sh) logger2.addHandler(sh) logger3.addHandler(sh) #logger1.setLevel(30) logger1.setLevel(10) logger2.setLevel(10) logger3.setLevel(10) sh.setLevel(10) 测试 logger1.debug('爷爷') logger2.debug('爸爸') logger3.debug('孙子') ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:4:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"日志模块应用 模拟购物小程序，选择转账时记录日志。 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:5:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"整体项目结构 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:5:1","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"每个目录简单介绍 bin目录：存放用户交互程序 conf目录：设置相关 core：核心功能 db:用户认证相关 lib:常用功能 log：日志文件 README:项目介绍 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:5:2","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"相关源码 start.py import sys, os #print(os.path.abspath(__file__)) #print(os.path.dirname(os.path.abspath(__file__))) #print(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))) BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) sys.path.append(BASE_DIR) from core import src if __name__ == '__main__': src.run() settings.py import os import logging.config BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) LOG_PATH = os.path.join(BASE_DIR, 'log', 'access.log') DB_PATH = os.path.join(BASE_DIR, 'db', 'user') COLLECT_PATH = os.path.join(BASE_DIR, 'log', 'collect.log') print(LOG_PATH) print(DB_PATH) # 定义三种日志输出格式 开始 standard_format = '[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]' \\ '[%(levelname)s][%(message)s]' #其中name为getlogger指定的名字 simple_format = '[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s' id_simple_format = '[%(levelname)s][%(asctime)s] %(message)s' # log配置字典 LOGGING_DIC = { 'version': 1, 'disable_existing_loggers': False, 'formatters': { 'standard': { 'format': standard_format }, 'simple': { 'format': simple_format }, 'id_simple': { 'format': id_simple_format }, }, 'filters': {}, 'handlers': { #打印到终端的日志 'console': { 'level': 'DEBUG', 'class': 'logging.StreamHandler', # 打印到屏幕 'formatter': 'simple' }, #打印到文件的日志,收集info及以上的日志 'default': { 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件 'formatter': 'standard', 'filename': LOG_PATH, # 日志文件 'maxBytes': 1024*1024*5, # 日志大小 5M 'backupCount': 5, 'encoding': 'utf-8', # 日志文件的编码，再也不用担心中文log乱码了 }, 'collect': { 'level': 'DEBUG', 'class': 'logging.handlers.RotatingFileHandler', # 保存到文件 'formatter': 'simple', 'filename': COLLECT_PATH, # 日志文件 'maxBytes': 1024*1024*5, # 日志大小 5M 'backupCount': 5, 'encoding': 'utf-8', # 日志文件的编码，再也不用担心中文log乱码了 }, }, 'loggers': { '': { 'handlers': ['default', 'console', 'collect'], # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕 'level': 'DEBUG', 'propagate': False, # 向上（更高level的logger）传递 }, }, } src.py from lib import common from lib import sql def shop(): print('购物') def check_balance(): print('查看余额....') #res = sql.execute('select balance from user where id=3') #print(res) def transfer_account(): print('转账....') #记录日志 log_msg = 'jack give smith ten yuan' #调用日志功能 loggers = common.logger_handle('transfer_account') loggers.debug(log_msg) def run(): msg = ''' 1.购物 2.查看余额 3.转账 ''' while True: print(msg) choice = input('\u003e\u003e: ').strip() if not choice:continue if choice == '1': shop() elif choice == '2': check_balance() elif choice == '3': transfer_account() user alex,18,male,10000 egon,18,male,1000000 common.py from conf import settings import logging.config # def logger(msg): # with open(settings.LOG_PATH, 'a', encoding='utf-8') as f: # f.write('%s\\n' %msg) def logger_handle(log_name): logging.config.dictConfig(settings.LOGGING_DIC) # 导入上面定义的logging配置 logger = logging.getLogger(log_name) # 生成一个log实例 logger.info('It works!') # 记录该文件的运行状态 sql.py def execute(sql): print('解析') print('执行sql') access.log jack给smith转账了10元 [2022-03-22 22:01:20,767][MainThread:2600][task_id:转账][common.py:10][INFO][It works!] [2022-03-22 22:04:08,963][MainThread:14184][task_id:转账][common.py:10][INFO][It works!] [2022-03-22 22:06:59,656][MainThread:15740][task_id:transfer_account][common.py:10][INFO][It works!] [2022-03-26 11:41:33,154][MainThread:12820][task_id:transfer_account][common.py:10][INFO][It works!] collect.log [INFO][2022-03-22 22:01:20,767][common.py:10]It works! [INFO][2022-03-22 22:04:08,963][common.py:10]It works! [INFO][2022-03-22 22:06:59,656][common.py:10]It works! [INFO][2022-03-26 11:41:33,154][common.py:10]It works! ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:5:3","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"re模块-正则表达式 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:6:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"什么是正则？ 正则就是用一些具有特殊含义的符号组合到一起（称为正则表达式）来描述字符或者字符串的方法。或者说：正则就是用来描述一类事物的规则。（在Python中）它内嵌在Python中，并通过 re 模块实现。正则表达式模式被编译成一系列的字节码，然后由用 C 编写的匹配引擎执行。 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:6:1","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"常用匹配模式(元字符) import re print(re.findall('\\w', 'jack 123 + _ - *')) print(re.findall('\\W', 'jack 123 + _ - *')) print(re.findall('\\s', 'jack\\tn 12\\n3 + _ - *')) print(re.findall('\\S', 'jack\\tn 12\\n3 + _ - *')) print(re.findall('\\d', 'jack\\tn 12\\n3 + _ - *')) print(re.findall('\\D', 'jack\\tn 12\\n3 + _ - *')) print(re.findall('\\n', 'jack\\tn 12\\n3 + _ - *')) print(re.findall('\\t', 'jack\\tn 12\\n3 + _ - *')) print(re.findall('j', 'jack\\tn 12\\n3 + hello _ - *')) print(re.findall('^j', 'jack\\tn 12\\n3 + hello _ - *')) print(re.findall('o$', 'jack\\tn 12\\n3 + _ * hello')) 重复./?/*/+/{m,n}/.*/.*? 点 .能匹配换行符(\\n)以外的任意一个字符 (以a开头的都没匹配上，直到遇到aab符合a.b匹配规则，所以结果是aab) print(re.findall('a.b', 'a1b a b a-b aaaaaaaab')) # ['a1b' ,'a b' , 'a-b', 'aab'] print(re.findall('a.b', 'a1b a b a\\nb aaaaaaaab')) # ['a1b','a b', 'aab'] #a.b print(re.findall('a.b', 'a1b a b a\\nb aaaaaaaab', re.DOTALL)) #['a1b','a b', 'a\\nb','aab'] 问号 ?代表?左边的字符出现0次或者1次 print(re.findall('ab?', 'a ab abb abbbb a1b')) #['a' ,'ab' ,'ab','ab','a'] 分析过程: 要匹配ab?。b可以出现1个也可以不出现。即'a'或者'ab'.字母a开头的只要能匹配就取出来。 星 *代表*左边的字符出现0次或者无穷次 print(re.findall('ab*', 'a ab abb abbbb a1b')) #['a', 'ab', 'abb','abbbb','a'] 加号 +代表+号左边的字符出现1次或者无穷次 print(re.findall('ab+', 'a ab abb abbbbb a1b')) #['ab','abb','abbbbb'] 分析过程: 要匹配ab+,b可以出现1个或者无穷次但不能不出现。即'ab'或者'a无穷个b'.需要以字母ab开头的才能匹配，注意和问号、星号做对比。 大括号 {m,n}：代表左边的字符出现m次到n次 print(re.findall('ab{0,1}', 'a ab abb abbbb a1b')) #等同于?效果。0次到1次 print(re.findall('ab{0,}', 'a ab abb abbbb a1b')) #等同于*效果。0次到无穷次 print(re.findall('ab{1,}', 'a ab abb abbbb a1b')) #等同于+效果。1次到无穷次 print(re.findall('ab{2,4}', 'a ab abb abbbb abbbbbbbbbbbb a1b')) #2次到4次，即匹配abb,abbb,abbbb ,如果出现4个以上的b只取到4个。结果为['abb','abbbb','abbbb'] 点星 .*代表要么不出现，要么出现无穷次。（贪婪匹配）通常匹配的不够精准。 print(re.findall('a.*b', 'xxxxy123a123b456b')) #['a123b456b'] 点星问号 .*?非贪婪匹配和.*对应。（爬虫经常用！！！） print(re.findall('a.*?b', 'xxxxy123a123b456b')) #['a123b'] 分析:有多个b时，匹配最近的一个b 斜杠 /或者 小括号 ()分组，findall()只取分组里面的字符。(?:)代表分组外面的字符也保留。是固定写法！ 需求:找出所有compan开头的英文字母 print(re.findall('compan(y|ies)', 'Too many companies have gone bankrupt, and the next one is my company')) #结果：['ies','y'] print(re.findall('compan(?:y|ies)', 'Too many companies have gone bankrupt, and the next one is my company')) #结果：['companies','company'] 应用取出网页中的链接 print(re.findall('href=\"(.*?)\"', '\u003ca href=\"http://www.baidu.com\"\u003e点击我\u003c/a\u003e')) 结果: ['http://www.baidu.com'] rawstring print(re.findall(r'a\\\\c', 'a\\\\c a1c aBc')) #a\\\\c -\u003ea\\c ['a\\\\c'] 中括号 []取中括号内任意一个 print(re.findall('a[a-z]b', 'axb azb aAb a-b a+b')) #['axb','azb'] print(re.findall('a[A-Z]b', 'axb azb aAb a-b a+b')) #['aAb'] print(re.findall('a[a-zA-Z]b', 'axb azb aAb a-b a+b')) #['axb', 'azb', 'aAb'] print(re.findall('a[0-9]b', 'axb azb aAb a1b a-b a+b a9b')) #['a1b', 'a9b'] print(re.findall('a[-+*/]b', 'axb azb aAb a1b a-b a+b a9b')) #['a-b', 'a+b'] print(re.findall('a[^-+*/]b', 'axb azb aAb a1b a-b a+b a9b')) #['axb', 'azb', 'aAb', 'a1b', 'a9b'] ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:6:2","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"re模块的其他用法 re.search匹配成功一次就返回,取不到就返回None,加.group()返回结果。 print(re.search('a[*]b', 'axb azb aAb a1b a-b a+b aaab')) #None print(re.search('a[a-z]b', 'axb azb aAb a1b a-b a+b aaab').group()) # axb re.match：从开头取,开头没有就为None,只取一次。 print(re.match('a[0-9]b', 'axb azb aAb a1b a-b a2b a+b')) print(re.match('a[0-9]b', 'a9b a8b axb azb aAb a1b a-b a2b a+b').group()) print(re.search('^a[0-9]b', 'a9b a8b axb azb aAb a1b a-b a2b a+b').group()) re.split:分割 print(re.split(':', 'root❌0:0::/root:/bin/bash',maxsplit=1)) #结果为：['root','x:0:0::/root:/bin/bash'] #'root❌0:0::/root:/bin/bash'.split(':') re.sub:替换 print(re.sub('root', 'admin', 'root❌0:0::/root:/bin/bash')) #都替换 print(re.sub('root', 'admin', 'root❌0:0::/root:/bin/bash', 1)) #只换一次 需求：文本前后倒转 print(re.sub('^([a-z]+)([^a-z]+)(.*?)([^a-z]+)([a-z]+)$', r'\\5\\2\\3\\4\\1', 'root❌0:0::/root:/bin/bash')) #只换一次 解析： ^以…开头 $以…结尾 ([a-z]+) 分组匹配单词 ([^a-z]+)分组匹配非单词 (.*?)分组匹配任意字符 正则整体表示：以单词开头，并且以单词结尾。r表示显示字符原本含义不进行转义，\\5表示第五个分组。r'\\5\\2\\3\\4\\1' 整体表示第5个分组和第一个分组的内容调换 并且斜杠使用原本含义不做转义。 re.compile :它将正则表达式转化为对象 obj = re.compile('a\\d{2}b') print(obj.findall('a12b a123b a12345b abbb')) #['a12b'] print(obj.search('a12b a123b a12345b abbb').group()) #a12b 常用正则表 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:6:3","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"时间模块 import time print(time.time()) #时间戳格式：1648026287.9298368 print(time.localtime().tm_mday) #23 print(time.localtime()) #结构化时间 print(time.gmtime()) #结构化时间 #结果 #time.struct_time(tm_year=2022, tm_mon=3, tm_mday=23, tm_hour=17, tm_min=5, tm_sec=26, tm_wday=2, tm_yday=82, tm_isdst=0) #time.struct_time(tm_year=2022, tm_mon=3, tm_mday=23, tm_hour=9, tm_min=5, tm_sec=26, tm_wday=2, tm_yday=82, tm_isdst=0) print(time.strftime('%Y-%m-%d %H:%M:%S')) #2022-03-23 17:07:47 print(time.strftime('%Y-%m-%d %X')) #2022-03-23 17:07:47 #了解 print(time.localtime(1111111111)) print(time.localtime(time.time())) print(time.gmtime(time.time())) print(time.mktime(time.localtime())) print(time.strftime('%Y-%m-%d', time.localtime())) print(time.strptime('2020-03-01', '%Y-%m-%d')) print(time.asctime()) #Wed Mar 23 17:15:40 2022 print(time.ctime()) #Wed Mar 23 17:15:40 2022 print(time.asctime(time.localtime())) #Wed Mar 23 17:16:32 2022 print(time.ctime(111111111)) #Tue Jul 10 08:11:51 1973 print(time.ctime(1648027065.7651727)) #Wed Mar 23 17:17:45 2022 print(time.time()) #时间戳格式：1648026287.9298368 #datetime import datetime print(datetime.datetime.now()) #当前时间：2022-03-23 17:20:11.964584 print(datetime.datetime.fromtimestamp(111111111)) #1973-07-10 08:11:51 print(datetime.datetime.now()+datetime.timedelta(days=3)) #当前时间开始的三天后。2022-03-26 17:22:35.581422 print(datetime.datetime.now()+datetime.timedelta(days=-3)) #当前时间开始的三天前。2022-03-20 17:22:35.581422 print(datetime.datetime.now()+datetime.timedelta(minutes=3)) #当前时间开始的三分钟后。2022-03-23 17:25:35.581422 print(datetime.datetime.now()+datetime.timedelta(seconds=3)) #当前时间开始的三秒后。2022-03-23 17:22:38.581422 print(datetime.datetime.now().replace(year=2000)) #将当前时间中年替换成2000. 2000-03-23 17:25:04.696554 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:7:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"random模块 import random print(random.random()) #(0,1) --float 大于0且小于1之间的小数 0.8266764258093519 print(random.randint(1, 3)) #[1,3] 大于等于1且小于等于3之间的整数 print(random.randrange(1, 3)) #[1,3) 大于等于1且小于3之间的整数 print(random.choice([1, '23', [4,5]])) #1或者23或者[4,5] print(random.sample([1,'23',[4,5]],2)) #列表元素任意2个组合 [[4, 5], '23'] print(random.uniform(1,3)) #大于1小于3的小数 2.3344194593026546 l=[1,3,4,2,5] random.shuffle(l) #列表中元素随机打乱顺序。[5, 1, 3, 4, 2] print(l) #随机验证码。数字+字母 def make_code(n): res='' for i in range(n): s1=str(random.randint(0,9)) s2=chr(random.randint(65,90)) res+=random.choice([s1,s2]) return res print(make_code(6)) ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:8:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"os模块 os.getcwd() 获取当前工作目录，即当前python脚本工作的目录路径 os.chdir(\"dirname\") 改变当前脚本工作目录；相当于shell下cd os.curdir 返回当前目录: ('.') os.pardir 获取当前目录的父目录字符串名：('..') os.makedirs('dirname1/dirname2') 可生成多层递归目录 os.removedirs('dirname1') 若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推 os.mkdir('dirname') 生成单级目录；相当于shell中mkdir dirname os.rmdir('dirname') 删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname os.listdir('dirname') 列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印 os.remove() 删除一个文件 os.rename(\"oldname\",\"newname\") 重命名文件/目录 os.stat('path/filename') 获取文件/目录信息 os.sep 输出操作系统特定的路径分隔符，win下为\"\\\\\",Linux下为\"/\" os.linesep 输出当前平台使用的行终止符，win下为\"\\t\\n\",Linux下为\"\\n\" os.pathsep 输出用于分割文件路径的字符串 win下为;,Linux下为: os.name 输出字符串指示当前使用平台。win-\u003e'nt'; Linux-\u003e'posix' os.system(\"bash command\") 运行shell命令，直接显示 os.environ 获取系统环境变量 os.path.abspath(path) 返回path规范化的绝对路径 os.path.split(path) 将path分割成目录和文件名二元组返回 os.path.dirname(path) 返回path的目录。其实就是os.path.split(path)的第一个元素 os.path.basename(path) 返回path最后的文件名。如何path以／或\\结尾，那么就会返回空值。即os.path.split(path)的第二个元素 os.path.exists(path) 如果path存在，返回True；如果path不存在，返回False os.path.isabs(path) 如果path是绝对路径，返回True os.path.isfile(path) 如果path是一个存在的文件，返回True。否则返回False os.path.isdir(path) 如果path是一个存在的目录，则返回True。否则返回False os.path.join(path1[, path2[, ...]]) 将多个路径组合后返回，第一个绝对路径之前的参数将被忽略 os.path.getatime(path) 返回path所指向的文件或者目录的最后存取时间 os.path.getmtime(path) 返回path所指向的文件或者目录的最后修改时间 os.path.getsize(path) 返回path的大小 在Linux和Mac平台上，该函数会原样返回path，在windows平台上会将路径中所有字符转换为小写，并将所有斜杠转换为反斜杠。 \u003e\u003e\u003e os.path.normcase('c:/windows\\\\system32\\\\') 'c:\\\\windows\\\\system32\\\\' 规范化路径，如..和/ \u003e\u003e\u003e os.path.normpath('c://windows\\\\System32\\\\../Temp/') 'c:\\\\windows\\\\Temp' \u003e\u003e\u003e a='/Users/jieli/test1/\\\\\\a1/\\\\\\\\aa.py/../..' \u003e\u003e\u003e print(os.path.normpath(a)) /Users/jieli/test1 举例 print(os.getcwd()) print(os.stat(r'D:\\pccharmcode\\oracle.py')) print(os.stat(r'D:\\pccharmcode\\oracle.py').st_size) print(os.path.getsize(r'D:\\pccharmcode\\oracle.py')) os.system('tasklist') #看系统进程,有编码问题。 print(os.path.split(r'D:\\pccharmcode\\oracle.py')) #('D:\\\\pccharmcode', 'oracle.py') print(os.path.dirname(r'D:\\pccharmcode\\oracle.py')) #D:\\pccharmcode print(os.path.basename(r'D:\\pccharmcode\\oracle.py')) #oracle.py print(os.path.isabs(r'C:\\\\a123123123')) #True print(os.path.isabs(r'/root/123.txt')) #True print(os.path.join('C:', 'D:\\\\', 'dir1', 'dir2', 'dir3')) #D:dir1\\dir2\\dir3 print(os.path.normcase('c:/windows\\\\SYstem32\\\\')) #c:\\windows\\system32\\ print(os.path.normpath('c://windows\\\\System32\\\\../Temp/')) #c:\\windows\\Temp 路径：D:\\pccharmcode\\api_key\\__init__.py 要求获取到根开始的第一级路径。 方法1： print(os.path.dirname(os.path.dirname(r'D:\\pccharmcode\\api_key\\__init__.py'))) 方法2： res = os.path.normpath(os.path.join( os.path.abspath(r'D:\\pccharmcode\\api_key\\__init__.py'), os.pardir, os.pardir )) print(res) 方法3： 先将原路径拼接成一个新路径(用os.path.join())。 D:\\pccharmcode\\api_key\\__init__.py\\..\\.. BASE_DIR = os.path.normpath( os.path.join( os.path.abspath(r'D:\\pccharmcode\\api_key\\__init__.py'), '..', '..' ) ) print(BASE_DIR) ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:9:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"sys模块 主要掌握 sys.argv sys.exit(0) sys.path 其他 sys.argv 命令行参数List，第一个元素是程序本身路径 sys.exit(n) 退出程序，正常退出时exit(0) sys.version 获取Python解释程序的版本信息 sys.maxint 最大的Int值 sys.path 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值 sys.platform 返回操作系统平台名称 模拟下载进度条 print(('[%%-%ds]' %50) %('#'*1)) print(('[%%-%ds]' %50) %('#'*2)) print(('[%%-%ds]' %50) %('#'*3)) print(('[%%-%ds]' %50) %('#'*4)) print(('[%%-%ds]' %50) %('#'*5)) print(('[%%-%ds]' %50) %('#'*6)) print(('[%%-%ds]' %50) %('#'*7)) 效果： [# ] [## ] [### ] [#### ] [##### ] [###### ] [####### ] import time import sys def progress(percent,width=50): if percent \u003e= 1: percent=1 show_str = ('[%%-%ds]' % width) % ('#' * int(width*percent)) print('\\r%s %d%%' %(show_str,int(100*percent)),end='') recv_size=0 total_size=10241 while recv_size \u003c total_size: time.sleep(0.1) #模拟数据的传输延迟 recv_size+=1024 #每次收1024 progress(recv_size/total_size) ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:10:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"shutil模块 高级的文件、文件夹、压缩包 处理模块。 格式： shutil.copyfileobj(fsrc, fdst[, length]) 将文件内容拷贝到另一个文件中 import shutil shutil.copyfileobj(open('old.xml','r'), open('new.xml', 'w')) 格式： shutil.copyfile(src, dst) 拷贝文件 shutil.copyfile('f1.log', 'f2.log') #目标文件无需存在 格式： shutil.copymode(src, dst) 仅拷贝权限。内容、组、用户均不变 shutil.copymode('f1.log', 'f2.log') #目标文件必须存在 格式： shutil.copystat(src, dst) 仅拷贝状态的信息，包括：mode bits, atime, mtime, flags shutil.copystat('f1.log', 'f2.log') #目标文件必须存在 格式： shutil.copy(src, dst) 拷贝文件和权限 import shutil shutil.copy('f1.log', 'f2.log') 格式： shutil.copy2(src, dst) 拷贝文件和状态信息 import shutil shutil.copy2('f1.log', 'f2.log') 格式： shutil.ignore_patterns(*patterns) shutil.copytree(src, dst, symlinks=False, ignore=None) 递归的去拷贝文件夹 import shutil shutil.copytree('folder1', 'folder2', ignore=shutil.ignore_patterns('*.pyc', 'tmp*')) #目标目录不能存在，注意对folder2目录父级目录要有可写权限，ignore的意思是排除 拷贝软连接: import shutil shutil.copytree('f1', 'f2', symlinks=True, ignore=shutil.ignore_patterns('*.pyc', 'tmp*')) 通常的拷贝都把软连接拷贝成硬链接，即对待软连接来说，创建新的文件. 格式： shutil.rmtree(path[, ignore_errors[, onerror]]) 递归的去删除文件 import shutil shutil.rmtree('folder1') 格式： shutil.move(src, dst) 递归的去移动文件，它类似mv命令，其实就是重命名。 shutil.move('folder1', 'folder3') 压缩与解压缩 格式： shutil.make_archive(base_name, format,...) 创建压缩包并返回文件路径，例如：zip、tar. base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径， 如 data_bak =\u003e保存至当前路径 如：/tmp/data_bak =\u003e保存至/tmp/ format： 压缩包种类，“zip”, “tar”, “bztar”，“gztar” root_dir： 要压缩的文件夹路径（默认当前目录） owner： 用户，默认当前用户 group： 组，默认当前组 logger： 用于记录日志，通常是logging.Logger对象 将 /data 下的文件打包放置当前程序目录 import shutil ret = shutil.make_archive(\"data_bak\", 'gztar', root_dir='/data') 将 /data下的文件打包放置 /tmp/目录 import shutil ret = shutil.make_archive(\"/tmp/data_bak\", 'gztar', root_dir='/data') shutil 对压缩包的处理是调用 ZipFile 和 TarFile 两个模块来进行的. 详细： 压缩 z = zipfile.ZipFile('laxi.zip', 'w') z.write('a.log') z.write('data.data') z.close() 解压 z = zipfile.ZipFile('laxi.zip', 'r') z.extractall(path='.') z.close() 使用tarfile压缩与解压缩 import tarfile 压缩 t=tarfile.open('/tmp/egon.tar','w') t.add('/test1/a.py',arcname='a.bak') t.add('/test1/b.py',arcname='b.bak') t.close() 解压缩 t=tarfile.open('/tmp/egon.tar','r') t.extractall('/egon') t.close() 练习： 将ATM文件夹以tar.gz方式压缩，然后解压到aaa文件夹内。最后删除aaa文件夹。 import shutil import tarfile #压缩 shutil.make_archive(\"backup\", 'gztar', root_dir=r'D:\\pccharmcode\\ATM') #解压 o = tarfile.open('backup.tar.gz', 'r') o.extractall(r'D:\\pccharmcode\\aaa') o.close() #删除aaa文件夹 shutil.rmtree(r'D:\\pccharmcode\\aaa') ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:11:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"xml模块 from xml.etree import ElementTree tree = ElementTree.parse('a.xml') root = tree.getroot() # print(root.tag) # print(root.attrib) # print(root.text) 三种查找方式 从子节点中查找 显示一种 print(root.find('country')) #\u003cElement 'country' at 0x000001E26EDCC130\u003e #加.tag .attrib .text就可以显示内容 显示所有。以列表的形式显示。 print(root.findall('country')) #[\u003cElement 'country' at 0x0000027D6F00C0E0\u003e, \u003cElement 'country' at 0x0000027D6F00C2C0\u003e, \u003cElement 'country' at 0x0000027D6F00C450\u003e] 注意：如果找不到就会显示 None 从树形结构中查找 root.iter() print(list(root.iter('country'))) ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:12:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"遍历文档 from xml.etree import ElementTree tree = ElementTree.parse('a.xml') root = tree.getroot() for country in root: print('==========\u003e', country.tag, country.attrib, country.attrib['name']) for rank in country: print(rank.tag, rank.attrib, rank.text) 结果 ==========\u003e country {'name': 'Liechtenstein'} Liechtenstein rank {'updated': 'yes'} 2 year {} 2008 gdppc {} 141100 neighbor {'name': 'Austria', 'direction': 'E'} None neighbor {'name': 'Switzerland', 'direction': 'W'} None ==========\u003e country {'name': 'Singapore'} Singapore rank {'updated': 'yes'} 5 year {} 2011 gdppc {} 59900 neighbor {'name': 'Malaysia', 'direction': 'N'} None ==========\u003e country {'name': 'Panama'} Panama rank {'updated': 'yes'} 69 year {} 2011 gdppc {} 13600 neighbor {'name': 'Costa Rica', 'direction': 'W'} None neighbor {'name': 'Colombia', 'direction': 'E'} None 只遍历year节点 for year in root.iter('year'): print(year.tag, year.text) 结果 year 2008 year 2011 year 2011 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:12:1","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"修改 for c in root.iter('year'): new_year = int(c.text)+1 c.text = str(new_year) c.set('update', 'yes') c.set('version', '1.0') tree.write('b.xml') ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:12:2","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"删除 for country in root.findall('country'): rank = int(country.find('rank').text) if rank \u003e 50: root.remove(country) tree.write('output.xml') 在country内添加（append）节点year2 for country in root.findall('country'): for year in country.findall('year'): if int(year.text) \u003e 2000: year2 = ElementTree.Element('year2') year2.text = 'happy-new-year' year2.attrib = {'update':'yes'} country.append(year2) #往country节点下添加子节点 tree.write('a.xml.swap') ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:12:3","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"configerparser模块 [mysqld]叫做section port、basedir等等叫做option 练习配置文件my.ini [mysqld] port = 3306 basedir = D:\\\\softnew\\\\MYSQL\\\\mysql-5.7.20-winx64 max_connections = 200 character-set-server = utf8 default-storage-engine = INNODB skip-grant-table = True [client] user = root password = 123 import configparser config = configparser.ConfigParser() config.read('my.ini') print(config.sections()) #查看所有的标题 print(config.options('mysqld')) #查看标题mysqld下所有key=value的key print(config.get('mysqld', 'port')) #查看标题mysqld下port的值=\u003e字符串格式 判断有没有名字为aaa的option if config.has_option('mysqld', 'aaa'): print(config.get('mysqld', 'aaaa')) 查看值的类型 print(type(config.get('mysqld', 'skip-grant-table'))) #\u003cclass 'str'\u003e 转换成布尔类型 print(config.getboolean('mysqld', 'skip-grant-table')) print(config.getint('mysqld', 'port')) print(config.getfloat('mysqld', 'port')) 向文件中添加section和option config.add_section('client1') config.set('client1', 'name', 'jack') config.set('client1', 'port', '2000') config.write(open('my.ini', 'w', encoding='utf-8')) my.ini文件 将section（client1）中option(port)对应的值2000改为3000 config.set('client1', 'port', '3000') config.write(open('my.ini', 'w', encoding='utf-8')) 查看my.ini文件，port对应的值已经改变。 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:13:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"hashlib模块 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:14:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"什么叫hash? hash是一种算法（3.x里代替了md5模块和sha模块，主要提供 SHA1, SHA224, SHA256, SHA384, SHA512 ，MD5 算法），该算法接受传入的内容，经过运算得到一串hash值。 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:14:1","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"hash值的特点 只要传入的内容一样，得到的hash值必然一样=====\u003e要用明文传输密码文件完整性校验。 不能由hash值返解成内容=======》把密码做成hash值，不应该在网络传输明文密码。 只要使用的hash算法不变，无论校验的内容有多大，得到的hash值长度是固定的。 hash算法就像一座工厂，工厂接收你送来的原材料（可以用m.update()为工厂运送原材料），经过加工返回的产品就是hash值。 练习 import hashlib m = hashlib.md5() # m=hashlib.sha256() m.update('jack'.encode('utf-8')) print(m.hexdigest()) #4ff9fc6e4e5d5f590c4f2134a8cc96d1 m.update('j'.encode('utf-8')) print(m.hexdigest()) #636a4e0a176a6cbb43dd00aec17e64ab m2 = hashlib.sha3_256() m2.update('jack123'.encode('utf-8')) print(m2.hexdigest()) #1183ac670862872ae3315c178a68dddd6166a004b0086bfa23f70e780fe7545c m2.update('j'.encode('utf-8')) print(m2.hexdigest()) #fe50db7bfb8a1e79934413625d2024114de0afd62bd17c3e9d97aee74f8553c6 注意：把一段很长的数据update多次，与一次update这段长数据，得到的结果一样。但是update多次为校验大文件提供了可能。 以上加密算法虽然依然非常厉害，但时候存在缺陷，即：通过撞库可以反解。所以，有必要对加密算法中添加自定义key再来做加密。 import hashlib hash = hashlib.sha256('898oaFs09f'.encode('utf-8')) hash.update('alvin'.encode('utf-8')) print(hash.hexdigest()) #e79e68f070cdedcfe63eaf1a2e92c83b4cfb1b5c6bc452d214c1b7e77cdfd1c7 模拟用户登录并把密码哈希 name = input('user\u003e\u003e: ') pwd = input('password\u003e\u003e: ') m = hashlib.md5() m.update(pwd.encode('utf-8')) pwd = m.hexdigest() print(name, pwd) # jack 1d6c1e168e362bc0092f247399003a88(jack123) 模拟撞库，先生成字典。 cryt_pwd = '1d6c1e168e362bc0092f247399003a88' pwds=[ 'jack1234', 'jack', 'jack456', 'jack123' ] def mack_dic(pwds): dic = {} for pwd in pwds: m = hashlib.md5(pwd.encode('utf-8')) dic[pwd] = m.hexdigest() return dic dic = mack_dic(pwds) for pwd in dic: if dic[pwd] == cryt_pwd: print(pwd) 结果：jack123 python 还有一个 hmac 模块，它内部对我们创建 key 和 内容 进行进一步的处理然后再加密 import hmac h1=hmac.new('hello'.encode('utf-8'),digestmod='md5') h1.update('world'.encode('utf-8')) print(h1.hexdigest()) import hmac m = hmac.new(key='加盐'.encode('utf-8'), msg='jack123'.encode('utf-8'), digestmod=hashlib.sha1) print(m.hexdigest()) 要想保证hmac最终结果一致，必须保证： hmac.new括号内指定的初始key一样 无论update多少次，校验的内容累加到一起是一样的内容 # 操作一 import hmac h1=hmac.new('hello'.encode('utf-8'),digestmod='md5') h1.update('world'.encode('utf-8')) print(h1.hexdigest()) # 0e2564b7e100f034341ea477c23f283b # 操作二 import hmac h2=hmac.new('hello'.encode('utf-8'),digestmod='md5') h2.update('w'.encode('utf-8')) h2.update('orld'.encode('utf-8')) print(h1.hexdigest()) # 0e2564b7e100f034341ea477c23f283b ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:14:2","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"subprocess模块 在linux中使用subporcess模块可以实现shell命令效果。 在windows中使用可以实现windows平台下的命令。 举例：在Linux下查找/root路径下所有以.txt结尾的文件。 shell 实现 ls /root | grep txt$ subprocess模块实现 import subprocess res1=subprocess.Popen('ls /root', shell=True,stdout=subprocess.PIPE) res=subprocess.Popen('grep txt$', shell=True, stdin=res1.stdout, stdout=subprocess.PIPE) print(res.stdout.read().decode('utf-8')) 解析： subprocess.Popen()执行命令ls /root并传入管道（subprocess.PIPE）并赋值给res1 shell=True指定用shell来执行。 subprocess.Popen()执行命令grep txt$先把res1传进来，然后再把整个命令作为输出，最后赋值给res。 读输出的内容，linux平台默认编码为utf-8。 结果： a.txt output.txt url.txt windows平台 查看当前系统所有任务 shell tasklist 使用subprocess实现 import subprocess res=subprocess.Popen('tasklist', shell=True, stdout=subprocess.PIPE) print(res.stdout.read().decode('gbk')) 注意：windows下默认编码为gbk。使用其他编码会出现乱码情况。 结果 映像名称 PID 会话名 会话# 内存使用 ========================= ======== ================ =========== ============ System Idle Process 0 Services 0 8 K System 4 Services 0 148 K Secure System 88 Services 0 73,304 K Registry 156 Services 0 108,364 K smss.exe 532 Services 0 1,232 K csrss.exe 868 Services 0 5,128 K Everything.exe 14296 Console 1 110,268 K LogiOptions.exe 2244 Console 1 15,932 K conhost.exe 6812 Console 1 11,480 K python.exe 9740 Console 1 10,116 K cmd.exe 3740 Console 1 4,852 K tasklist.exe 15428 Console 1 9,824 K 官方文档参考 ","date":"2022-03-26","objectID":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/:15:0","tags":["python"],"title":"python常用模块","uri":"/python%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"},{"categories":["编程"],"content":"什么是模块？ 最常见的场景，一个模块就是包含了一组功能的python文件，例如module.py,模块名是module。可以使用import module。 四个通用类别： 使用python编写的.py文件 已被编译为共享库或DLL的c或c++扩展 把一系列模块组织到一起的文件夹（注意：文件夹下有一个__init__.py文件，该文件夹称之为包） 使用C编写并连接到python解释器的内置模块 ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:1:0","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"为什么要使用模块？ 从文件级别组织程序，更方便管理。 拿来主义，提升开发效率。 ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:2:0","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"如何使用模块？ import 模块名 调用模块里面的函数 模块名.函数名 第一次导入模块，会发生3件事，重复导入只会引用之前加载好的结果。 1.产生一个新的名称空间。 2.运行spam.py源文件代码，产生的名字都存放于1的名称空间中,运行过程中global关键字指向的就是该名称空间。 3.在当前名称空间拿到一个名字spam，该名字指向1的名称空间。引用spam.py中名字的方式：spam.名字 强调：被导入的模块在执行过程中使用自己的独立的名称空间作为全局名称空间。 ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:3:0","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"起别名 import spam as sm ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:3:1","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"一行导入多个模块 import time,sys,spam ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:3:2","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"另一种使用模块的方法 from 模块名 import 名字 优点：引用时不用加前缀，简单 缺点：容易与当名称空间的名字冲突 from spam import money as m from spam import money,read1,read2 from spam import * # *包含除了下划线开头以外所有的名字。 ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:3:3","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"python文件的两种用途 1.当作脚本执行 __name__ == '__main__' 2.当作模块被导入使用 __name__ == '模块名' if __name__ == '__main__': pass ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:3:4","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"模块搜索路径顺序 内存-》内置模块–》sys.path(当前执行文件路径) ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:3:5","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"什么是包 包就是一个包含了__init__.py文件的文件夹（可以往该文件夹下放一堆子模块） ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:4:0","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"包的使用 注意：但凡是在导入时，出现.，这是导入包才有的语法，.的左边必须是一个包，使用的时候没有这种限制。 #把所有要导入的.py模块到放到一个包中，然后只需要导入包名就可以使用了。 import package1 练习： 在根目录下创建python package 名字为package1，默认会自动创建__init__.py 在和package1同级的目录下import.py中导入package1,可以使用package1中定义的模块. 在package1中创建模块func.py。 func.py内容如下： def f1(): print('Welcome to my f1') print('from func.py') __init__.py内容如下： print('__init__.py yeah') 使用package1包中模块func.py中的f1()函数（在import.py中导入） 方法1： import package1.func package1.func.f1() 方法2： from package1 import func func.f1() 结果: __init__.py yeah from func.py Welcome to my f1 分析：路径查找顺序 __init__.py-\u003efunc.py-\u003ef1() ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:5:0","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"如何在pycharm中创建包？ new-\u003ePython Package 练习： 层级结构如下 /root/import.py /root/package1 ├── init.py ├── func.py └── package2 ├── init.py └── myfunc.py /root/package1/func.py中的内容 def f1(): print('Welcome to my f1') /root/package1/package2/myfunc.py 模块中内容 def max1(): print('This is a test!') 需求： 1.在/root/import.py使用/root/package1/package2/myfunc.py 模块中max1() 函数 2.在/root/import.py使用/root/package1/func.py 模块中f1() 函数 解决方法： 思路：/root/package1/__init__.py中先导入max1() 函数,再导入f1() 函数 from package1.package2.myfunc import max1 from package1.func import f1 然后在执行文件/root/import.py中只需要导入包package1 就可以直接使用max1()和f1()了。 import package1 package1.max1() package1.f1() 结果如下 This is a test! Welcome to my f1 拓展： 层级目录结构如下： /root/import.py /root/package1 ├── init.py ├── func.py ├── package2 │ ├── init.py │ └── myfunc.py └── package3 ├── init.py └── myfunc1.py /root/package1/package3/myfunc1.py 中的内容 def f3(): print('from package3 myfunc1.py') 需求：在/root/import.py中使用package3中myfunc1模块中的f3函数（使用相对路径导入） 解决： 1.在/root/package1/__init__.py 中先导入f3函数(点表示在当前路径下) from .package3.myfunc1 import f3 2.在/root/import.py中导入package1包即可直接使用f3函数 import package1 package1.f3() ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:5:1","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"新下载的模块aaa如何导入？ import sys sys.path.append(r'aaa绝对路径') ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:5:2","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"如何连接两个或者多个路径名？ 使用os.path.join()函数 import os print(os.path.join(r'C:', '\\\\', 'a', 'b', 'c.txt')) 结果 C:\\a\\b\\c.txt ","date":"2022-03-26","objectID":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/:5:3","tags":["python"],"title":"模块与包","uri":"/%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85/"},{"categories":["编程"],"content":"基于k8s中cni插件calico网络原理使用总结 ","date":"2022-03-25","objectID":"/k8s%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:1:0","tags":["k8s"],"title":"k8s网路通信","uri":"/k8s%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":["编程"],"content":"1.实验环境 name version ip cni master v1.22.2 ens33:10.4.7.60 calico worker1 v1.22.2 ens33:10.4.7.61 calico worker2 v1.22.2 ens33:10.4.7.62 calico ","date":"2022-03-25","objectID":"/k8s%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:1:1","tags":["k8s"],"title":"k8s网路通信","uri":"/k8s%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":["编程"],"content":"2.实验整体拓扑 ","date":"2022-03-25","objectID":"/k8s%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:1:2","tags":["k8s"],"title":"k8s网路通信","uri":"/k8s%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":["编程"],"content":"3.部署一个deployment 问题1 pod的ip从哪里来？ 由kube-controller-manager来分配。 root@master:~# cat /etc/kubernetes/manifests/kube-controller-manager.yaml | grep cidr - --allocate-node-cidrs=true - --cluster-cidr=10.244.0.0/16 问题2 如何确定集群上正在使用的cni网络插件? 在master节点上查看 问题3 在k8s中，docker 使用的是bridge（网桥）模式，并且始终处于Down状态，那么calico使用的也是网桥模式码？ 使用ip -d a可以查看网卡模式. calico使用都是vxlan技术。 root@master:~# ip -d a 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 promiscuity 0 minmtu 0 maxmtu 0 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: ens33: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:0c:29:30:56:5c brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 46 maxmtu 16110 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 inet 10.4.7.60/24 brd 10.4.7.255 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:fe30:565c/64 scope link valid_lft forever preferred_lft forever 3: docker0: \u003cNO-CARRIER,BROADCAST,MULTICAST,UP\u003e mtu 1500 qdisc noqueue state DOWN group default link/ether 02:42:97:3a:db:c3 brd ff:ff:ff:ff:ff:ff promiscuity 0 minmtu 68 maxmtu 65535 bridge forward_delay 1500 hello_time 200 max_age 2000 ageing_time 30000 stp_state 0 priority 32768 vlan_filtering 0 vlan_protocol 802.1Q bridge_id 8000.2:42:97:3a:db:c3 designated_root 8000.2:42:97:3a:db:c3 root_port 0 root_path_cost 0 topology_change 0 topology_change_detected 0 hello_timer 0.00 tcn_timer 0.00 topology_change_timer 0.00 gc_timer 102.44 vlan_default_pvid 1 vlan_stats_enabled 0 vlan_stats_per_port 0 group_fwd_mask 0 group_address 01:80:c2:00:00:00 mcast_snooping 1 mcast_router 1 mcast_query_use_ifaddr 0 mcast_querier 0 mcast_hash_elasticity 16 mcast_hash_max 4096 mcast_last_member_count 2 mcast_startup_query_count 2 mcast_last_member_interval 100 mcast_membership_interval 26000 mcast_querier_interval 25500 mcast_query_interval 12500 mcast_query_response_interval 1000 mcast_startup_query_interval 3124 mcast_stats_enabled 0 mcast_igmp_version 2 mcast_mld_version 1 nf_call_iptables 0 nf_call_ip6tables 0 nf_call_arptables 0 numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever 4: cali64bc2599f1b@if3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1450 qdisc noqueue state UP group default link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 0 promiscuity 0 minmtu 68 maxmtu 65535 veth numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 inet6 fe80::ecee:eeff:feee:eeee/64 scope link valid_lft forever preferred_lft forever 5: cali186813c9403@if3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1450 qdisc noqueue state UP group default link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 1 promiscuity 0 minmtu 68 maxmtu 65535 veth numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 inet6 fe80::ecee:eeff:feee:eeee/64 scope link valid_lft forever preferred_lft forever 6: calia0e2fa62436@if3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1450 qdisc noqueue state UP group default link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 2 promiscuity 0 minmtu 68 maxmtu 65535 veth numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 inet6 fe80::ecee:eeff:feee:eeee/64 scope link valid_lft forever preferred_lft forever 7: calia67de3f32d9@if3: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1450 qdisc noqueue state UP group default link/ether ee:ee:ee:ee:ee:ee brd ff:ff:ff:ff:ff:ff link-netnsid 3 promiscuity 0 minmtu 68 maxmtu 65535 veth numtxqueues 1 numrxqueues 1 gso_max_size 65536 gso_max_segs 65535 inet6 fe80::ecee:eeff:feee:eeee/64 scope link valid_lft forever preferred_lft forever 10: vxlan.calico: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 145","date":"2022-03-25","objectID":"/k8s%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:1:3","tags":["k8s"],"title":"k8s网路通信","uri":"/k8s%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":["linux"],"content":"系统环境 [root@43f873a76b81 ~]# uname -a Linux 43f873a76b81 4.18.0-147.5.1.el8_1.x86_64 #1 SMP Wed Feb 5 02:00:39 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux [root@43f873a76b81 ~]# cat /etc/*release* CentOS Linux release 7.9.2009 (Core) Derived from Red Hat Enterprise Linux 7.9 (Source) NAME=\"CentOS Linux\" VERSION=\"7 (Core)\" ID=\"centos\" ID_LIKE=\"rhel fedora\" VERSION_ID=\"7\" PRETTY_NAME=\"CentOS Linux 7 (Core)\" ANSI_COLOR=\"0;31\" CPE_NAME=\"cpe:/o:centos:centos:7\" HOME_URL=\"https://www.centos.org/\" BUG_REPORT_URL=\"https://bugs.centos.org/\" CENTOS_MANTISBT_PROJECT=\"CentOS-7\" CENTOS_MANTISBT_PROJECT_VERSION=\"7\" REDHAT_SUPPORT_PRODUCT=\"centos\" REDHAT_SUPPORT_PRODUCT_VERSION=\"7\" CentOS Linux release 7.9.2009 (Core) CentOS Linux release 7.9.2009 (Core) cpe:/o:centos:centos:7 ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:1","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"检查是否有ssh服务,没有则需要安装openssh-server服务 [root@43f873a76b81 ~]# rpm -qa| grep ssh openssh-7.4p1-22.el7_9.x86_64 openssh-server-7.4p1-22.el7_9.x86_64 libssh2-1.8.0-4.el7.x86_64 [root@43f873a76b81 ~]# yum install -y openssh-server ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:2","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"编辑vi /etc/ssh/sshd_config 文件，禁用root用户直接登录，1分钟无操作自动退出系统。 ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:3","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"主要配置文件，其他全注释掉。 Port 22 LoginGraceTime 1m PermitRootLogin no AuthorizedKeysFile .ssh/authorized_keys UsePAM yes X11Forwarding yes AcceptEnv LANG LC_CTYPE LC_NUMERIC LC_TIME LC_COLLATE LC_MONETARY LC_MESSAGES AcceptEnv LC_PAPER LC_NAME LC_ADDRESS LC_TELEPHONE LC_MEASUREMENT AcceptEnv LC_IDENTIFICATION LC_ALL LANGUAGE AcceptEnv XMODIFIERS Subsystem sftp /usr/libexec/openssh/sftp-server Protocol 2 ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:4","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"解释： Port 22 #使用22端口连接 LoginGraceTime 1m #登录系统后1分钟内不操作自动退出。设置空闲会话超时时长。 PermitRootLogin no #禁止root用户直接登录 UsePAM yes #使用pam模块 X11Forwarding yes # 开启GUI界面 Subsystem sftp /usr/libexec/openssh/sftp-server Protocol 2 #使用版本2更加安全。 ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:5","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"添加一个普通用户admin并设置密码admin useradd admin passwd admin ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:6","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"更改pam模块设置，密码输错后等待120s后重试。 ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:7","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"一定要加在第一行。 vi /etc/pam.d/login #%PAM-1.0 auth required pam_tally2.so onerr=fail deny=3 unlock_time=120 even_deny_root root_unlock_time=120 vi /etc/pam.d/sshd #%PAM-1.0 auth required pam_tally2.so onerr=fail deny=3 unlock_time=120 even_deny_root root_unlock_time=120 ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:8","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"最后重启ssh服务 systemctl restart sshd ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:9","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"测试效果 ssh admin@172.16.0.3 Account locked due to 27 failed logins Password: Account locked due to 29 failed logins Password: ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:10","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"查看登陆信息 [root@43f873a76b81 ~]# pam_tally2 --user Login Failures Latest failure From root 3 03/16/22 06:04:08 gateway admin 36 03/16/22 06:04:17 gateway ","date":"2022-03-16","objectID":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/:0:11","tags":["pam模块"],"title":"pam模块限制登录","uri":"/pam%E6%A8%A1%E5%9D%97%E9%99%90%E5%88%B6%E7%99%BB%E5%BD%95/"},{"categories":["linux"],"content":"Linux 信息查询命令 ","date":"2022-02-25","objectID":"/linux-%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4/:0:0","tags":["linux"],"title":"Linux 信息查询命令","uri":"/linux-%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"硬件查询 查看 CPU 信息 cat /proc/cpuinfo 查看物理 CPU 数量 cat /proc/cpuinfo |grep \"physical id\"|sort |uniq|wc -l 查看逻辑 CPU 数量 cat /proc/cpuinfo |grep \"processor\"|wc -l 查看每个 CPU 中 core 的数量 (核心数) cat /proc/cpuinfo |grep \"cores\"|uniq 查看 CPU 的主频 cat /proc/cpuinfo |grep MHz|uniq 查看操作系统内核信息 uname -a 查看 CPU 型号 cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c # 8 Intel(R) Core(TM) i7-4770 CPU @ 3.40GHz 前面 8 代表 CPU 数量. 查看 CPU 运行在 32bit 或 64bit 模式 getconf LONG_BIT # 64 说明当前 CPU 运行在 64bit 模式下,但并不代表不支持 32bit,反之亦然. 查看 CPU 是否支持 64bit 计算 cat /proc/cpuinfo | grep flags | grep ' lm ' | wc -l # 8 (结果大于 0, 说明支持 64bit 计算. lm 指 long mode, 支持 lm 则是 64bit) 查看机器型号 dmidecode | grep \"Product Name\" 查看网卡信息 dmesg | grep -i eth 查看内存信息 cat /proc/meminfo 查看内存总量 grep MemTotal /proc/meminfo 查看空闲内存总量 grep MemFree /proc/meminfo 查看指定目录的大小 du -sh \u003c目录名\u003e 查看各分区使用情况 df -h 查看系统运行时间、用户数、负载 uptime 查看操作系统版本 head -n 1 /etc/issue 查看环境变量 env 查看计算机名 hostname ","date":"2022-02-25","objectID":"/linux-%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4/:1:0","tags":["linux"],"title":"Linux 信息查询命令","uri":"/linux-%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"CentOS 7 常规命令 ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:0:0","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"文件类 ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:1:0","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"常规 tar 打包解包 tar cvf FileName.tar DirName or FileName # 打包 tar xvf FileName.tar -C 指定位置目录 # 解包 tar gz 打包压缩 tar zcvf FileName.tar.gz DirName or FileName # 打包并压缩 tar zxvf FileName.tar.gz -C 指定位置目录 # 解包 zip 压缩解压缩 zip FileName.zip FileName # 压缩文件 zip -r DirName.zip DirName # 压缩目录 unzip xxx.zip # 解压缩 ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:1:1","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"文件下载 下载覆盖 wget https://xxx.com/xxx.zip -O /xxx/xxx.zip # -O 重命名并直接覆盖 下载指定路径比对新旧直接覆盖 wget -P /xxx/xxx -N https://xxx.com/xxx.zip # -P 指定下载路径,如不存在则自动创建. # -N 只下载比本地新的文件并覆盖 ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:1:2","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"文件传输 文件下载 - 从远程服务器下载文件到本服务器 scp -P 22 root@8.8.8.8:/root/1.zip /root 文件上传 - 上传本地文件到远程服务器 scp -P 22 /root/st/1.zip root@8.8.8.8:/root 目录下载 - 从远程服务器下载文件夹到本服务器 scp -r -P 22 root@8.8.8.8:/root/xx /root 目录上传 - 上传本地文件夹到远程服务器 scp -r -P 22 /root/xx root@8.8.8.8:/root ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:1:3","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"文件查找 查询当前目录下及所有子目录下的某文件,并拷贝到当前文件夹 find . -name \"*.txt\" | xargs -I{} cp {} ./ find . -name \"*.*\" | xargs -I{} cp {} ./ 查询当前目录下及所有子目录下的某文件,并删除. find . -name \".DS_Store\" | xargs -I{} rm {} ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:1:4","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"运维类 ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:2:0","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"基础配置 允许 root 登陆及修改端口 vi /etc/ssh/sshd_config Port 22222 # 配置端口 PermitRootLogin yes PasswordAuthentication yes ClientAliveInterval 30 # 重启 sshd systemctl restart sshd yum 源 yum repolist yum repolist all # 查看 yum 源 yum -y install epel-release # 如无 epel/x86_64 推荐先安装 epel 源 yum clean all yum makecache # 清除并重建缓存 yum update -y # 更新 # 如需使用 epel 源国内阿里云镜像加速,执行以下命令: mv /etc/yum.repos.d/epel.repo /etc/yum.repos.d/epel.repo.backup mv /etc/yum.repos.d/epel-testing.repo /etc/yum.repos.d/epel-testing.repo.backup wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo yum clean all yum makecache 修改网络信息 cd /etc/sysconfig/network-scripts # ls 查看当前网卡信息,可能为 ifcfg-eth0 ifcfg-ens192 等等. vi ifcfg-eth0 # 编辑修改网络信息 service network restart # 重启网络服务 时区及 ntp 时间同步 tzselect # 选择时区 mv /etc/localtime /etc/localtime.bak # 备份 localtime ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime # 创建时区软链接,再次 date 检查时区. yum -y install ntpdate # 安装 ntpdate ntpdate cn.pool.ntp.org # 同步时间 # 备选 ntp 服务器 cn.pool.ntp.org ntp.aliyun.com ntp1.aliyun.com time1.cloud.tencent.com screen 常用命令 yum -y install screen # 安装 screen screen -S xxx # 新建名为 xxx 的 session screen -ls # 列出当前所有 session screen -r xxx # 恢复到 xxx 这个 session screen -d xxx # 远程分离 xxx 这个 session screen -d -r xxx # 结束当前 session 并恢复到 xxx 这个 session screen -S xxx -X quit # 远程删除 session ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:2:1","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"常规查询 清除历史登录记录 echo \u003e /var/log/wtmp 清除历史命令记录 history -c \u0026\u0026 history -w 一键清除并退出 echo \u003e /var/log/wtmp \u0026\u0026 history -c \u0026\u0026 history -w \u0026\u0026 exit 查看目录占用空间 du -h --max-depth=1 /home 端口占用查询 netstat -ntlp netstat -ntlp | grep 80 # 查询80端口占用 CPU内存占用查询 ps aux|head -1;ps aux|grep -v PID|sort -rn -k +3|head # 获取占用CPU资源最多的10个进程 ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head # 获取占用内存资源最多的10个进程 重新加载systemctl sudo systemctl daemon-reload ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:2:2","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"iptables 使用 iptables 需禁用默认防火墙 firewalld yum -y install iptables-services # 安装 iptables iptables-services systemctl stop firewalld systemctl disable firewalld # 禁用 firewall systemctl start iptables systemctl status iptables systemctl enable iptables # 启用 iptables iptables -P INPUT ACCEPT iptables -P OUTPUT ACCEPT iptables -P FORWARD ACCEPT iptables -F service iptables save # 设置默认规则并清空所有规则,保存设置. # 以下为快速执行 iptables -P INPUT ACCEPT \u0026\u0026 \\ iptables -P OUTPUT ACCEPT \u0026\u0026 \\ iptables -P FORWARD ACCEPT \u0026\u0026 \\ iptables -F \u0026\u0026 \\ service iptables save ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:2:3","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"防火墙 常规命令 sudo firewall-cmd --add-service=http --permanent sudo firewall-cmd --add-service=https --permanent sudo firewall-cmd --add-port=80/tcp --permanent sudo firewall-cmd --add-port=443/tcp --permanent sudo firewall-cmd --add-port=4000-5000/tcp --permanent sudo firewall-cmd --remove-port=XXXX/tcp --permanent sudo firewall-cmd --reload sudo firewall-cmd --list-all 更多命令 # 查看是否开启 systemctl status firewalld.service # 打开防火墙 systemctl start firewalld.service # 停用防火墙 systemctl disable firewalld # 禁用防火墙 systemctl stop firewalld.service # 开机启动 systemctl enable firewalld # 取消开机启动 systemctl disable firewalld # 查看运行状态 firewall-cmd --state # 查看接口信息 firewall-cmd --list-all # 更新防火墙规则方法1:无需断开连接，动态更改规则 firewall-cmd --reload # 更新防火墙规则方法2:断开连接，以重启的方式更改规则 firewall-cmd --complete-reload # 查看帮助 firewall-cmd --help --zone=NAME # 指定 Zone --permanent # 为永久生效 --timeout=seconds # 持续一段时间，到期后自动移除，经常用于调试，且不能与 --permanent 同时使用 # 追加一个8181端口，永久有效 firewall-cmd --add-port=8181/tcp --permanent # 追加一段端口范围 firewall-cmd --add-port=6000-6600/tcp # 开放 ftp 服务 firewall-cmd --add-service=ftp # 添加eth0 接口至 public 信任等级，永久有效 firewall-cmd --zone=public --add-interface=eth0 --permanent # 配置 public zone 的端口转发 firewall-cmd --zone=public --add-masquerade # 然后转发 tcp 22 端口至 9527 firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toport=9527 # 转发 22 端口数据至另一个 ip 的相同端口上 firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toaddr=192.168.1.123 # 转发 22 端口数据至另一 ip 的 9527 端口上 firewall-cmd --zone=public --add-forward-port=port=22:proto=tcp:toport=9527:toaddr=192.168.1.100 # IP 封禁 firewall-cmd --permanent --add-rich-rule=\"rule family='ipv4' source address='192.168.1.123' reject\" # 通过 ipset 来封禁 ip firewall-cmd --permanent --zone=public --new-ipset=blacklist --type=hash:ip firewall-cmd --permanent --zone=public --ipset=blacklist --add-entry=192.168.1.123 # 封禁网段 firewall-cmd --permanent --zone=public --new-ipset=blacklist --type=hash:net firewall-cmd --permanent --zone=public --ipset=blacklist --add-entry=192.168.1.0/24 # 倒入 ipset 规则 blacklist，然后封禁 blacklist firewall-cmd --permanent --zone=public --new-ipset-from-file=/path/blacklist.xml firewall-cmd --permanent --zone=public --add-rich-rule='rule source ipset=blacklist drop' ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:2:4","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"系统类 ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:3:0","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"磁盘挂载 磁盘分区格式化 fdisk -l # 查看到新硬盘 /dev/sdb fdisk /dev/sdb # 为磁盘分区,选择 n 开始分区,其他直接回车保持默认,结尾 w 保存. mkfs.ext4 /dev/sdb1 # 格式化分区 磁盘挂载 mkdir /data # 创建挂载目录 mount /dev/sdb1 /data # 挂载至 /data vi /etc/fstab # 配置开机自动挂载 /dev/sdb1 /data ext4 defaults 0 0 # 添加启动项后保存 umount /data # 取消挂载,同时需再次编辑 /etc/fstab 删除开机自动挂载命令. ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:3:1","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"NFS 服务端 安装 yum -y install nfs-utils systemctl start rpcbind systemctl enable rpcbind systemctl start nfs systemctl enable nfs 配置 vi /etc/exports # 配置挂载权限 /share *(rw,sync,no_root_squash,no_all_squash) # 所有网段 /share 192.168.1.0/24(rw,sync,no_root_squash,no_all_squash) # 指定网段 /share 192.168.1.9(rw,sync,no_root_squash,no_all_squash) # 指定 IP exportfs -r # 刷新配置 客户端挂载 用于挂载局域网内群晖 NFS 共享文件夹,需在群晖 DSM 内开启 NFS 服务,并编辑需挂载的共享文件夹,添加 NFS 权限设置服务器名称或 IP 地址为 \\* yum -y install nfs-utils # 安装 NFS 工具 mkdir /data # 创建本地目录 mount -t nfs 192.168.1.8:/volume1/Downloads /data # 挂载目录 vi /etc/fstab # 设置开机自动挂载 192.168.1.8:/volume1/Downloads /data nfs defaults 0 0 # 尾行添加挂载命令 umount /data # 取消挂载,同时需再次编辑 /etc/fstab 删除开机自动挂载命令. ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:3:2","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"SMB 服务端 安装启动 yum -y install samba # 安装 systemctl start smb # 启动 systemctl status smb # 状态 systemctl enable smb # 开机自启动 systemctl restart smb # 重启 共享文件夹 本文为匿名共享文件夹,无需配置账号密码. mkdir /data # 创建共享文件夹 chown -R nobody:nobody /data # 赋予文件夹匿名用户权限 vi /etc/sysconfig/selinux # OR vi /etc/selinux/config # 修改 SELINUX=disabled 后重启服务器 配置 smb.conf vi /etc/samba/smb.conf # 参考以下编辑 conf 文件: [global] workgroup = WORKGROUP security = user map to guest = Bad User [data] comment = date path = /data public = yes read only = No 配置账号密码 参考链接 useradd stille smbpasswd -a stille chown -R nobody:nobody share chmod -R 777 share vi /etc/samba/smb.conf [global] security = user workgroup = SAMBA passdb backend = tdbsam [share] comment = share path = /share writable = no create mask = 0644 directory mask = 02755 valid users = stille write list = stille 检查语法 testparm # 检查语法 systemctl restart smb # 重启 smb 服务 avahi yum install avahi-tools systemctl start avahi-daemon systemctl enable avahi-daemon vi /etc/avahi/services/smb.service \u003cservice-group\u003e \u003cname\u003eCENTOS\u003c/name\u003e \u003cservice\u003e \u003ctype\u003e_device-info._tcp\u003c/type\u003e \u003ctxt-record\u003emodel=Xserve\u003c/txt-record\u003e \u003c/service\u003e \u003cservice\u003e \u003ctype\u003e_smb._tcp\u003c/type\u003e \u003cport\u003e445\u003c/port\u003e \u003c/service\u003e \u003c/service-group\u003e systemctl restart avahi-daemon 客户端 匿名挂载 mount -t cifs -o guest //192.168.1.8/share /share # 配置开机自动挂载 vim /etc/fstab //192.168.1.8/share /share cifs defaults,guest 0 0 用户密码挂载 mount -t cifs -o username=xxxxx,password='xxxxx',iocharset=utf-8 //192.168.1.8/share /share # 配置开机自动挂载 vim /etc/fstab //192.168.1.8/share /share cifs defaults,username=xxxxx,password=xxxxx umount umount /share # 遇到无法 umount 时 yum install psmisc fuser -mv /share kill -9 xxxx ","date":"2022-02-25","objectID":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/:3:3","tags":["centos7"],"title":"CentOS7 常规命令","uri":"/centos7-%E5%B8%B8%E8%A7%84%E5%91%BD%E4%BB%A4/"},{"categories":["linux"],"content":"CentOS 7 升级内核 uname -r # 查看内核 yum install -y https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm yum --disablerepo=\"*\" --enablerepo=\"elrepo-kernel\" list available yum --enablerepo=elrepo-kernel install -y kernel-lt awk -F\\' '$1==\"menuentry \" {print i++ \" : \" $2}' /boot/grub2/grub.cfg yum install -y grub2-pc grub2-set-default 0 vim /etc/default/grub # 修改 GRUB_DEFAULT=0 grub2-mkconfig -o /boot/grub2/grub.cfg reboot # 重启 uname -r # 查看内核 ############################## 以下可选 ############################## yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64 # 删除版本工具包 yum --disablerepo=\\* --enablerepo=elrepo-kernel install -y kernel-lt-tools.x86_64 # 安装新版本工具包 rpm -qa | grep kernel # 查看已安装内核 ","date":"2022-02-25","objectID":"/centos7-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/:0:0","tags":["centos7"],"title":"CentOS7 升级内核","uri":"/centos7-%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/"},{"categories":["工具"],"content":"Shell 脚本常用参考 ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:0:0","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"echo cat read sed awk ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:1:0","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"cat cat \u003e /path/${TEMP}/account.conf\u003c\u003cEOF export ${API_ID_HEADER}=\"${API_ID_INPUT}\" export ${API_KEY_HEADER}=\"${API_KEY_INPUT}\" EOF # 单引号转译内容 # cat \u003e /path/${TEMP}/account.conf\u003c\u003c'EOF' ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:1:1","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"sed sed -i \\ -e '/Port 22/a\\Port 22222' \\ -e '/^PasswordAuthentication.*yes$/s/yes/no/g' \\ -e '/^PermitRootLogin.*no$/s/no/yes/g' \\ -e '/^#PermitRoot.*yes$/s/#PermitRoot/PermitRoot/g' \\ -e '/#ClientAliveInterval/s/#ClientAliveInterval 0/ClientAliveInterval 30/g' \\ -e '/#MaxSessions/s/#MaxSessions 10/MaxSessions 100/g' \\ /etc/ssh/sshd_config ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:1:2","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"awk 从文件获取 分隔符 = 如果第一列含有 DOMAIN 打印第二列 DOMAIN=$(cat /conf/account.conf | awk -F= '{if($1~\"DOMAIN\")print $2}') ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:1:3","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"read read -p \"请输入:\" INPUT ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:1:4","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"case case \"$INPUT\" in 1) echo \"1\" ;; 2) echo \"2\" ;; *) echo \"其他\" exit 0 esac ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:1:5","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"if 判断 字符串对比判断 if [ \"$INPUT\" == \"3\" ]; then echo \"变量等于 3\" fi 判断变量是否存在 if [ ! -n \"${INPUT}\" ]; then echo \"变量不存在\" fi 判断目录是否存在 if [ -d /data/test ]; then echo \"目录存在\" fi 判断文件是否存在 if [ -f /data/test ]; then echo \"目录存在\" fi 服务器软件判断 if type docker-compose \u003e/dev/null 2\u003e\u00261; then echo \"已安装 docker-compose\" else echo \"未安装 docker-compose\" fi 判断是否是root if [[ $EUID -ne 0 ]]; then echo \"非 root 用户\" exit 1 fi 判断 OpenVZ if [[ -d \"/proc/vz\" ]]; then echo -e \"这是 OpenVZ,非 KVM\" exit 1 fi 数值比较判断 if [ $TIMES -eq 3 ]; then echo \"Times 大于 3\" fi ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:2:0","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"运算符 ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:3:0","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"算术运算符 #!/bin/sh a=10 b=20 val=`expr $a + $b` echo \"a + b : $val\" val=`expr $a - $b` echo \"a - b : $val\" val=`expr $a \\* $b` echo \"a * b : $val\" val=`expr $b / $a` echo \"b / a : $val\" val=`expr $b % $a` echo \"b % a : $val\" if [ $a == $b ] then echo \"a is equal to b\" fi if [ $a != $b ] then echo \"a is not equal to b\" fi 运算符 说明 举例 + 加法 expr $a + $b 结果为 30。 - 减法 expr $a - $b 结果为 10。 * 乘法 expr $a \\* $b 结果为 200。 / 除法 expr $b / $a 结果为 2。 % 取余 expr $b % $a 结果为 0。 = 赋值 a=$b 将把变量 b 的值赋给 a。 == 相等。用于比较两个数字，相同则返回 true。 [ $a == $b ] 返回 false。 != 不相等。用于比较两个数字，不相同则返回 true。 [ $a != $b ] 返回 true。 ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:3:1","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"关系运算符 #!/bin/sh a=10 b=20 if [ $a -eq $b ] then echo \"$a -eq $b : a is equal to b\" else echo \"$a -eq $b: a is not equal to b\" fi if [ $a -ne $b ] then echo \"$a -ne $b: a is not equal to b\" else echo \"$a -ne $b : a is equal to b\" fi if [ $a -gt $b ] then echo \"$a -gt $b: a is greater than b\" else echo \"$a -gt $b: a is not greater than b\" fi if [ $a -lt $b ] then echo \"$a -lt $b: a is less than b\" else echo \"$a -lt $b: a is not less than b\" fi if [ $a -ge $b ] then echo \"$a -ge $b: a is greater or equal to b\" else echo \"$a -ge $b: a is not greater or equal to b\" fi if [ $a -le $b ] then echo \"$a -le $b: a is less or equal to b\" else echo \"$a -le $b: a is not less or equal to b\" fi 关系运算符列表 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 true。 -ne 检测两个数是否相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:3:2","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"布尔运算符 #!/bin/sh a=10 b=20 if [ $a != $b ] then echo \"$a != $b : a is not equal to b\" else echo \"$a != $b: a is equal to b\" fi if [ $a -lt 100 -a $b -gt 15 ] then echo \"$a -lt 100 -a $b -gt 15 : returns true\" else echo \"$a -lt 100 -a $b -gt 15 : returns false\" fi if [ $a -lt 100 -o $b -gt 100 ] then echo \"$a -lt 100 -o $b -gt 100 : returns true\" else echo \"$a -lt 100 -o $b -gt 100 : returns false\" fi if [ $a -lt 5 -o $b -gt 100 ] then echo \"$a -lt 100 -o $b -gt 100 : returns true\" else echo \"$a -lt 100 -o $b -gt 100 : returns false\" fi 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:3:3","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"字符串运算符 #!/bin/sh a=\"abc\" b=\"efg\" if [ $a = $b ] then echo \"$a = $b : a is equal to b\" else echo \"$a = $b: a is not equal to b\" fi if [ $a != $b ] then echo \"$a != $b : a is not equal to b\" else echo \"$a != $b: a is equal to b\" fi if [ -z $a ] then echo \"-z $a : string length is zero\" else echo \"-z $a : string length is not zero\" fi if [ -n $a ] then echo \"-n $a : string length is not zero\" else echo \"-n $a : string length is zero\" fi if [ $a ] then echo \"$a : string is not empty\" else echo \"$a : string is empty\" fi 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -z $a ] 返回 true。 str 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:3:4","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"文件测试运算符列表 #!/bin/sh file=\"/var/www/tutorialspoint/unix/test.sh\" if [ -r $file ] then echo \"File has read access\" else echo \"File does not have read access\" fi if [ -w $file ] then echo \"File has write permission\" else echo \"File does not have write permission\" fi if [ -x $file ] then echo \"File has execute permission\" else echo \"File does not have execute permission\" fi if [ -f $file ] then echo \"File is an ordinary file\" else echo \"This is sepcial file\" fi if [ -d $file ] then echo \"File is a directory\" else echo \"This is not a directory\" fi if [ -s $file ] then echo \"File size is not zero\" else echo \"File size is zero\" fi if [ -e $file ] then echo \"File exists\" else echo \"File does not exist\" fi 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -b $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是具名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:3:5","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"参数 参考liunk 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(\" “)包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:4:0","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["工具"],"content":"循环 标准按次循环 for (( i=1;i\u003c=3;i++ )); do xxx done for 文件循环 套 while 比对循环 for LOG in $(ls -1 ${LOG_PATH}/*.log) do SIZE=`ls -l $LOG | awk '{print $5}'` while [ $SIZE -gt $MAX_SIZE ] do sed -i '1,100000d' $LOG SIZE=`ls -l $LOG | awk '{print $5}'` done done ","date":"2022-02-25","objectID":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/:5:0","tags":["shell"],"title":"shell脚本常用参考","uri":"/shell%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E5%8F%82%E8%80%83/"},{"categories":["linux"],"content":"iptables常用总结 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"安装 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:1","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"查询当前防火墙状态 systemctl status iptables # 检查 iptables 是否安装 systemctl status firewalld # 检查 firewall 是否安装 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:2","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"停止并禁用firewalld systemctl stop firewalld # 停止 firewalld 服务 systemctl disable firewalld # 禁用 firewalld 服务 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:3","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"安装iptables yum install -y iptables # 安装 iptables yum install -y iptables-services # 安装 iptables-services ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:4","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"启动命令 systemctl start iptables systemctl enable iptables systemctl stop iptables systemctl restart iptables systemctl reload iptables ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:5","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"默认开放规则 iptables -P INPUT ACCEPT iptables -P OUTPUT ACCEPT iptables -P FORWARD ACCEPT #清空规则 iptables -F ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:6","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"保存配置 service iptables save # 手动修改 vi /etc/sysconfig/iptables ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:7","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"机制 命令 iptables -t 表名 \u003c-A/I/D/R\u003e 规则链名 [规则号] \u003c-i/o 网卡名\u003e \u003c-s 源IP/源子网\u003e --sport 源端口 -p 协议名 \u003c-d 目标IP/目标子网\u003e --dport 目标端口 -j 动作 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:8","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"工作机制 规则链名包括「也被称为五个钩子函数(hook functions)」： INPUT链 ：处理输入数据包。 OUTPUT链 ：处理输出数据包。 FORWARD链 ：处理转发数据包。 PREROUTING链 ：用于目标地址转换（DNAT）。 POSTOUTING链 ：用于源地址转换（SNAT）。 防火墙策略 防火墙策略一般分为两种，一种叫通策略，一种叫堵策略，通策略，默认门是关着的，必须要定义谁能进。堵策略则是，大门是洞开的，但是你必须有身份认证，否则不能进。所以我们要定义，让进来的进来，让出去的出去，所以通，是要全通，而堵，则是要选择。当我们定义的策略的时候，要分别定义多条功能，其中：定义数据包中允许或者不允许的策略，filter过滤的功能，而定义地址转换的功能的则是nat选项。为了让这些功能交替工作，我们制定出了“表”这个定义，来定义、区分各种不同的工作功能和处理方式。 我们现在用的比较多个功能有3个： filter 定义允许或者不允许的，只能做在3个链上：INPUT ，FORWARD ，OUTPUT nat 定义地址转换的，也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING mangle功能:修改报文原数据，是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING 我们修改报文原数据就是来修改TTL的。能够实现将数据包的元数据拆开，在里面做标记/修改内容的。而防火墙标记，其实就是靠mangle来实现的。 小扩展: 对于filter来讲一般只能做在3个链上：INPUT ，FORWARD ，OUTPUT 对于nat来讲一般也只能做在3个链上：PREROUTING ，OUTPUT ，POSTROUTING 而mangle则是5个链都可以做：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING iptables/netfilter（这款软件）是工作在用户空间的，它可以让规则进行生效的，本身不是一种服务，而且规则是立即生效的。而我们iptables现在被做成了一个服务，可以进行启动，停止的。启动，则将规则直接生效，停止，则将规则撤销。 iptables还支持自己定义链。但是自己定义的链，必须是跟某种特定的链关联起来的。在一个关卡设定，指定当有数据的时候专门去找某个特定的链来处理，当那个链处理完之后，再返回。接着在特定的链中继续检查。 注意：规则的次序非常关键，谁的规则越严格，应该放的越靠前，而检查规则的时候，是按照从上往下的方式进行检查的。 表名包括： raw ：高级功能，如：网址过滤。 mangle ：数据包修改（QOS），用于实现服务质量。 nat ：地址转换，用于网关路由器。 filter ：包过滤，用于防火墙规则。 动作包括： ACCEPT ：接收数据包。 DROP ：丢弃数据包。 REDIRECT ：重定向、映射、透明代理。 SNAT ：源地址转换。 DNAT ：目标地址转换。 MASQUERADE ：IP伪装（NAT），用于ADSL。 LOG ：日志记录。 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:9","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"选项 -t, --table table 对指定的表 table 进行操作， table 必须是 raw， nat，filter，mangle 中的一个。如果不指定此选项，默认的是 filter 表。 # 通用匹配：源地址目标地址的匹配 -p：指定要匹配的数据包协议类型； -s, --source [!] address[/mask] ：把指定的一个／一组地址作为源地址，按此规则进行过滤。当后面没有 mask 时，address 是一个地址，比如：192.168.1.1；当 mask 指定时，可以表示一组范围内的地址，比如：192.168.1.0/255.255.255.0。 -d, --destination [!] address[/mask] ：地址格式同上，但这里是指定地址为目的地址，按此进行过滤。 -i, --in-interface [!] \u003c网络接口name\u003e ：指定数据包的来自来自网络接口，比如最常见的 eth0 。注意：它只对 INPUT，FORWARD，PREROUTING 这三个链起作用。如果没有指定此选项， 说明可以来自任何一个网络接口。同前面类似，\"!\" 表示取反。 -o, --out-interface [!] \u003c网络接口name\u003e ：指定数据包出去的网络接口。只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。 # 查看管理命令 -L, --list [chain] 列出链 chain 上面的所有规则，如果没有指定链，列出表上所有链的所有规则。 # 规则管理命令 -A, --append chain rule-specification 在指定链 chain 的末尾插入指定的规则，也就是说，这条规则会被放到最后，最后才会被执行。规则是由后面的匹配来指定。 -I, --insert chain [rulenum] rule-specification 在链 chain 中的指定位置插入一条或多条规则。如果指定的规则号是1，则在链的头部插入。这也是默认的情况，如果没有指定规则号。 -D, --delete chain rule-specification -D, --delete chain rulenum 在指定的链 chain 中删除一个或多个指定规则。 -R num：Replays替换/修改第几条规则 # 链管理命令（这都是立即生效的） -P, --policy chain target ：为指定的链 chain 设置策略 target。注意，只有内置的链才允许有策略，用户自定义的是不允许的。 -F, --flush [chain] 清空指定链 chain 上面的所有规则。如果没有指定链，清空该表上所有链的所有规则。 -N, --new-chain chain 用指定的名字创建一个新的链。 -X, --delete-chain [chain] ：删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。如果没有指定链名，则会删除该表中所有非内置的链。 -E, --rename-chain old-chain new-chain ：用指定的新名字去重命名指定的链。这并不会对链内部造成任何影响。 -Z, --zero [chain] ：把指定链，或者表中的所有链上的所有计数器清零。 -j, --jump target \u003c指定目标\u003e ：即满足某条件时该执行什么样的动作。target 可以是内置的目标，比如 ACCEPT，也可以是用户自定义的链。 -h：显示帮助信息； ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:10","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"参数 参数 说明 -P 设置默认策略:iptables -P INPUT (DROP) -F 清空规则链 -L 查看规则链 -A 在规则链的末尾加入新规则 -I num 在规则链的头部加入新规则 -D num 删除某一条规则 -s 匹配来源地址IP/MASK，加叹号\"!“表示除这个IP外。 -d 匹配目标地址 -i 网卡名称 匹配从这块网卡流入的数据 -o 网卡名称 匹配从这块网卡流出的数据 -p 匹配协议,如tcp,udp,icmp –dport num 匹配目标端口号 –sport num 匹配来源端口号 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:11","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"实例 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:12","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"清空当前所有规则和计数 iptables -F # 清空所有的防火墙规则 iptables -X # 删除用户自定义的空链 iptables -Z # 清空计数 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:13","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"配置允许ssh端口连接 iptables -A INPUT -s 192.168.1.0/24 -p tcp --dport 22 -j ACCEPT # 22为你的ssh端口， -s 192.168.1.0/24表示允许这个网段的机器来连接，其它网段的ip地址是登陆不了你的机器的。 -j ACCEPT表示接受这样的请求 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:14","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"允许本地回环地址可以正常使用 iptables -A INPUT -i lo -j ACCEPT # 本地回环地址就是127.0.0.1，是本机上使用的,它进与出都设置为允许 iptables -A OUTPUT -o lo -j ACCEPT ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:15","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"设置默认规则 iptables -P INPUT DROP # 配置默认的不让进 iptables -P FORWARD DROP # 默认的不允许转发 iptables -P OUTPUT ACCEPT # 默认的可以出去 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:16","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"配置白名单 iptables -A INPUT -p all -s 192.168.1.0/24 -j ACCEPT # 允许机房内网机器可以访问 iptables -A INPUT -p all -s 192.168.140.0/24 -j ACCEPT # 允许机房内网机器可以访问 iptables -A INPUT -p tcp -s 183.121.3.7 --dport 3380 -j ACCEPT # 允许183.121.3.7访问本机的3380端口 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:1:17","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"开启相应的服务端口 iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 开启80端口，因为web对外都是这个端口 iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT # 允许被ping iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # 已经建立的连接得让它进来 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"配置多端口 #同一目的IP多个不连续端口 iptables -t nat -A PREROUTING -i eth0 -s 0.0.0.0/0 -d 192.168.255.1 -p tcp -m multiport --dport 8082,8083,10728 -j DNAT --to 172.29.110.107 iptables -t nat -A POSTROUTING -o bond0 -d 172.29.110.107 -p tcp -m multiport --dport 8082,8083,10728 -j SNAT --to 172.13.202.100 #同一目的ip多个连续端口 iptables -t nat -A PREROUTING -i eth0 -s 0.0.0.0/0 -d 192.168.255.1 -p tcp --dport 47110:47122 -j DNAT --to 172.12.43.70 iptables -t nat -A POSTROUTING -o bond0 -d 172.12.43.70 -p tcp --dport 47110:47122 -j SNAT --to 172.13.202.101 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:1","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"保存规则到配置文件中 cp /etc/sysconfig/iptables /etc/sysconfig/iptables.bak # 任何改动之前先备份，请保持这一优秀的习惯 iptables-save \u003e /etc/sysconfig/iptables cat /etc/sysconfig/iptables ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:2","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"列出已设置的规则 iptables -L [-t 表名] [链名] 四个表名 raw，nat，filter，mangle 五个规则链名 INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING filter表包含INPUT、OUTPUT、FORWARD三个规则链 iptables -L -t nat # 列出 nat 上面的所有规则 # ^ -t 参数指定，必须是 raw， nat，filter，mangle 中的一个 iptables -L -t nat --line-numbers # 规则带编号 iptables -L INPUT iptables -L -nv # 查看，这个列表看起来更详细 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:3","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"清除已有规则 iptables -F INPUT # 清空指定链 INPUT 上面的所有规则 iptables -X INPUT # 删除指定的链，这个链必须没有被其它任何规则引用，而且这条上必须没有任何规则。 # 如果没有指定链名，则会删除该表中所有非内置的链。 iptables -Z INPUT # 把指定链，或者表中的所有链上的所有计数器清零。 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:4","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"删除已添加的规则 iptables -A INPUT -s 192.168.1.5 -j DROP # 添加一条规则 将所有iptables以序号标记显示，执行： iptables -L -n --line-numbers 比如要删除INPUT里序号为8的规则，执行： iptables -D INPUT 8 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:5","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"开放指定的端口 iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT #允许本地回环接口(即运行本机访问本机) iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT #允许已建立的或相关连的通行 iptables -A OUTPUT -j ACCEPT # 允许所有本机向外的访问 iptables -A INPUT -p tcp --dport 22 -j ACCEPT # 允许访问22端口 iptables -A INPUT -p tcp --dport 80 -j ACCEPT # 允许访问80端口 iptables -A INPUT -p tcp --dport 21 -j ACCEPT # 允许ftp服务的21端口 iptables -A INPUT -p tcp --dport 20 -j ACCEPT # 允许FTP服务的20端口 iptables -A INPUT -j REJECT # 禁止其他未允许的规则访问 iptables -A FORWARD -j REJECT # 禁止其他未允许的规则访问 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:6","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"屏蔽端口 iptables -A INPUT -p tcp --dport 12345 -j DROP # 屏蔽访问 12345 端口 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:7","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"屏蔽域名 iptables -A OUTPUT -m string --string \"ysp8.cc\" --algo bm --to 65535 -j DROP # 屏蔽服务器内域名访问 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:8","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"屏蔽IP iptables -A INPUT -p tcp -m tcp -s 192.168.0.8 -j DROP # 屏蔽恶意主机（比如，192.168.0.8 iptables -I INPUT -s 123.45.6.7 -j DROP # 屏蔽单个IP的命令 iptables -I INPUT -s 123.0.0.0/8 -j DROP # 封整个段即从123.0.0.1到123.255.255.254的命令 iptables -I INPUT -s 124.45.0.0/16 -j DROP # 封IP段即从123.45.0.1到123.45.255.254的命令 iptables -I INPUT -s 123.45.6.0/24 -j DROP # 封IP段即从123.45.6.1到123.45.6.254的命令是 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:9","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"指定数据包出去的网络接口 只对 OUTPUT，FORWARD，POSTROUTING 三个链起作用。 iptables -A FORWARD -o eth0 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:10","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"查看已添加的规则 iptables -L -n -v Chain INPUT (policy DROP 48106 packets, 2690K bytes) pkts bytes target prot opt in out source destination 5075 589K ACCEPT all -- lo * 0.0.0.0/0 0.0.0.0/0 191K 90M ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:22 1499K 133M ACCEPT tcp -- * * 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 4364K 6351M ACCEPT all -- * * 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 6256 327K ACCEPT icmp -- * * 0.0.0.0/0 0.0.0.0/0 Chain FORWARD (policy ACCEPT 0 packets, 0 bytes) pkts bytes target prot opt in out source destination Chain OUTPUT (policy ACCEPT 3382K packets, 1819M bytes) pkts bytes target prot opt in out source destination 5075 589K ACCEPT all -- * lo 0.0.0.0/0 0.0.0.0/0 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:11","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"启动网络转发规则 公网210.14.67.7让内网192.168.188.0/24上网 iptables -t nat -A POSTROUTING -s 192.168.188.0/24 -j SNAT --to-source 210.14.67.127 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:12","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"端口映射 本机的 2222 端口映射到内网 虚拟机的22 端口 iptables -t nat -A PREROUTING -d 210.14.67.127 -p tcp --dport 2222 -j DNAT --to-dest 192.168.188.115:22 ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:13","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"字符串匹配 比如，我们要过滤所有TCP连接中的字符串test，一旦出现它我们就终止这个连接，我们可以这么做： iptables -A INPUT -p tcp -m string --algo kmp --string \"test\" -j REJECT --reject-with tcp-reset iptables -L # Chain INPUT (policy ACCEPT) # target prot opt source destination # REJECT tcp -- anywhere anywhere STRING match \"test\" ALGO name kmp TO 65535 reject-with tcp-reset # # Chain FORWARD (policy ACCEPT) # target prot opt source destination # # Chain OUTPUT (policy ACCEPT) # target prot opt source destination ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:14","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"阻止Windows蠕虫的攻击 iptables -I INPUT -j DROP -p tcp -s 0.0.0.0/0 -m string --algo kmp --string \"cmd.exe\" ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:15","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["linux"],"content":"防止SYN洪水攻击 iptables -A INPUT -p tcp --syn -m limit --limit 5/second -j ACCEPT ","date":"2022-02-25","objectID":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/:2:16","tags":["iptables"],"title":"iptables常用总结","uri":"/iptables%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["工具"],"content":"前言 长时间不登陆jupyter竟然忘记了密码，所以记录下jupyter容器中更改密码过程。 ","date":"2022-02-24","objectID":"/jupyter%E6%9B%B4%E6%94%B9%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81/:1:0","tags":["jupyter"],"title":"jupyter更改登录密码","uri":"/jupyter%E6%9B%B4%E6%94%B9%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81/"},{"categories":["工具"],"content":"更改过程 进入jupyter容器 docker exec -it vk-jupyter bash cd .jupyter/ vi jupyter_notebook_config.json 生成新密码哈希值 ipython 复制新的哈希值替换jupyter_notebook_config.json文件中的哈希值 重启jupyter容器 docker restart vk-jupyter 尝试用新密码登录 ","date":"2022-02-24","objectID":"/jupyter%E6%9B%B4%E6%94%B9%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81/:2:0","tags":["jupyter"],"title":"jupyter更改登录密码","uri":"/jupyter%E6%9B%B4%E6%94%B9%E7%99%BB%E5%BD%95%E5%AF%86%E7%A0%81/"},{"categories":["工具"],"content":"安装及命令 ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:0","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"Docker命令 常用 docker version docker info docker pull docker login docker logout docker images docker ps -a docker start|stop|restart docker rm xxxx docker rmi xxxx docker exec -it `name OR id` /bin/bash 批量停止删除容器和镜像 停止所有容器 docker stop $(docker ps -aq) 删除所有的容器 docker rm $(docker ps -aq) 删除所有的镜像 docker rmi $(docker images -q) Docker目录拷贝 本机/root/test目录拷贝到容器内/root目录内 docker cp /root/test 28a186bbebd4:/root/ 本机/root/test目录拷贝到容器内,并更名为/test123.注意命令后没有/. docker cp /root/test 28a186bbebd4:/test123 将容器内的/test目录拷贝到主机的/root目录内. docker cp 28a186bbebd4:/test /root/ Docker 文件拷贝 本机1.db文件拷贝到容器内root目录内. docker cp 1.db 28a186bbebd4:/root/ 将容器内的/root/1.db文件拷贝到主机的当前目录. docker cp 28a186bbebd4:/root/1.db . Docker命令补全 安装 bash-completion sudo yum install -y bash-completion 根据官方文档进一步配置 官网链接 curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose \u003e /etc/bash_completion.d/docker-compose 重新进入终端即可补全命令。 ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:1","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"Docker镜像 容器创建镜像 通过容器提交生成镜像 docker commit 容器名 镜像名 保存镜像到文件 docker save 镜像名 \u003e 文件名.tar 从文件恢复到镜像 docker load \u003c 文件名.tar 通过镜像启动新容器 docker run --name 容器名 相关参数 最后接新的镜像名 例如 赋予容器所有权限 docker run -it --name test -d --privileged=true centos:7.6.1810 /usr/sbin/init 容器暴露端口给外面访问,容器内20、80，容器外2000、8080 docker run -it --name test -p 2000:20 -p 8080:80 -d centos:7.6.1810 /usr/sbin/init 容器不间断运行，docker重启容器会自动重启不用人工干预。 做数据持久化存储。本地目录容器目录映射。容器内端口5000 容器外端口5000。 容器内目录：/var/lib/registry 容器外目录：/opt/registry docker run -it --name registry -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always registry 退出容器后立即销毁 docker run -it --rm --name test2 alpine sh 进入容器 docker exec -it 容器名/容器id /bin/bash ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:2","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"导入导出镜像 导出镜像 docker images # 查看IMAGE ID docker save bb2b73d4a4a6 \u003e xxx.tar 导入镜像 docker load \u003c xxx.tar 修改镜像名 docker tag bb2b73d4a4a6 xxx/xxx:latest ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:3","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"Docker hub 上传本地镜像 登录 docker login -u 用户名 ip/域名 -p 密码 上传镜像前打标签 docker tag SOURCE_IMAGE[:TAG] harbor.lhp.com/images/IMAGE[:TAG] 上传镜像 docker push harbor.lhp.com/images/IMAGE[:TAG] 下载镜像 docker pull harbor.lhp.com/images/alpine:latest 登录成功信息查看 cat /root/.docker/config.json auth后面字段可以用base64进行解码 #加密 echo test|base64 dGVzdAo= #解密 echo \"YWRtaW46SGFyYm9yMTIzNDU=\" | base64 -d 自动构建镜像 Docker hub创建仓库 链接 GitHub 配置 Build Rules Source Type Source Docker Tag Dockerfile location Branch Master Latest / Tag /^v([0-9.]+)$/ {\\1} / Tag Github Tag /^v([0-9.]+)$/ 对应 v1.0 或 v1.0.0 /^([0-9.]+)$/ 对应 1.0 或 1.0.0 /^([0-9]+)$/ 对应 20210101 Docker Tag {sourceref} 对应 Github Tag {\\1} 对应 Github Tag 去除 v Github push 正常 commit 并 push 到 GitHub Docker Hub 自动构建 master 分支为 latest 镜像 本地 tag commit 并 push tag Docker Hub 自动构建 tag 标签为 tag名 镜像 创建标签 git log # 复制 commit ID git tag -a v1.0.0 commitID -m \"v1.0.0\" # 本地 tag 版本号标签 git push origin v1.0.0 # 提交本地标签到 GitHub 删除标签 git tag -d 标签名 git push origin :refs/tags/标签名 ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:4","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"Docker安装 Docker官方脚本安装 下载一键安装脚本 curl -fsSL https://get.docker.com -o get-docker.sh 运行一键安装脚本(阿里云加速镜像) sudo sh get-docker.sh --mirror Aliyun Docker官方手动升级 升级yum yum update 安装依赖包 sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 配置仓库(国内用户推荐使用下面阿里云加速镜像) sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 配置仓库(阿里云加速镜像) sudo yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 排序查看仓库内文件 yum list docker-ce --showduplicates | sort -r 安装最新版Docker sudo yum install docker-ce docker-ce-cli containerd.io ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:5","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"Docker启动命令 启动Docker sudo systemctl start docker 或 sudo /etc/init.d/docker restart 查看Docker版本 sudo docker version 设置Docker开机自动启动 sudo systemctl enable docker ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:6","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"Docker-compose 安装 官方安装 - 速度慢,有可能被DNS污染导致失败. 手动安装 - 手动下载,离线安装. PIP 在线安装 - 使用 Python 的 pip 包管理工具在线安装. 官方安装 官网选择版本 https://github.com/docker/compose/releases 以下命令手动修改版本号,例如v2.2.3 curl -L https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 执行权限 chmod +x /usr/local/bin/docker-compose 检查 docker compose 版本 docker-compose version 手动安装 官网选择版本 https://github.com/docker/compose/releases 选择相应版本,下载到本地或者服务器中. 更名为docker-compose,并移动到/usr/local/bin目录下. 添加执行权限 chmod +x /usr/local/bin/docker-compose 检查 docker compose 版本 docker-compose version pip在线安装 安装依赖 yum -y install epel-release 安装 PIP yum -y install python-pip 升级 PIP pip install --upgrade pip 升级报错 You are using pip version 8.1.2, however version 22.0.3 is available 解决 curl https://bootstrap.pypa.io/pip/2.7/get-pip.py \u003e\u003e get-pip.py python get-pip.py 3.6版本的get-pip.py curl https://bootstrap.pypa.io/get-pip.py \u003e\u003e get-pip.py python get-pip.py 检查 PIP 版本 pip --version pip 21.3.1 from /usr/local/lib/python3.6/site-packages/pip (python 3.6) 安装 docker compose。 pip install -U docker-compose 检查 docker compose 版本 docker-compose version docker-compose version 1.29.2, build unknown docker-py version: 5.0.3 CPython version: 3.6.8 OpenSSL version: OpenSSL 1.0.2k-fips 26 Jan 2017 ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:7","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"Docker配置镜像加速及私有仓库 配置保存命令 配置daemon.json需要重载并重启生效 编辑 daemon.json vi /etc/docker/daemon.json 重新加载 daemon.json sudo systemctl daemon-reload 重启 Docker sudo systemctl restart docker ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:8","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"配置镜像加速 公共镜像加速 添加Docker 中国官方镜像加速 { \"registry-mirrors\": [\"https://registry.docker-cn.com\"] } 更多公共镜像加速服务 { \"registry-mirrors\": [ \"https://hub-mirror.c.163.com\", \"https://mirror.baidubce.com\", \"https://registry.docker-cn.com\", \"https://reg-mirror.qiniu.com\", \"https://dockerhub.azk8s.cn\", \"https://docker.mirrors.ustc.edu.cn\" ] } ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:9","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"私有镜像加速 可使用IP或反向代理域名来配置私有镜像加速服务. 请注意镜像加速的 HTTP/HTTPS 协议,以及开放防火墙端口. 私有域名镜像加速 { \"registry-mirrors\": [ \"https://registry.yourdomain.com\" ] } 私有IP镜像加速 { \"registry-mirrors\": [ \"http://101.102.103.104:5000\" ] } ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:10","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"配置私有仓库 私有仓库可以使用内网 IP和公网 IP的形式配置. 使用反向代理配置了域名的私有仓库无需配置daemon.json. 内网IP { \"insecure-registries\": [ \"192.168.1.5:5000\" ] } 公网IP { \"insecure-registries\": [ \"101.102.103.104:5000\" ] } 同时配置镜像加速和私有仓库 { \"registry-mirrors\": [\"https://registry.yourdomain.com\"], \"insecure-registries\": [\"192.168.1.5:5000\"] } 更多的镜像加速服务和私有仓库 { \"registry-mirrors\": [ \"https://registry.yourdomain.com\", \"https://hub-mirror.c.163.com\", \"https://mirror.baidubce.com\" ], \"insecure-registries\": [ \"192.168.1.5:5000\", \"101.102.103.104:5000\" ] } ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:1:11","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"Docker迁移/var/lib/docker目录 ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:2:0","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"前言 由于/var/lib/docker/overlay2目录占用磁盘空间过大,即使使用docker system prune -a命令也无法清理overlay2目录下的文件,手动删除则会导致容器无法启动.所以只有将 docker 根目录迁移至空间更大的目录. 迁移流程 停止docker服务 systemctl stop docker 迁移目录 创建新的 docker 根目录,确保创建的目录空间容量够大. mkdir -p /home/docker/lib 迁移/var/lib/docker目录至/home/docker/lib rsync -avz /var/lib/docker /home/docker/lib/ 配置devicemapper.conf,先查看该文件是否存在.如不存在则新建. mkdir -p /etc/systemd/system/docker.service.d/ vi /etc/systemd/system/docker.service.d/devicemapper.conf 写入以下代码保存: [Service] ExecStart= ExecStart=/usr/bin/dockerd --graph=/home/docker/lib/docker 重加载 docker systemctl daemon-reload systemctl restart docker systemctl enable docker 检查 执行以下命令检查 docker info 确认显示信息中 Docker Root Dir 路径正确 Docker Root Dir: /home/docker/lib/docker Debug Mode: false Registry: https://index.docker.io/v1/ 完成 再次启动容器,检查无误后可删除原路径/var/lib/docker/中的文件. ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:2:1","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"Docker 私有镜像仓库 安装服务端 本文以部署至公网,开启账号密码,并配置域名反向代理为例. 命令参数过多,为方便配置参数,建议使用docker compose部署. 创建htpasswd账号密码 启动一个一次性容器用于创建账号密码.密码文件路径以/root/registry/htpasswd为例,账号密码以admin和12345678为例. docker run --rm --entrypoint \\ htpasswd httpd:2 -Bbn \\ admin 12345678 \u003e /root/registry/htpasswd docker-compose.yml volumes 挂载htpasswd密码文件,数据目录,时区文件.配置文件config.yml作为高级用户可选挂载. environment 环境变量开启认证,并开启删除镜像功能. version: \"3\" services: registry: image: registry:2 container_name: registry volumes: # - ./config.yml:/etc/docker/registry/config.yml - ./htpasswd:/auth/htpasswd - ./registry:/var/lib/registry - /etc/localtime:/etc/localtime ports: - 5000:5000 environment: - REGISTRY_AUTH=htpasswd - REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd - REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm - REGISTRY_STORAGE_DELETE_ENABLED=true networks: - registry restart: always networks: registry: 启动 docker-compose up -d 成功启动后私有镜像仓库内网地址为: 192.168.1.5:5000 可根据需求使用域名配置反向代理,例如: https://registry.yourdomain.com 注意需开放防火墙 5000 端口 ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:2:2","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"配置客户端 以CentOS为例,创建或修改/etc/docker/daemon.json文件. 注意,如使用域名配置反向代理并开启HTTPS,则无需配daemon.json文件. { \"insecure-registries\": [ \"192.168.1.5:5000\" ] } 或 { \"insecure-registries\": [ \"101.102.103.104:5000\" ] } ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:2:3","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"使用 登录 docker login registry.yourdomain.com docker login 192.168.1.5:5000 docker login 101.102.103.104:5000 # 使用上文创建的账号密码 admin 12345678 登录 登出 docker logout registry.yourdomain.com docker logout 192.168.1.5:5000 docker logout 101.102.103.104:5000 Push 将现有镜像 tag 为私有仓库镜像名 docker images # 获取现有镜像的 IMAGE ID docker tag 102816b1ee7d registry.yourdomain.com/mysql:8.0.13 docker tag 102816b1ee7d 192.168.1.5:5000/mysql:8.0.13 docker tag 102816b1ee7d 101.102.103.104:5000/mysql:8.0.13 Push 至私有镜像仓库 docker push registry.yourdomain.com/mysql:8.0.13 docker push 192.168.1.5:5000/mysql:8.0.13 docker push 101.102.103.104:5000/mysql:8.0.13 Pull docker pull registry.yourdomain.com/mysql:8.0.13 docker pull 192.168.1.5:5000/mysql:8.0.13 docker pull 101.102.103.104:5000/mysql:8.0.13 查看镜像仓库清单 curl -u admin:12345678 -X GET https://registry.yourdomain.com/v2/_catalog 查看镜像 tag 清单 curl -u admin:12345678 -X GET https://registry.yourdomain.com/v2/mysql/tags/list 删除镜像 docker-compose.yml`环境变量中开启`REGISTRY_STORAGE_DELETE_ENABLED=true 获取镜像 digest hash curl -u admin:12345678 --header \"Accept: application/vnd.docker.distribution.manifest.v2+json\" -I -X GET https://registry.yourdomain.com/v2/mysql/manifests/8.0.13 # 获取 digest hash 如下 sha256:45a2a291xxx223123fc03d9be551e362b460exxs56787736919baa 删除镜像清单 curl -u admin:12345678 -I -X DELETE https://registry.yourdomain.com/v2/mysql/manifests/sha256:45a2a291xxx223123fc03d9be551e362b460exxs56787736919baa 清理磁盘空间 docker exec registry bin/registry garbage-collect /etc/docker/registry/config.yml 手动删除目录 完成上述操作后还可以删除存储目录中的空目录文件,如不删除依旧可以被上述查看镜像仓库的命令查询到结果. 依照上文示例,挂载存储目录路径如下: ./registry/docker/registry/v2/repositories ","date":"2022-02-24","objectID":"/docker%E5%9F%BA%E7%A1%80/:2:4","tags":["docker"],"title":"docker基础","uri":"/docker%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"前言 上次安装了Harbor，并没有开启https，不太安全，这次记录下自签名证书来实现https登录。 ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:1:0","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"自签名证书创建过程 创建证书目录 mkdir /root/ca -p cd /root/ca #以下命令创建CA证书 openssl req -newkey rsa:4096 -nodes -sha256 -keyout ca.key -x509 -days 365 -out ca.crt 其中：（req：申请证书签署请求；-newkey 新密钥 ；-x509：可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作，这里用来自签名。） 一路回车出现Common Name 输入IP或域名: Common Name (eg, your name or your server's hostname) []:harbor.lhp.com ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:2:0","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"生成证书签名请求 openssl req -newkey rsa:4096 -nodes -sha256 -keyout harbor.lhp.com.key 一路回车出现Common Name 输入IP或域名 Common Name (eg, your name or your server's hostname) []:harbor.lhp.com ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:2:1","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"生成x509 v3 扩展文件 cat \u003e v3.ext \u003c\u003c-EOF authorityKeyIdentifier=keyid,issuer basicConstraints=CA:FALSE keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment extendedKeyUsage = serverAuth subjectAltName = DNS:harbor.lhp.com EOF ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:2:2","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"生成主机证书 openssl x509 -req -sha512 -days 3650 \\ -extfile v3.ext \\ -CA ca.crt -CAkey ca.key -CAcreateserial \\ -in harbor.lhp.com.csr \\ -out harbor.lhp.com.crt ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:2:3","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"增加docker证书可信 openssl x509 -inform PEM -in harbor.lhp.com.crt -out harbor.lhp.com.cert mkdir -p /etc/docker/certs.d/ cp harbor.lhp.com.cert /etc/docker/certs.d/harbor.lhp.com/ cp harbor.lhp.com.key /etc/docker/certs.d/harbor.lhp.com/ cp ca.crt /etc/docker/certs.d/harbor.lhp.com/ ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:2:4","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"重启docker /etc/init.d/docker restart ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:2:5","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"配置harbor.yml #set hostname hostname = harbor.lhp.com #域名或ip #set ui_url_protocol uiurlprotocol = https #这里改为https**** ...... #The path of cert and key files for nginx, they are applied only the protocol is set to https ssl_cert = /root/ca/harbor.lhp.com.crt #crt位置 ssl_cert_key = /root/ca/harbor.lhp.com.key #key的位置 ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:2:6","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"配置启动harbor #到harbor安装目录下更新配置文件 ./prepare #启动harbor docker-compose -f docker-compose.yml up -d ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:2:7","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"测试 https://harbor.lhp.com ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:3:0","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"重新登录harbor报错 x509 重新编辑/etc/docker/daemon.json文件 { \"registry-mirrors\": [\"https://jliunkl7.mirror.aliyuncs.com\"], \"insecure-registries\": [\"harbor.lhp.com\"] } 重启docker即可. 官方参考 ","date":"2022-02-21","objectID":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/:3:1","tags":["hatbor"],"title":"harbor使用自签名证书实现https登录","uri":"/harbor%E4%BD%BF%E7%94%A8%E8%87%AA%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6%E5%AE%9E%E7%8E%B0https%E7%99%BB%E5%BD%95/"},{"categories":["工具"],"content":"前言 由于我使用的ubuntu20.04中docker所启动的服务除了本机能访问，局域网中其他设备都无法访问。容器端口和windows本机端口不相通，需要windows开启端口转发。网上找了好多资料发现有位github用户开发的脚本简单易用并且能完美解决端口转发问题。 ","date":"2022-02-21","objectID":"/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%9C%AC%E6%9C%BAwsl2%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1/:1:0","tags":["wsl2"],"title":"局域网中其他主机访问本机wsl2中的服务","uri":"/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%9C%AC%E6%9C%BAwsl2%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1/"},{"categories":["工具"],"content":"windows上使用 链接 下载wslpp.exe即可使用，默认所有IP都能访问本机的docker生成的服务端口，并且不用配置。 ","date":"2022-02-21","objectID":"/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%9C%AC%E6%9C%BAwsl2%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1/:1:1","tags":["wsl2"],"title":"局域网中其他主机访问本机wsl2中的服务","uri":"/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%9C%AC%E6%9C%BAwsl2%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1/"},{"categories":["工具"],"content":"linux中使用 环境 wsl中必须安装net-tools工具 sudo apt-get install net-tools 在Windows PowerShell中, 将其clone到本地: git clone https://github.com/HobaiRiku/wsl2-auto-portproxy.git 在WSL2中, 编译此项目,注意,是需要Go的环境的, 而且这一步骤需要在Windows的管理员模式进行 sudo apt install golang-go cd /mnt/c/Users/`windows-user-name`/wsl2-auto-portproxy/ make build 配置wslpp的配置文件, 在WSL中执行 mkdir /mnt/c/Users/14408/.wslpp vim /mnt/c/Users/14408/.wslpp/config.json 输入: { \"onlyPredefined\": true, \"predefined\": { \"tcp\": [ \"22:22\" ] }, \"ignore\": { \"tcp\": [ 445 ] } }: 回到Windows PowerShell中, 执行: cd .\\wsl2-auto-portproxy\\dist\\ .\\wslpp.exe 此外, WSL操作Windows的文件,是需要在管理员模式下进行的. ","date":"2022-02-21","objectID":"/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%9C%AC%E6%9C%BAwsl2%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1/:1:2","tags":["wsl2"],"title":"局域网中其他主机访问本机wsl2中的服务","uri":"/%E5%B1%80%E5%9F%9F%E7%BD%91%E4%B8%AD%E5%85%B6%E4%BB%96%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%9C%AC%E6%9C%BAwsl2%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1/"},{"categories":["工具"],"content":"前言 Harbor 是一个开源的容器镜像仓库，它提供用户权限管理、镜像复制等功能，提高使用的registry的效率。确保镜像被扫描并且没有漏洞，并将镜像标记为可信。 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:1:0","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"harbor架构 主要组件包括proxy，他是一个nginx前端代理，主要是分发前端页面ui访问和镜像上传和下载流量，上图中通过深蓝色先标识； ui提供了一个web管理页面，当然还包括了一个前端页面和后端API，底层使用mysql数据库。 registry是镜像仓库，负责存储镜像文件，当镜像上传完毕后通过hook通知ui创建repository，上图通过红色线标识，当然registry的token认证也是通过ui组件完成。 adminserver是系统的配置管理中心附带检查存储用量，ui和jobserver启动时候回需要加载adminserver的配置，通过灰色线标识。jobsevice是负责镜像复制工作的，他和registry通信，从一个registry pull镜像然后push到另一个registry，并记录job_log，上图通过紫色线标识。 log是日志汇总组件，通过docker的log-driver把日志汇总到一起，通过浅蓝色线条标识。 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:2:0","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"环境准备 运行环境 Ubuntu 20.04 LTS docker-ce：20.10.12 docker-compose：v2.2.3 harbor-offline：v1.10.10 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:3:0","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"安装docker 官方安装参考 我是在wsl2中使用ubuntu 20.04系统安装docker的。 删除旧版docker sudo apt-get remove docker docker-engine docker.io containerd runc 如果之前安装过docker,那么所有配置文件都在/var/lib/docker/中,包括images, containers, volumes, and networks。 不用可以删除。 开始安装设置repo源 sudo apt-get update sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 添加Docker的官方GPG key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 设置稳定版repo源 echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 安装docker-ce sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io 测试安装是否成功 sudo docker run hello-world 安装docker-compose harbor需要用docker-compose来管理。 源码地址：https://github.com/docker/compose/releases 下载指定版本。 curl -L https://github.com/docker/compose/releases/download/v2.2.3/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose 添加执行权限。 chmod +x /usr/local/bin/docker-compose 验证一下。 $docker-compose --version 输出： Docker Compose version v2.2.3 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:4:0","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"安装 harbor 源码地址：https://github.com/goharbor/harbor/releases 项目分有在线版，以及离线版，这里使用离线版的安装。 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:0","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"下载安装包。 wget https://github.com/goharbor/harbor/releases/download/v1.10.10/harbor-offline-installer-v1.10.10.tgz 或许用迅雷下载，速度更佳。 解压安装包。 mkdir -p softwere cd /root/softwere mv harbor-offline-installer-v1.10.10.tgz /root/softwere tar xvf harbor-offline-installer-v1.10.10.tgz ls harbor LICENSE common common.sh docker-compose.yml harbor.v1.10.10.tar.gz harbor.yml install.sh prepare ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:1","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"更改配置 这里使用域名+5000端口来访问，关闭https。完整配置如下： vim harbor.yml # Configuration file of Harbor # The IP address or hostname to access admin UI and registry service. # DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients. hostname: harbor.lhp.com # http related config http: # port for http, default is 80. If https enabled, this port will redirect to https port port: 5000 # https related config # https: # https port for harbor, default is 443 # port: 443 # The path of cert and key files for nginx # certificate: /your/certificate/path # private_key: /your/private/key/path # Uncomment external_url if you want to enable external proxy # And when it enabled the hostname will no longer used # external_url: https://reg.mydomain.com:8433 # The initial password of Harbor admin # It only works in first time to install harbor # Remember Change the admin password from UI after launching Harbor. harbor_admin_password: Toor12345 # Harbor DB configuration database: # The password for the root user of Harbor DB. Change this before any production use. password: root123 # The maximum number of connections in the idle connection pool. If it \u003c=0, no idle connections are retained. max_idle_conns: 50 # The maximum number of open connections to the database. If it \u003c= 0, then there is no limit on the number of open connections. # Note: the default number of connections is 100 for postgres. max_open_conns: 100 # The default data volume data_volume: /data # Harbor Storage settings by default is using /data dir on local filesystem # Uncomment storage_service setting If you want to using external storage # storage_service: # # ca_bundle is the path to the custom root ca certificate, which will be injected into the truststore # # of registry's and chart repository's containers. This is usually needed when the user hosts a internal storage with self signed certificate. # ca_bundle: # # storage backend, default is filesystem, options include filesystem, azure, gcs, s3, swift and oss # # for more info about this configuration please refer https://docs.docker.com/registry/configuration/ # filesystem: # maxthreads: 100 # # set disable to true when you want to disable registry redirect # redirect: # disabled: false # Clair configuration clair: # The interval of clair updaters, the unit is hour, set to 0 to disable the updaters. updaters_interval: 12 jobservice: # Maximum number of job workers in job service max_job_workers: 10 notification: # Maximum retry count for webhook job webhook_job_max_retry: 10 chart: # Change the value of absolute_url to enabled can enable absolute url in chart absolute_url: disabled # Log configurations log: # options are debug, info, warning, error, fatal level: info # configs for logs in local storage local: # Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated. rotate_count: 50 # Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes. # If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G # are all valid. rotate_size: 200M # The directory on your host that store log location: /var/log/harbor # Uncomment following lines to enable external syslog endpoint. # external_endpoint: # # protocol used to transmit log to external endpoint, options is tcp or udp # protocol: tcp # # The host of external endpoint # host: localhost # # Port of external endpoint # port: 5140 #This attribute is for migrator to detect the version of the .cfg file, DO NOT MODIFY! _version: 1.10.0 # Uncomment external_database if using external database. # external_database: # harbor: # host: harbor_db_host # port: harbor_db_port # db_name: harbor_db_name # username: harbor_db_username # password: harbor_db_password # ssl_mode: disable # max_idle_conns: 2 # max_open_conns: 0 # clair: # host: clair_db_h","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:2","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"添加映射关系 vi /etc/hosts 172.28.238.43 harbor.lhp.com ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:3","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"windows也需要添加映射关系 用管理员用户编辑C:\\Windows\\System32\\drivers\\etc\\hosts #同样添加下面内容 172.28.238.43 harbor.lhp.com ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:4","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"修改后刷新 ipconfig /flushdns 配置daemon.json，docker登录harbor时需要。 vi /etc/docker/daemon.json { \"registry-mirrors\": [\"https://jliunkl7.mirror.aliyuncs.com\"], \"insecure-registries\": [\"harbor.lhp.com:5000\"] } ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:5","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"重启docker service docker stop service docker start ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:6","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"执行install.sh脚本安装 ./install.sh ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:7","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"测试访问harbor http://harbor.lhp.com:5000 用户名：admin 密码：Toor12345 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:8","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"docker登录harbor docker login -u admin http://harbor.lhp.com:5000 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:9","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"harbor创建项目 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:10","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"测试上传和下载到harbor #push docker tag alpine:latest harbor.lhp.com:5000/images/alpine:latest docker push harbor.lhp.com:5000/images/alpine:latest #pull docker pull harbor.lhp.com:5000/images/alpine:latest portainer中添加harbor仓库。以后就可以在portainer中可视化上传和下载镜像啦！ ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:5:11","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"登录portainer并新增仓库 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:6:0","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"测试上传和下载。 镜像打tag时注意要在镜像前加harbor项目文件夹，文中的为images。 将busybox:latest上传到harbor的images中。 进入busybox镜像并打tag，注意格式。 上传镜像到harbor仓库 harbor中查看 harbor上拉取镜像操作 选择要拉取的镜像并拉取。 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:6:1","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"harbor登录时遇到的坑 如果显示harbor登录失败，而密码又是harbor.yml中设置的密码。此时需要停止harbor所有相关镜像。进入到harbor安装目录。 cd /root/softwere/harbor #停止harbor所有相关镜像 docker-compose down -v #开启harbor所有相关镜像 docker-compose up -d 停止docker服务，删除harbor的数据卷,清除日志，路径在harbor.yml中。 rm -rf /data rm -rf /var/log/harbor #path data_volume: /data location: /var/log/harbor 最后删除harbor文件夹，重新解压安装即可。 rm -rf /root/softwere/harbor cd /root/softwere/ tar -xf harbor.v1.10.10.tar.gz ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:7:0","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"其他功能-Harbor镜像漏洞扫描 安装harbor自带的漏洞扫描 添加扫描模块 #进入到harbor目录中操作 ./prepare --with-clair prepare base dir is set to /root/softwere/harbor /usr/src/app/utils/configs.py💯 YAMLLoadWarning: calling yaml.load() without Loader=... is deprecated, as the default Loader is unsafe. Please read https://msg.pyyaml.org/load for full details. configs = yaml.load(f) WARNING:root:WARNING: HTTP protocol is insecure. Harbor will deprecate http protocol in the future. Please make sure to upgrade to httpsClearing the configuration file: /config/db/env Clearing the configuration file: /config/jobservice/env Clearing the configuration file: /config/jobservice/config.yml Clearing the configuration file: /config/nginx/nginx.conf Clearing the configuration file: /config/registryctl/env Clearing the configuration file: /config/registryctl/config.yml Clearing the configuration file: /config/registry/root.crt Clearing the configuration file: /config/registry/config.yml Clearing the configuration file: /config/core/env Clearing the configuration file: /config/core/app.conf Clearing the configuration file: /config/log/rsyslog_docker.conf Clearing the configuration file: /config/log/logrotate.conf Generated configuration file: /config/log/logrotate.conf Generated configuration file: /config/log/rsyslog_docker.conf Generated configuration file: /config/nginx/nginx.conf Generated configuration file: /config/core/env Generated configuration file: /config/core/app.conf Generated configuration file: /config/registry/config.yml Generated configuration file: /config/registryctl/env Generated configuration file: /config/db/env Generated configuration file: /config/jobservice/env Generated configuration file: /config/jobservice/config.yml loaded secret from file: /secret/keys/secretkey Generated configuration file: /config/clair/postgres_env Generated configuration file: /config/clair/config.yaml Generated configuration file: /config/clair/clair_env Generated configuration file: /config/clair-adapter/env Generated configuration file: /compose_location/docker-compose.yml /usr/src/app/utils/configs.py:90: YAMLLoadWarning: calling yaml.load() without Loader=... is deprecated, as the default Loader is unsafe. Please read https://msg.pyyaml.org/load for full details. versions = yaml.load(f) Clean up the input dir #会自动生成docker-compose.yml文件 ➜ harbor ls LICENSE common common.sh docker-compose.yml harbor.v1.10.10.tar.gz harbor.yml install.sh prepare 重启启动harbor服务（注意这里要指定docker-compose.yaml文件） docker-compose -f docker-compose.yml up -d 测试扫描 可以看到在项目里面已经显示安装好了扫描器插件，不安装这里是没有的。 选择镜像我们就可以进行扫描了。 镜像未扫描前 镜像扫描后 ","date":"2022-02-18","objectID":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:8:0","tags":["harbor"],"title":"harbor安装与简单使用","uri":"/harbor%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"前言 Portainer是一款轻量级的Docker图形化管理的方案，相比k8s和k3s，只需要创建一个容器！ 功能点： 多平台支持：Linux/Windows/OSX 控制面板分类展示 技术栈分类展示：使用swarm或docker-compose等启动的服务/集群会在这里出现 管理容器生命周期 应用模板快速部署 管理Swarm集群或多服务器的镜像/容器/卷/网络 操作事件日志记录 容器控制台日志展示 使用多个Docker仓库私服pull/push镜像 用户权限管理功能（需付费$9.9） ","date":"2022-02-17","objectID":"/wsl2%E4%B8%ADportainer%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:0","tags":["wsl2"],"title":"wsl2中Portainer容器可视化管理工具的安装与使用","uri":"/wsl2%E4%B8%ADportainer%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"安装 官方文档 首先，创建 Portainer Server 将用于存储其数据库的卷： docker volume create portainer_data 然后，下载并安装 Portainer Server 容器: docker run -d -p 8000:8000 -p 9000:9000 -p 9443:9443 \\ --name=portainer --restart=always \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v portainer_data:/data \\ portainer/portainer-ce:2.11.1 查看是否启动 ➜ ~ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bb2b73d4a4a6 portainer/portainer-ce:2.11.1 \"/portainer\" 2 hours ago Up About an hour 0.0.0.0:8000-\u003e8000/tcp, :::8000-\u003e8000/tcp, 0.0.0.0:9443-\u003e9443/tcp, :::9443-\u003e9443/tcp, 9000/tcp portainer 登录 https://localhost:9443 注意:localhost可以改成IP 第一次登录需要初始化环境，创建超级管理员用户名和密码。 进入后会自动扫描容器环境 升级参考官方文档 ","date":"2022-02-17","objectID":"/wsl2%E4%B8%ADportainer%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:0","tags":["wsl2"],"title":"wsl2中Portainer容器可视化管理工具的安装与使用","uri":"/wsl2%E4%B8%ADportainer%E5%AE%B9%E5%99%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"前言 由于wsl2每次启动IP都会改变，查阅微软官方文档后发现wsl2无法设置静态IP。然而dockers私有仓库registry中IP配置是固定的。所以需要自定义脚本实时获取wsl2本机IP，并复制到/etc/docker/daemon.json中对应的IP位置。还需要创建系统服务启动脚本。以下内容均在ubuntu 20.04 LTS中实现。 ","date":"2022-02-17","objectID":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/:1:0","tags":["脚本"],"title":"使用脚本获取本机IP并复制到registry配置文件中","uri":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/"},{"categories":["工具"],"content":"思路 要想实现需求，可以使用bash中多脚本之间变量传递。参考 ","date":"2022-02-17","objectID":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/:2:0","tags":["脚本"],"title":"使用脚本获取本机IP并复制到registry配置文件中","uri":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/"},{"categories":["工具"],"content":"获取wsl2本机IP vi /root/init_code/get-ip.sh \u0026\u0026 chmod +x /root/init_code/get-ip.sh var=`hostname -I | awk '{print $1}'` echo $var ","date":"2022-02-17","objectID":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/:2:1","tags":["脚本"],"title":"使用脚本获取本机IP并复制到registry配置文件中","uri":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/"},{"categories":["工具"],"content":"查看文本格式 cat /etc/docker/daemon.json { \"registry-mirrors\": [\"https://8xpk5wnt.mirror.aliyuncs.com\"], \"insecure-registries\": [\"172.26.133.115:5000\"] } ","date":"2022-02-17","objectID":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/:2:2","tags":["脚本"],"title":"使用脚本获取本机IP并复制到registry配置文件中","uri":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/"},{"categories":["工具"],"content":"创建脚本来更改daemon.json中对应IP vi chang-daemon.sh \u0026\u0026 chmod +x chang-daemon.sh #!/bin/bash source /root/init_code/get-ip.sh echo \"{ \\\"registry-mirrors\\\": [\\\"https://8xpk5wnt.mirror.aliyuncs.com\\\"], \\\"insecure-registries\\\": [\\\"$var:5000\\\"] } \" \u003e /etc/docker/daemon.json 在脚本2中使用source 来引用脚本1中的变量。如何打印出双引号？双引号前加反斜杠。 例如： 打印出\"Hello World!\" echo \"\\\"Hello World!\"\\\" ","date":"2022-02-17","objectID":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/:2:3","tags":["脚本"],"title":"使用脚本获取本机IP并复制到registry配置文件中","uri":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/"},{"categories":["工具"],"content":"创建开机自启动脚本 vi /root/init_code/init_myservice.sh #启动ssh服务和docker服务 sudo service ssh restart sudo service docker start ","date":"2022-02-17","objectID":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/:2:4","tags":["脚本"],"title":"使用脚本获取本机IP并复制到registry配置文件中","uri":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/"},{"categories":["工具"],"content":"创建查看仓库中镜像脚本 vi /root/init_code/watch-myregistry.sh #!/bin/bash source /root/init_code/get-ip.sh curl -XGET http://$var:5000/v2/_catalog 搭建私有仓库命令 docker run -d --name registry -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always registry ","date":"2022-02-17","objectID":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/:2:5","tags":["脚本"],"title":"使用脚本获取本机IP并复制到registry配置文件中","uri":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/"},{"categories":["工具"],"content":"附加 wsl2中使用systemctl启动服务报错如下 ➜ ~ systemctl restart docker System has not been booted with systemd as init system (PID 1). Can't operate. Failed to connect to bus: Host is down wsl2中默认使用System V init 来管理系统服务，而不是systemd。所以不能运行systemd中的命令。 Systemd command和Sysvinit command命令对照表 Systemd command Sysvinit command systemctl start service_name service service_name start systemctl stop service_name service service_name stop systemctl restart service_name service service_name restart systemctl status service_name service service_name status systemctl enable service_name chkconfig service_name on systemctl disable service_name chkconfig service_name off wsl2中使用chkconfig 命令设置服务开机自启动没效果，所以最后还是使用脚本来实现。 查看当前系统服务管理机制 使用sysvinit管理服务 ➜ ~ ps -p 1 -o comm= init 使用systemd管理服务 [root@localhost ~]# ps -p 1 -o comm= systemd ","date":"2022-02-17","objectID":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/:3:0","tags":["脚本"],"title":"使用脚本获取本机IP并复制到registry配置文件中","uri":"/%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BAip%E5%B9%B6%E5%A4%8D%E5%88%B6%E5%88%B0registry%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD/"},{"categories":["linux"],"content":"简介 混杂模式就是接收所有经过网卡的数据包，包括不是发给本机的包，即不验证MAC地址。普通模式下网卡只接收发给本机的包（包括广播包）传递给上层程序，其它的包一律丢弃。 一般来说，混杂模式不会影响网卡的正常工作，多在网络监听工具上使用。 ","date":"2022-02-14","objectID":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/:1:0","tags":["linux混杂模式"],"title":"linux下混杂模式判断","uri":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/"},{"categories":["linux"],"content":"网卡工作模式 广播模式（Broad Cast Model）:它的物理地址（MAC）地址是 0Xffffff 的帧为广播帧，工作在广播模式的网卡接收广播帧。 多播传送（MultiCast Model）：多播传送地址作为目的物理地址的帧可以被组内的其它主机同时接收，而组外主机却接收不到。但是，如果将网卡设置为多播传送模式，它可以接收所有的多播传送帧，而不论它是不是组内成员。 直接模式（Direct Model）:工作在直接模式下的网卡只接收目地址是自己 Mac地址的帧。 混杂模式（Promiscuous Model）:工作在混杂模式下的网卡接收所有的流过网卡的帧，信包捕获程序就是在这种模式下运行的。 网卡的缺省工作模式包含广播模式和直接模式，即它只接收广播帧和发给自己的帧。如果采用混杂模式，一个站点的网卡将接受同一网络内所有站点所发送的数据包这样就可以到达对于网络信息监视捕获的目的。 ","date":"2022-02-14","objectID":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/:2:0","tags":["linux混杂模式"],"title":"linux下混杂模式判断","uri":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/"},{"categories":["linux"],"content":"开启混杂模式 Linux下设置把网卡设置成混杂模式的命令也很简单。 ifconfig ens33 promisc cat /sys/class/net/ens33/flags ","date":"2022-02-14","objectID":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/:3:0","tags":["linux混杂模式"],"title":"linux下混杂模式判断","uri":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/"},{"categories":["linux"],"content":"取消混杂模式 ifconfig ens33 -promisc cat /sys/class/net/ens33/flags ","date":"2022-02-14","objectID":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/:4:0","tags":["linux混杂模式"],"title":"linux下混杂模式判断","uri":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/"},{"categories":["linux"],"content":"拓展 使用tcpdump工具抓包时，抓包的网口会临时变成混杂模式。 [root@nginx140 ~]# tcpdump -i ens33 -vv -nn -w ./test.cap tcpdump: listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes ^C537 packets captured 540 packets received by filter 0 packets dropped by kernel 抓包的同时查看对应网卡标志位 [root@nginx140 ~]# cat /sys/class/net/ens33/flags 0x1103 ","date":"2022-02-14","objectID":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/:5:0","tags":["linux混杂模式"],"title":"linux下混杂模式判断","uri":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/"},{"categories":["linux"],"content":"总结 当网卡的标志位为0x1003时，没有开启混杂模式。而网卡标志位为0x1103时，说明该网卡开启了混杂模式。 ","date":"2022-02-14","objectID":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/:6:0","tags":["linux混杂模式"],"title":"linux下混杂模式判断","uri":"/linux%E4%B8%8B%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD/"},{"categories":["问题"],"content":"备份原repo mv /etc/yum.repos.d/rhel-source.repo /etc/yum.repos.d/rhel-source.repo-old ","date":"2022-02-12","objectID":"/redhat6.3yum%E6%BA%90%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/:1:0","tags":["yum源失效"],"title":"redhat6.3的yum源失效解决","uri":"/redhat6.3yum%E6%BA%90%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/"},{"categories":["问题"],"content":"新建repo文件 vi /etc/yum.repos.d/rhel-source.repo # CentOS-Base.repo # # The mirror system uses the connecting IP address of the client and the # update status of each mirror to pick mirrors that are updated to and # geographically close to the client. You should use this for CentOS updates # unless you are manually picking other mirrors. # # If the mirrorlist= does not work for you, as a fall back you can try the # remarked out baseurl= line instead. # # [base] name=CentOS-6.5 - Base - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos-vault/6.5/os/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6 #released updates [updates] name=CentOS-6.5 - Updates - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos-vault/6.5/updates/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6 #additional packages that may be useful [extras] name=CentOS-6.5 - Extras - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos-vault/6.5/extras/$basearch/ gpgcheck=1 gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6 #additional packages that extend functionality of existing packages [centos-vaultplus] name=CentOS-6.5 - Plus - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos-vault/6.5/centos-vaultplus/$basearch/ gpgcheck=1 enabled=0 gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6 #contrib - packages by Centos Users [contrib] name=CentOS-6.5 - Contrib - mirrors.aliyun.com failovermethod=priority baseurl=http://mirrors.aliyun.com/centos-vault/6.5/contrib/$basearch/ gpgcheck=1 enabled=0 gpgkey=http://mirrors.aliyun.com/centos-vault/RPM-GPG-KEY-CentOS-6 ","date":"2022-02-12","objectID":"/redhat6.3yum%E6%BA%90%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/:2:0","tags":["yum源失效"],"title":"redhat6.3的yum源失效解决","uri":"/redhat6.3yum%E6%BA%90%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/"},{"categories":["问题"],"content":"清除缓存并重建缓存 yum clean all \u0026\u0026 yum makecache ","date":"2022-02-12","objectID":"/redhat6.3yum%E6%BA%90%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/:3:0","tags":["yum源失效"],"title":"redhat6.3的yum源失效解决","uri":"/redhat6.3yum%E6%BA%90%E5%A4%B1%E6%95%88%E8%A7%A3%E5%86%B3/"},{"categories":["工具"],"content":"简介 logrotate 程序是一个日志文件管理工具。用于分割日志文件，删除旧的日志文件，并创建新的日志文件，起到“转储”作用。可以节省磁盘空间。下面就对 logrotate 日志轮转操作做一梳理记录。 logrotate 是基于 crontab 运行的，所以这个时间点是由 crontab 控制的，具体可以查询 crontab 的配置文件 /etc/anacrontab。 系统会按照计划的频率运行 logrotate，通常是每天。在大多数的 Linux 发行版本上，计划每天运行的脚本位于 /etc/cron.daily/logrotate。 主流 Linux 发行版上都默认安装有 logrotate 包，如果你的 linux 系统中找不到 logrotate, 可以使用 apt-get 或 yum 命令来安装。 logrotate运行机制 logrotate 在很多 Linux 发行版上都是默认安装的。系统会定时运行 logrotate，一般是每天一次。系统是这么实现按天执行的。crontab 会每天定时执行 /etc/cron.daily 目录下的脚本，而这个目录下有个文件叫 logrotate。在 centos 上脚本内容是这样的： 系统自带 cron task：/etc/cron.daily/logrotate，每天运行一次。 [root@localhost logrotate.d]# cat /etc/cron.daily/logrotate #!/bin/sh /usr/sbin/logrotate -s /var/lib/logrotate/logrotate.status /etc/logrotate.conf EXITVALUE=$? if [ $EXITVALUE != 0 ]; then /usr/bin/logger -t logrotate \"ALERT exited abnormally with [$EXITVALUE]\" fi exit 0 可以看到这个脚本主要做的事就是以 /etc/logrotate.conf 为配置文件执行了 logrotate。就是这样实现了每天执行一次 logrotate。 自定义周期滚动日志 因为我的系统执行 /etc/cron.daily 目录下的脚本不是我想滚动日志的时间，所以我把 /etc/cron.daily/logrotate 拷了出来，改了一下 logrotate 配置文件的路径，然后在 crontab 里加上一条指定时间执行这个脚本的记录，自定义周期滚动日志就大功告成了。这种自定义的方式有两点要注意： 配置文件里一定要配置 rotate 文件数目这个参数。如果不配置默认是 0 个，也就是只允许存在一份日志，刚切分出来的日志会马上被删除。 执行 logrotate 命令最好加 -f 参数，不然有时候配置文件修改的内容不生效。 很多程序的会用到 logrotate 滚动日志，比如 nginx。它们安装后，会在 /etc/logrotate.d 这个目录下增加自己的 logrotate 的配置文件。logrotate 什么时候执行 /etc/logrotate.d 下的配置呢？看到 /etc/logrotate.conf 里这行，一切就不言而喻了。 include /etc/logrotate.d 安装 先检查服务器有没有安装 rpm -qa | grep crontab 安装 yum -y install vixie-cron yum -y install crontabs 简单说明： vixie-cron 是 cron 的主程序； crontabs 是用来安装、卸装、或列举用来驱动 cron 守护进程的表格的程序。 安装好后启动和配置服务 service crond start //启动服务 service crond stop //关闭服务 service crond restart //重启服务 service crond reload //重新载入配置 service crond status //查看crontab服务状态 设置开机自启 chkconfig --level 345 crond on 简单定时脚本 [root@localhost ~]# vim test.sh nowtime=`date +\"%Y-%m-%d %H:%M:%S\"` echo \"hello cron \"$nowtime 添加执行权限 [root@localhost~]# chmod +x test.sh 运行： [root@localhost ~]# ./test.sh hello cron 2022-01-09 19:54:30 添加定时任务。每一分钟执行一次 运行crontab -e */1 * * * * /root/test.sh \u003e\u003e /root/test.log 配置文件介绍 Linux系统默认安装logrotate工具，它默认的配置文件在： /etc/logrotate.conf /etc/logrotate.d/ logrotate.conf 才是主要的配置文件，logrotate.d 是一个目录，该目录里的所有文件都会被主动的读入/etc/logrotate.conf中执行。另外，如果 /etc/logrotate.d/ 里面的文件中没有设定一些细节，则会以/etc/logrotate.conf这个文件的设定来作为默认值。 Logrotate是基于CRON来运行的，其脚本是/etc/cron.daily/logrotate，日志轮转是系统自动完成的。实际运行时，Logrotate会调用配置文件/etc/logrotate.conf。可以在/etc/logrotate.d目录里放置自定义好的配置文件，用来覆盖Logrotate的缺省值。 [root@localhost ~]# cat /etc/cron.daily/logrotate #!/bin/sh /usr/sbin/logrotate /etc/logrotate.conf \u003e/dev/null 2\u003e\u00261 EXITVALUE=$? if [ $EXITVALUE != 0 ]; then /usr/bin/logger -t logrotate \"ALERT exited abnormally with [$EXITVALUE]\" fi exit 0 如果等不及cron自动执行日志轮转，想手动强制切割日志，需要加-f参数；不过正式执行前最好通过Debug选项来验证一下（-d参数），这对调试也很重要： /usr/sbin/logrotate -f /etc/logrotate.d/nginx /usr/sbin/logrotate -d -f /etc/logrotate.d/nginx logrotate 命令格式： logrotate [OPTION...] \u003cconfigfile\u003e -d, --debug ：debug模式，测试配置文件是否有错误。 -f, --force ：强制转储文件。 -m, --mail=command ：压缩日志后，发送日志到指定邮箱。 -s, --state=statefile ：使用指定的状态文件。 -v, --verbose ：显示转储过程。 根据日志切割设置进行操作，并显示详细信息： [root@localhost ~]# /usr/sbin/logrotate -v /etc/logrotate.conf [root@localhost ~]# /usr/sbin/logrotate -v /etc/logrotate.d/php 根据日志切割设置进行执行，并显示详细信息,但是不进行具体操作，debug模式 [root@localhost ~]# /usr/sbin/logrotate -d /etc/logrotate.conf [root@localhost ~]# /usr/sbin/logrotate -d /etc/logrotate.d/nginx 查看各log文件的具体执行情况 [root@localhost ~]# cat /var/lib/logrotate.status 切割介绍 比如以系统日志/var/log/message做切割来简单说明下： 第一次执行完rotate(轮转)之后，原本的messages会变成messages.1，而且会制造一个空的messages给系统来储存日志； 第二次执行之后，messages.1会变成messages.2，而messages会变成messages.1，又造成一个空的messages来储存日志！ 如果仅设定保留三个日志（即轮转3次）的话，那么执行第三次时，则 messages.3这个档案就会被删除，并由后面的较新的保存日志所取代！也就是会保存最新的几个日志。 日志究竟轮换几次，这个是根据配置文件中的dateext 参数来判定的。 ","date":"2022-02-12","objectID":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/:0:0","tags":["logrotate"],"title":"使用logrotate进行日志切割","uri":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/"},{"categories":["工具"],"content":"logrotate.conf配置 cat /etc/logrotate.conf 底下的设定是 “logrotate 的默认值” ，如果別的文件设定了其他的值，就会以其它文件的设定为主 weekly //默认每一周执行一次rotate轮转工作 rotate 4 // 保留多少个日志文件(轮转几次).默认保留四个.就是指定日志文件删除之前轮转的次数，0 指没有备份 create //自动创建新的日志文件，新的日志文件具有和原来的文件相同的权限；因为日志被改名,因此要创建一个新的来继续存储之前的日志 dateext // 这个参数很重要！就是切割后的日志文件以当前日期为格式结尾，如xxx.log-20131216这样,如果注释掉,切割出来是按数字递增,即前面说的 xxx.log-1这种格式 compress //是否通过gzip压缩转储以后的日志文件，如xxx.log-20131216.gz ；如果不需要压缩，注释掉就行 include /etc/logrotate.d //将 /etc/logrotate.d/ 目录中的所有文件都加载进来 /var/log/wtmp { //仅针对 /var/log/wtmp 所设定的参数 monthly //每月一次切割,取代默认的一周 minsize 1M //文件大小超过 1M 后才会切割 create 0664 root utmp //指定新建的日志文件权限以及所属用户和组 rotate 1 //只保留一个日志. } 这个 wtmp 可记录用户登录系统及系统重启的时间.因为有 minsize 的参数，因此不见得每个月一定会执行一次,要看文件大小。 由这个文件的设定可以知道/etc/logrotate.d其实就是由/etc/logrotate.conf 所规划出来的目录，虽然可以将所有的配置都写入 /etc/logrotate.conf ，但是这样一来这个文件就实在是太复杂了，尤其是当使用很多的服务在系统上面时， 每个服务都要去修改 /etc/logrotate.conf 的设定也似乎不太合理了。 所以，如果独立出来一个目录，那么每个要切割日志的服务， 就可以独自成为一个文件，并且放置到 /etc/logrotate.d/ 当中。 其他重要参数说明： 参数 说明 compress 通过gzip 压缩转储以后的日志 nocompress 不做gzip压缩处理 copytruncate 用于还在打开中的日志文件，把当前日志备份并截断；是先拷贝再清空的方式，拷贝和清空之间有一个时间差，可能会丢失部分日志数据。 nocopytruncate 备份日志文件不过不截断 create mode owner group 轮转时指定创建新文件的属性，如create 0777 nobody nobody nocreate 不建立新的日志文件 delaycompress 和compress 一起使用时，转储的日志文件到下一次转储时才压缩 nodelaycompress 覆盖 delaycompress 选项，转储同时压缩。 missingok 如果日志丢失，不报错继续滚动下一个日志 errors address 转储时的错误信息发送到指定的Email 地址 ifempty 即使日志文件为空文件也做轮转，这个是logrotate的缺省选项。 notifempty 当日志文件为空时，不进行轮转 mail address 把转储的日志文件发送到指定的E-mail 地址 nomail 转储时不发送日志文件 olddir directory 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统 noolddir 转储后的日志文件和当前日志文件放在同一个目录下 sharedscripts 运行postrotate脚本，作用是在所有日志都轮转后统一执行一次脚本。如果没有配置这个，那么每个日志轮转后都会执行一次脚本 prerotate 在logrotate转储之前需要执行的指令，例如修改文件的属性等动作；必须独立成行 postrotate 在logrotate转储之后需要执行的指令，例如重新启动 (kill -HUP) 某个服务！必须独立成行 daily 指定转储周期为每天 weekly 指定转储周期为每周 monthly 指定转储周期为每月 rotate count 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份 dateext 使用当期日期作为命名格式 dateformat .%s 配合dateext使用，紧跟在下一行出现，定义文件切割后的文件名，必须配合dateext使用，只支持 %Y %m %d %s 这四个参数 size(或minsize) log-size 当日志文件到达指定的大小时才转储，log-size能指定bytes(缺省)及KB (sizek)或MB(sizem). 当日志文件 \u003e= log-size 的时候就转储。 以下为合法格式：（其他格式的单位大小写没有试过） size = 5 或 size 5 （\u003e= 5 个字节就转储） size = 100k 或 size 100k size = 100M 或 size 100M ","date":"2022-02-12","objectID":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/:1:0","tags":["logrotate"],"title":"使用logrotate进行日志切割","uri":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/"},{"categories":["工具"],"content":"切割nginx日志的配置 [root@localhost ~]# vim /etc/logrotate.d/nginx /usr/local/nginx/logs/*.log { daily rotate 7 missingok notifempty dateext sharedscripts postrotate if [ -f /usr/local/nginx/logs/nginx.pid ]; then kill -USR1 `cat /usr/local/nginx/logs/nginx.pid` fi endscript } ","date":"2022-02-12","objectID":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/:1:1","tags":["logrotate"],"title":"使用logrotate进行日志切割","uri":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/"},{"categories":["工具"],"content":"关于 USR1 信号解释 USR1 通常被用来告知应用程序重载配置文件；例如，向 Apache HTTP 服务器发送一个 USR1 信号将导致以下步骤的发生：停止接受新的连接，等待当前连接停止，重新载入配置文件，重新打开日志文件，重启服务器，从而实现相对平滑的不关机的更改。 对于 USR1 和 2 都可以用户自定义的，在 POSIX 兼容的平台上，SIGUSR1 和 SIGUSR2 是发送给一个进程的信号，它表示了用户定义的情况。它们的符号常量在头文件 signal.h 中定义。在不同的平台上，信号的编号可能发生变化，因此需要使用符号名称。 kill -HUP pid killall -HUP pName 其中 pid 是进程标识，pName 是进程的名称。 如果想要更改配置而不需停止并重新启动服务，可以使用上面两个命令。在对配置文件作必要的更改后，发出该命令以动态更新服务配置。根据约定，当你发送一个挂起信号 (信号 1 或 HUP) 时，大多数服务器进程 (所有常用的进程) 都会进行复位操作并重新加载它们的配置文件。 ","date":"2022-02-12","objectID":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/:2:0","tags":["logrotate"],"title":"使用logrotate进行日志切割","uri":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/"},{"categories":["工具"],"content":"分享一例曾经使用过的nginx日志切割处理脚本： logrotate日志分割配置 [root@localhost ~# vim /etc/logrotate.d/nginx /data/nginx_logs/*.access_log { nocompress daily copytruncate create ifempty olddir /data/nginx_logs/days rotate 0 } 日志分割脚本 [root@localhost ~# vim /usr/local/sbin/logrotate-nginx.sh #!/bin/bash #创建转储日志压缩存放目录 mkdir -p /data/nginx_logs/days #手工对nginx日志进行切割转换 /usr/sbin/logrotate -vf /etc/logrotate.d/nginx #当前时间 time=$(date -d \"yesterday\" +\"%Y-%m-%d\") #进入转储日志存放目录 cd /data/nginx_logs/days #对目录中的转储日志文件的文件名进行统一转换 for i in $(ls ./ | grep \"^\\(.*\\)\\.[[:digit:]]$\") do mv ${i} ./$(echo ${i}|sed -n 's/^\\(.*\\)\\.\\([[:digit:]]\\)$/\\1/p')-$(echo $time) done #对转储的日志文件进行压缩存放，并删除原有转储的日志文件，只保存压缩后的日志文件。以节约存储空间 for i in $(ls ./ | grep \"^\\(.*\\)\\-\\([[:digit:]-]\\+\\)$\") do tar jcvf ${i}.bz2 ./${i} rm -rf ./${i} done #只保留最近7天的压缩转储日志文件 find /data/nginx_logs/days/* -name \"*.bz2\" -mtime 7 -type f -exec rm -rf {} \\; crontab定时执行 [root@localhost ~# crontab -e #logrotate 0 0 * * * /bin/bash -x /usr/local/sbin/logrotate-nginx.sh \u003e /dev/null 2\u003e\u00261 手动执行脚本，测试下看看： [root@localhost ~# /bin/bash -x /usr/local/sbin/logrotate-nginx.sh [root@localhost ~# cd /data/nginx_logs/days [root@localhost days# ls huantest.access_log-2017-01-18.bz2 php脚本切割 [root@localhost ~]# cat /etc/logrotate.d/php /Data/logs/php/*log { daily rotate 365 missingok notifempty compress dateext sharedscripts postrotate if [ -f /Data/app/php5.6.26/var/run/php-fpm.pid ]; then kill -USR1 `cat /Data/app/php5.6.26/var/run/php-fpm.pid` fi endscript postrotate /bin/chmod 644 /Data/logs/php/*gz endscript } 结果 [root@localhost ~]# ll /Data/app/php5.6.26/var/run/php-fpm.pid -rw-r--r-- 1 root root 4 Dec 28 17:03 /Data/app/php5.6.26/var/run/php-fpm.pid [root@localhost ~]# cd /Data/logs/php [root@localhost php]# ll total 25676 -rw-r--r-- 1 root root 0 Jun 1 2016 error.log -rw-r--r-- 1 nobody nobody 182 Aug 30 2015 error.log-20150830.gz -rw-r--r-- 1 nobody nobody 371 Sep 1 2015 error.log-20150901.gz -rw-r--r-- 1 nobody nobody 315 Sep 7 2015 error.log-20150907.gz nginx日志切割一例 [root@localhost ~]# cat /etc/logrotate.d/nginx /Data/logs/nginx/*/*log { daily rotate 365 missingok notifempty compress dateext sharedscripts postrotate /etc/init.d/nginx reload endscript } 结果 [root@localhost ~]# ll /Data/logs/nginx/www.huanqiu.com/ .......... -rw-r--r-- 1 root root 1652 Jan 1 00:00 error.log-20170101.gz -rw-r--r-- 1 root root 1289 Jan 2 00:00 error.log-20170102.gz -rw-r--r-- 1 root root 1633 Jan 3 00:00 error.log-20170103.gz -rw-r--r-- 1 root root 3239 Jan 4 00:00 error.log-20170104.gz 系统日志切割一例 [root@localhost ~]# cat /etc/logrotate.d/syslog /var/log/cron /var/log/maillog /var/log/messages /var/log/secure /var/log/spooler { sharedscripts postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2\u003e /dev/null` 2\u003e /dev/null || true endscript } 结果 [root@localhost ~]# ll /var/log/messages* -rw------- 1 root root 34248975 Jan 19 18:42 /var/log/messages -rw------- 1 root root 51772994 Dec 25 03:11 /var/log/messages-20161225 -rw------- 1 root root 51800210 Jan 1 03:05 /var/log/messages-20170101 -rw------- 1 root root 51981366 Jan 8 03:36 /var/log/messages-20170108 -rw------- 1 root root 51843025 Jan 15 03:40 /var/log/messages-20170115 [root@localhost ~]# ll /var/log/cron* -rw------- 1 root root 2155681 Jan 19 18:43 /var/log/cron -rw------- 1 root root 2932618 Dec 25 03:11 /var/log/cron-20161225 -rw------- 1 root root 2939305 Jan 1 03:06 /var/log/cron-20170101 -rw------- 1 root root 2951820 Jan 8 03:37 /var/log/cron-20170108 -rw------- 1 root root 3203992 Jan 15 03:41 /var/log/cron-20170115 [root@localhost ~]# ll /var/log/secure* -rw------- 1 root root 275343 Jan 19 18:36 /var/log/secure -rw------- 1 root root 2111936 Dec 25 03:06 /var/log/secure-20161225 -rw------- 1 root root 2772744 Jan 1 02:57 /var/log/secure-20170101 -rw------- 1 root root 1115543 Jan 8 03:26 /var/log/secure-20170108 -rw------- 1 root root 731599 Jan 15 03:40 /var/log/secure-20170115 [root@localhost ~]# ll /var/log/spooler* -rw------- 1 root root 0 Jan 15 03:41 /var/log/spooler -rw-------","date":"2022-02-12","objectID":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/:2:1","tags":["logrotate"],"title":"使用logrotate进行日志切割","uri":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/"},{"categories":["工具"],"content":"尝试解决logrotate无法自动轮询日志的办法 现象说明： 使用logrotate轮询nginx日志，配置好之后，发现nginx日志连续两天没被切割，这是为什么呢？？ 然后开始检查日志切割的配置文件是否有问题，检查后确定配置文件一切正常。 于是怀疑是logrotate预定的cron没执行，查看了cron的日志，发现有一条Dec 7 04:02:01 www crond[18959]: (root) CMD (run-parts /etc/cron.daily)这样的日志，证明cron在04:02分时已经执行/etc/cron.daily目录下的程序。 接着查看/etc /cron.daily/logrotate（这是logrotate自动轮转的脚本）的内容： [root@localhost~]# cat /etc/cron.daily/logrotate #!/bin/sh /usr/sbin/logrotate /etc/logrotate.conf \u003e/dev/null 2\u003e\u00261 EXITVALUE=$? if [ $EXITVALUE != 0 ]; then /usr/bin/logger -t logrotate \"ALERT exited abnormally with [$EXITVALUE]\" fi exit 0 没有发现异常，配置好的日志轮转操作都是由这个脚本完成的，一切运行正常，脚本应该就没问题。 直接执行命令： [root@localhost ~]# /usr/sbin/logrotate /etc/logrotate.conf 这些系统日志是正常轮询了，但nginx日志却还是没轮询。接着强行启动记录文件维护操作，纵使logrotate指令认为没有需要，应该有可能是logroate认为nginx日志太小，不进行轮询。 故需要强制轮询，即在/etc/cron.daily/logrotate脚本中将 -t 参数替换成 -f 参数 [root@localhost ~]# cat /etc/cron.daily/logrotate #!/bin/sh /usr/sbin/logrotate /etc/logrotate.conf \u003e/dev/null 2\u003e\u00261 EXITVALUE=$? if [ $EXITVALUE != 0 ]; then /usr/bin/logger -f logrotate \"ALERT exited abnormally with [$EXITVALUE]\" fi exit 最后重启下cron服务： [root@localhost ~]# /etc/init.d/crond restart Stopping crond: [ OK ] Starting crond: [ OK ] logrotate默认自动切割生效时间 Logrotate是基于CRON来运行的，其脚本是/etc/cron.daily/logrotate，实际运行时，Logrotate会调用配置文件/etc/logrotate.conf。 [root@test ~]# cat /etc/cron.daily/logrotate #!/bin/sh /usr/sbin/logrotate /etc/logrotate.conf EXITVALUE=$? if [ $EXITVALUE != 0 ]; then /usr/bin/logger -t logrotate \"ALERT exited abnormally with [$EXITVALUE]\" fi exit 0 时间是由CRON控制的，具体可以查询CRON的配置文件/etc/anacrontab（老版本的文件是/etc/crontab） [root@test ~]# cat /etc/anacrontab # /etc/anacrontab: configuration file for anacron # See anacron(8) and anacrontab(5) for details. SHELL=/bin/sh PATH=/sbin:/bin:/usr/sbin:/usr/bin MAILTO=root # the maximal random delay added to the base delay of the jobs RANDOM_DELAY=45 //这个是随机的延迟时间，表示最大45分钟 # the jobs will be started during the following hours only START_HOURS_RANGE=3-22 //这个是开始时间 #period in days delay in minutes job-identifier command 1 5 cron.daily nice run-parts /etc/cron.daily 7 25 cron.weekly nice run-parts /etc/cron.weekly @monthly 45 cron.monthly nice run-parts /etc/cron.monthly 第一个是Recurrence period 第二个是延迟时间 所以cron.daily会在3:22+(5,45)这个时间段执行，/etc/cron.daily是个文件夹. 通过默认/etc/anacrontab文件配置，会发现logrotate自动切割日志文件的默认时间是凌晨3点多。 ================================================================================================== 现在需要将切割时间调整到每天的晚上12点，即每天切割的日志是前一天的0-24点之间的内容。 操作如下： [root@localhost ~]# mv /etc/anacrontab /etc/anacrontab.bak //取消日志自动轮转的设置 [root@localhost logrotate.d]# cat nstc_nohup.out /data/nstc/nohup.out { rotate 30 dateext daily copytruncate compress notifempty missingok } [root@localhost logrotate.d]# cat syslog /var/log/cron /var/log/maillog /var/log/messages /var/log/secure /var/log/history { sharedscripts compress rotate 30 daily dateext postrotate /bin/kill -HUP `cat /var/run/syslogd.pid 2\u003e /dev/null` 2\u003e /dev/null || true endscript } 结合crontab进行自定义的定时轮转操作 [root@localhost ~]# crontab -l #log logrotate 59 23 * * * /usr/sbin/logrotate -f /etc/logrotate.d/syslog \u003e/dev/null 2\u003e\u00261 59 23 * * * /usr/sbin/logrotate -f /etc/logrotate.d/nstc_nohup.out \u003e/dev/null 2\u003e\u00261 结果 [root@localhost ~]# ll /data/nstc/nohup.out* -rw------- 1 app app 33218 1月 25 09:43 /data/nstc/nohup.out -rw------- 1 app app 67678 1月 25 23:59 /data/nstc/nohup.out-20180125.gz 除了利用自带的Logrotate工具实现日志切割之外，还可以编写python脚本或shell脚本以实现日志切割。下面就简单列出几个实例说明下： ","date":"2022-02-12","objectID":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/:2:2","tags":["logrotate"],"title":"使用logrotate进行日志切割","uri":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/"},{"categories":["工具"],"content":"其他工具实现日志切割 Python脚本实现日志切割 实例1：对jumpserver日志进行切割 [root@localhost mnt]# cat log_rotate.py #!/usr/bin/env python import datetime,os,sys,shutil log_path = '/opt/jumpserver/logs/' log_file = 'jumpserver.log' yesterday = (datetime.datetime.now() - datetime.timedelta(days = 1)) try: os.makedirs(log_path + yesterday.strftime('%Y') + os.sep + \\ yesterday.strftime('%m')) except OSError,e: print print e sys.exit() shutil.move(log_path + log_file,log_path \\ + yesterday.strftime('%Y') + os.sep \\ + yesterday.strftime('%m') + os.sep \\ + log_file + '_' + yesterday.strftime('%Y%m%d') + '.log') os.popen(\"sudo /opt/jumpserver/service.sh restart\") 手动执行这个脚本： [root@localhost mnt]# chmod 755 log_rotate.py [root@localhost mnt]# python log_rotate.py 查看日志切割后的效果： [root@localhost mnt]# ls /opt/jumpserver/logs/ 2017 jumpserver.log [root@localhost mnt]# ls /opt/jumpserver/logs/2017/ 09 [root@localhost mnt]# ls /opt/jumpserver/logs/2017/09/ jumpserver.log_20170916.log 然后做每日的定时切割任务： [root@localhost mnt]# crontab -e 30 1 * * * /usr/bin/python /mnt/log_rotate.py \u003e /dev/null 2\u003e\u00261 实例2:对nginx日志进行切割 [root@localhost mnt]# vim log_rotate.py #!/usr/bin/env python import datetime,os,sys,shutil log_path = '/app/nginx/logs/' log_file = 'www_access.log' yesterday = (datetime.datetime.now() - datetime.timedelta(days = 1)) try: os.makedirs(log_path + yesterday.strftime('%Y') + os.sep + \\ yesterday.strftime('%m')) except OSError,e: print print e sys.exit() shutil.move(log_path + log_file,log_path \\ + yesterday.strftime('%Y') + os.sep \\ + yesterday.strftime('%m') + os.sep \\ + log_file + '_' + yesterday.strftime('%Y%m%d') + '.log') os.popen(\"sudo kill -USR1 `cat /app/nginx/logs/nginx.pid`\") shell脚本实现日志切割 [root@localhost ~]# cat /app/script/log_rotate.sh #!/bin/sh function rotate() { logs_path=$1 echo Rotating Log: $1 cp ${logs_path} ${logs_path}.$(date -d \"yesterday\" +\"%Y%m%d\") \u003e ${logs_path} rm -f ${logs_path}.$(date -d \"7 days ago\" +\"%Y%m%d\") } for i in $* do rotate $i done 每天定时切割日志的任务制定（比如对python的一个业务/data/log/xcspam/下的日志进行切割，0K的日志不进行切割）： [root@localhost ~]# crontab -e #xcspam 日志切割 30 0 * * * find /data/log/xcspam/ -size +0 -name '*.log' | xargs /app/script/log_rotate.sh 手动执行切割： [root@localhost ~]# find /data/log/xcspam/ -size +0 -name ‘*.log’ | xargs /app/script/log_rotate.sh 切割后的日志效果： [root@qd-vpc-op-consumer01 ~]# ls /data/log/xcspam/ xcspam_error.log xcspam_error.log-20170926 比如对maridb日志进行切割 [root@localhost ~]# crontab -e #xcspam 日志切割 30 0 * * * find /var/log/mariadb/ -size +0 -name '*.log' | xargs /app/script/log_rotate.sh [root@localhost ~]# find /var/log/mariadb/ -size +0 -name '*.log' | xargs /app/script/log_rotate.sh [root@localhost ~]# ll /var/log/mariadb/ 总用量 8 -rw-r-----. 1 mysql mysql 0 9月 17 20:31 mariadb.log -rw-r-----. 1 root root 4532 9月 17 20:31 mariadb.log.20170916 日志压缩脚本： [root@localhost ~]# ls /var/log/fss/nginx/ nginx.20190506.log nginx.20190507.log nginx.20190508.log [root@localhost ~]# cat /root/log_clean.sh #!/usr/bin/sh #根据系统/服务/日志保留天数三个参数压缩日志 #usage: sh clearlog.sh sysname appname keepdays sysName=$1 appName=$2 keepDay=$3 logDir=/var/log/${sysName}/${appName} logFile=${appName}.*[0-9][0-9].log cd ${logDir} find ./ -name \"${logFile}\" -mtime -${keepDay} -exec gzip {} \\; [root@localhost ~]# sh /root/log_clean.sh fss nginx 3 [root@localhost ~]# ls /var/log/fss/nginx/ nginx.20190506.log.gz nginx.20190507.log.gz nginx.20190508.log.gz 还可以针对日志保留策略，调整成日志清理脚本。 推荐用的Nginx日志轮转方法 [部署在nginx的日志目录下] #!/bin/bash yesterday=`date -d \"-1 days\" +'%Y%m%d'` cd `dirname $0` basedir=`pwd` logdir=\"${basedir}/bak\" bindir=\"${basedir%/*}/sbin\" mkdir -p ${logdir} for log in `ls *.log 2\u003e/dev/null` do mv ${log} ${logdir}/${log}.${yesterday}.bak # gzip ${logdir}/${log}.${yesterday} done ${bindir}/nginx -s reload cd ${logdir} find . -type f -name \"*.bak\" -mtime +7 | xargs rm -f ","date":"2022-02-12","objectID":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/:2:3","tags":["logrotate"],"title":"使用logrotate进行日志切割","uri":"/%E4%BD%BF%E7%94%A8logrotate%E8%BF%9B%E8%A1%8C%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/"},{"categories":["问题"],"content":"所有的端口使用情况 netstat -ano ","date":"2022-02-06","objectID":"/windows%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B/:1:0","tags":["win进程"],"title":"windows结束进程","uri":"/windows%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B/"},{"categories":["问题"],"content":"查看占用端口应用 netstat -ano | findstr \"端口号\" ","date":"2022-02-06","objectID":"/windows%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B/:2:0","tags":["win进程"],"title":"windows结束进程","uri":"/windows%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B/"},{"categories":["问题"],"content":"通过id查找对应的进程名称 tasklist | findstr \"进程id号\" #列出进程名称 taskkill /f /t /im \"进程id或者进程名称\" #结束进程 ","date":"2022-02-06","objectID":"/windows%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B/:3:0","tags":["win进程"],"title":"windows结束进程","uri":"/windows%E7%BB%93%E6%9D%9F%E8%BF%9B%E7%A8%8B/"},{"categories":["网站"],"content":"创建文章 进入博客目录，在 /source/_posts 文件夹下直接建立一个.md文件 hexo new “这里填入文章的标题” .md文件注意使用带有makedown语法的编辑器打开，对文章进行编辑，你可以在Hexo-\u003eSource-\u003e_post目录下看到你新创建的那个文章，还有一个配套的文件夹，里面放这边博文的图片资源 文章标题，日期，标签，分类 layout: title title: hexo文章发布和删除 date: 2022-02-06 17:42:04 tags: 标签 categories: 分类 文章插入图片使用jsdelivr进行cdn加速使图片访问更快。 图片格式： \u003cimg src=\"https://cdn.jsdelivr.net/gh/Smithkenny/Myimage/img/zsh插件.png\" /\u003e ","date":"2022-02-06","objectID":"/hexo%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%92%8C%E5%88%A0%E9%99%A4/:0:1","tags":["hexo"],"title":"hexo文章发布和删除","uri":"/hexo%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%92%8C%E5%88%A0%E9%99%A4/"},{"categories":["网站"],"content":"发布新建文章 文章写好后，直接在git bash中执行以下命令即可直接发布文章 hexo d -g 如果发布的时候出现错误 ERROR Deployer not found: git 执行 npm install hexo-deployer-git –save 或者直接使用git推送到远程仓库中,等待github action 自动部署网站。 git add . git commit -m \"说明\" git push origin master ","date":"2022-02-06","objectID":"/hexo%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%92%8C%E5%88%A0%E9%99%A4/:0:2","tags":["hexo"],"title":"hexo文章发布和删除","uri":"/hexo%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%92%8C%E5%88%A0%E9%99%A4/"},{"categories":["网站"],"content":"删除文章 删除文章的过程一样也很简单，先删除本地文件，然后通过生成和部署命令进而将远程仓库中的文件也一并删除。具体来说，以最开始默认形成的helloworld.md这篇文章为例。 首先进入到source / _post 文件夹中，找到helloworld.md文件，在本地直接执行删除。然后依次执行 hexo d -g 再去主页查看你就会发现你的博客上面已经空空如也了，这就是如何删除文章的方法。 ","date":"2022-02-06","objectID":"/hexo%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%92%8C%E5%88%A0%E9%99%A4/:0:3","tags":["hexo"],"title":"hexo文章发布和删除","uri":"/hexo%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E5%92%8C%E5%88%A0%E9%99%A4/"},{"categories":["工具"],"content":"什么是 WSL WSL 的全称叫做：Windows Subsystem for Linux，即「适用于 Linux 的 Windows 子系统」。WSL 的诞生让 Windows 用户（开发人员）按原样运行 GNU/Linux 环境 —— 包括大多数命令行工具、实用工具和应用程序 —— 且不会产生虚拟机开销。 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:1:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"用 WSL 可以做什么？ 好的，在 Windows 上用 WSL 我们到底能干什么呢？ 你可以在 Windows 上「安装」你喜欢的 GNU/Linux 发行版 你可以直接在 Windows 上运行 grep、awk、sed 等 Linux 原生可执行文件 你可以在 Windows 上直接使用 Vim、Emacs 等工具，直接使用 Linux 版本的 Javascript/Node.js、Ruby、Python、C/C++、Rust、Go 等语言进行开发，直接运行 MySQL、Apache 等 Linux 原生应用和服务等 最为重要的是，利用 WSL 我们可以直接在 不抛弃 Windows 全部优秀工具的前提下，在没有因为虚拟机开销而牺牲太多性能的情况下，直接运行使用完整的 Linux 系统。 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:2:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"WSL 2 中采用的新措施 在 Windows 上实现完整的 Linux 原生系统调用（Full System Call Compatibility） 用 WSL 执行曾经 1.0 版本无法运行的 Linux 原生程序，比如依赖虚拟化技术的 Docker 容器。 极大的突破了 WSL 1.0 中出现的 I/O 性能瓶颈：WSL 2 中，git clone、npm install、apt update、apt upgrade 等依赖文件系统性能的操作和命令的速度都有显著提高。 如果你在 WSL 2 中运行 Web 服务器，你会发现映射到 Windows 中的端口并不一样。不过这一不同并无大碍。 你会发现 WSL 2 中在 Windows 侧和 Linux 侧之间相互移动文件的速度会比 WSL 的 1.0 版本慢。因此，为了尽可能保证我们 WSL 文件系统的存储速度，我们应该将在 Linux 中使用的文件全部放在 Linux 文件系统下。 WSL 2 目前对硬件的支持有限，因此你可能无法直接通过 WSL 2 访问外设。不过，WSL 2 目前已经支持了 GPU 的连接,同时，我们也可以通过一些 hacky 的手段让 WSL 2 能够访问 USB 接口. WSL 2 对 VMware 等虚拟机软件也有一些要求，也就是：你无法在运行 WSL 2 的情况下直接运行 VMware 或旧版本的 Virtual Box。这是因为 WSL 2 中的虚拟化技术依赖于 Hyper-V，而 VMware 和 6.0 版本之前的 Virtual Box 都和 Hyper-V 不兼容. ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:3:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"安装 只有 Windows 10 才能安装使用 WSL。Windows 7、8 或之前的任何版本都无法使用，请及时将系统版本更新至最新。 只有 Windows 10 版本 16215 或以后的版本才能够正常运行 WSL。你可以在「Windows 设置 \u003e 系统 \u003e 关于」处找到你的 Windows 10 操作系统版本。 只有 Windows 10 版本 18362 或 18363 以及以后的版本，或小版本号为 1049 的版本，才能够正常运行 WSL 2。需要明确，WSL 2 目前只能在 Windows 10 版本 1903、1909 和 2004 中使用（其中 1903 和 1909 仅支持 x64 系统），因此你需要将自己的 Windows 系统进行升级至合适的版本，才能使用正确的 Windows 10 版本安装 WSL 2。 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:4:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"开启「适用于 Linux 的 Windows 子系统」的附加功能 无论使用 WSL 1 还是 WSL 2，我们都需要开启「适用于 Linux 的 Windows 子系统」的附加功能： 以管理员身份打开 PowerShell 终端 运行下面的命令： Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux 按照提示重启电脑 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:4:1","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"官方版本 WSL 微软官方支持的 WSL Linux 发行版可以直接从微软商店下载。 官方支持的 Linux 发行版有： Ubuntu: 最新版 ，16.04 LTS ，18.04 LTS ，和 20.04 LTS OpenSUSE Leap: 42 , 15.0 SUSE Linux Enterprise Server: 12 , 15 Debian GNU/Linux Kali Linux Pengwin - GitHub | WhitewaterFoundry/Pengwin 付费 Alpine WSL - GitHub | agowa338/WSL-DistroLauncher-Alpine Fedora Remix for WSL - GitHub | WhitewaterFoundry/Fedora-Remix-for-WSL 付费 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:4:2","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"社区支持的 WSL 另外也有社区支持的 WSL Linux 发行版，社区支持的第三方 WSL 发行版： Arch Linux Alpine Linux 第三方支持的发行版需要按照其官方使用说明进行安装。 下载成功后，我们需要对刚刚这一发行版进行初始化。在开始菜单中，没有意外的话，你应该看到刚刚下载完成的 Ubuntu 快捷方式，我们点击打开 Ubuntu，等待初始化完成即可。（初始化过程会将下载好的 Linux 发行版的文件解压缩，并存储在电脑上供你使用，往往会需要 1 分钟甚至更多。） 初始化完成之后，Linux 会提示你输入一个 UNIX 用户名并为之设置一个 UNIX 密码。这一用户名和密码与你的 Windows 登录账号密码完全无关，你可以任意设置。完成之后，你的 Ubuntu 发行版就安装成功了。 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:4:3","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"WSL 2 的安装 WSL 2 需要在 WSL 已经安装完毕的基础之上才能进行安装。 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:5:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"开启支持 WSL 2 的可选组件 如果你希望安装 WSL 2，你需要确保你已安装「适用于 Linux 的 Windows 子系统」和「虚拟机平台」这两个可选组件。[1] 同样： 以管理员身份打开 PowerShell 终端 运行下面的命令： dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 根据提示重启电脑 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:5:1","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"使用命令行设置需要由 WSL 2 支持的发行版 同样，用管理员身份打开 PowerShell 终端： 执行下面命令找到你当前安装的 Linux 发行版及其名字： wsl --list 之后，执行下面的命令将你需要的发行版设置为由 WSL 2 支持，将其中的 \u003cDistro\u003e 修改为 Linux 发行版名称： wsl --set-version \u003cDistro\u003e 2 另外，你也可以通过下面的命令将之后新安装的发行版均设置为默认由 WSL 2 支持： wsl --set-default-version 2 执行下面的命令，如果发现最后一列的 VERSION 数为 2，说明你的配置是成功的： wsl --list --verbose 如果查询到的版本还是1，并且提示当前windows需要升级内核。则使用wsl_update_x64.rar工具升级并重启电脑。再次尝试，直到版本为2. ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:5:2","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"安装Fluent Terminal Fluent Terminal 是目前相对稳定的非 Electron 构建的终端。得益于 UWP 技术，Fluent Terminal 能够同样拥有美丽的亚克力半透明背景，同时也支持 iTerm2 色彩主题。 安装Fluent Terminal之前先安装Scoop. ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:6:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"自定义路径安装Scoop 用管理员运行powershell,创建scoop环境变量. env:SCOOP='D:\\Applications\\Scoop' [Environment]::SetEnvironmentVariable('SCOOP',$env:SCOOP,'User') env:SCOOP_GLOBAL='D:\\GlobalScoopApps' [Environment]::SetEnvironmentVariable('SCOOP_GLOBAL',$env:SCOOP_GLOBAL,'User') windows环境变量查看方式： 设置-系统设置-高级系统设置-环境变量 安装Scoop(包管理工具) Scoop官网 参考 需要设置代理才能安装： 暂时先用以下方法设置代理 使用下面的命令将当前 session（会话）的代理进行配置： export http_proxy=http://\u003cWindows 主机的 IP 地址\u003e:\u003c代理端口\u003e export https_proxy=http://\u003cWindows 主机的 IP 地址\u003e:\u003c代理端口\u003e 使用下面的命令取消代理： unset http_proxy https_proxy 我们可以使用下面的命令检测自己的对外端口： # 一个接口 curl ipinfo.io # 另一个接口 curl cip.cc 安装命令： iex (new-object net.webclient).downloadstring('https://get.scoop.sh') ## 或者 iwr-useb get.scoop.sh|iex 卸载命令： scoop uninstall scoop 这个卸载，会删除你配置的scoop下面的所有软件，非常危险。 安装 Scoop 之后，我们在 PowerShell 中执行下面的命令，即可安装 Fluent Terminal： scoop bucket add nonportable scoop install fluent-terminal-np ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:6:1","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"Shell 环境 为了加速 Ubuntu 软件包在中国大陆的下载速度，我们将包管理工具 apt 源更换至清华 TUNA 软件源镜像。Ubuntu 的软件源配置文件是 /etc/apt/sources.list。将系统自带的该文件做个备份，将该文件替换为下面内容，即可使用 TUNA 的软件源镜像。 备份原文件： sudo cp /etc/apt/sources.list /etc/apt/sources.list.bac 在配置文件 /etc/apt/sources.list 最前面添加下面的内容（下面内容为默认 Ubuntu 20.04 LTS 版本的内容）： # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse 更新缓存： sudo apt update \u0026\u0026 sudo apt upgrade 更多内容请参考：Ubuntu 镜像使用帮助 - 清华大学开源软件镜像站 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:7:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"zsh ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:7:1","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"安装、配置 安装 zsh 并将之设置为默认 Shell： 利用 apt 安装 zsh sudo apt install zsh 下载安装 oh-my-zsh ，可能是市面上最好的 zsh 配置管理工具： 运行命令下载安装 sh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\" 将 zsh 作为默认的 Shell 环境（如果刚刚安装脚本没有这样做的话）： chsh -s $(which zsh) 安装zsh时如果报以下错误： chsh always asking a password , and get `PAM: Authentication failure` 解决方法 将/etc/pam.d/chsh中 auth required pam_shells.so 改成 auth sufficient pam_shells.so 重新进入当前用户并重新安装zsh。 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:7:2","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"插件、主题模板推荐 zsh 拥有相当丰富的主题、插件等拓展内容，这里我仅列举一些我常用的配置插件和主题模板： 插件 在.zshrc中设置 zsh-autosuggestions ：为 zsh 提供基于输入历史的自动命令提示 autojump ：快速跳转不同的目录、路径、文件夹 zsh-syntax-highlighting ：为 zsh 命令提供色彩高亮 退出当前登录用户并重新进，如果发现提示插件需要重新安装。则用以下命令安装。 git clone https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/custom/plugins/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting git clone https://github.com/wting/autojump ~/.oh-my-zsh/custom/plugins/autojump autojump代码仓库克隆后需要进入到autojump 手动安装 安装 cd autojump ./install.py 卸载 ./uninstall.py ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:7:3","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"安装git进行版本控制 参考 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:8:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"使用脚本自动执行代理配置 WINDOWS_IP=$(ip route | grep default | awk '{print $3}') PROXY_HTTP=\"http://${WINDOWS_IP}:7890\" PROXY_SOCKS5=\"${WINDOWS_IP}:7890\" # Set proxy set_proxy () { export http_proxy=\"${PROXY_HTTP}\" export https_proxy=\"${PROXY_HTTP}\" proxy_git } # Unset proxy unset_proxy () { unset http_proxy unset https_proxy git config --global --unset http.https://github.com.proxy } # Set alias alias proxy=set_proxy alias deproxy=unset_proxy 实际上是先获取到网关IP，自动设置代理。 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:8:1","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"使用方式 开启代理：proxy 关闭代理：deproxy IP检测： 我们可以使用下面的命令检测自己的对外端口： # 一个接口 curl ipinfo.io # 另一个接口 curl cip.cc ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:8:2","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"安装 Python 在 WSL 环境中安装 Python： 使用 APT 安装最新版本的 Python 3： # 安装最新版本的 Python 3 sudo apt install python-is-python3 安装 Python 包管理 pip 工具： sudo apt install python3-pip 更新 pip 包管理源为清华大学 TUNA 镜像源：[1] # 使用 TUNA 镜像源更新 pip pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U # 将 pip 源设置为 TUNA pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:9:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"安装代码优化工具 在上面安装完成 VS Code 的 Python 插件之后，如果顺利，那么 VS Code 应该提示你缺少 Python 代码检查工具（Python linter），如果你尝试格式化文档，那么 VS Code 还会提示你缺少 Python 代码格式化工具（Python code formatter）。我们需要手动安装这些组件。 安装 Python 代码检查工具，VS Code 支持 Pylint（默认）、Flake8、mypy 等多个 Python linter，我更推荐大家使用 Flake8 ： pip install flake8 安装 Python 格式化代码工具，VS Code 支持 autopep8（默认）、yapf 和 black，我更推荐大家使用 black 来格式化代码： pip install black ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:10:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"用 Poetry 管理 Python 项目 Poetry – Python packaging and dependency management made easy.[2] 熟悉 Python 项目开发的同学可能知道，Python 需要利用虚拟环境工具 virtualenv 来创建虚拟环境运行 Python 项目，也需要 pip 包管理工具来安装 Python 依赖。使用两个单独的工具管理一个项目可能会出现诸多问题，同时 requirements.txt 的管理也相当不优雅。因此我们用 Poetry 作为统一管理 Python 环境和依赖的工具。Poetry 之于 Python 就如 yarn / npm 之于 Node.js、cargo 之于 Rust、composer 之于 PHP…… ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:11:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"安装 Poetry 在 WSL 中安装 Poetry： curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python 将 Tab 补全加入我们所使用的 Shell 环境，比如 zsh 中： poetry completions zsh \u003e ~/.zfunc/_poetry ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:11:1","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"基本使用 我们可以用 Poetry 直接新建一个模板 Python 项目，比如叫做 poetry-demo： poetry new poetry-demo 这一命令会在 poetry-demo 目录下生成如下的文件内容： poetry-demo ├── pyproject.toml ├── README.rst ├── poetry_demo │ └── __init__.py └── tests ├── __init__.py └── test_poetry_demo.py 其中的 pyproject.toml 文件就是定义我们当前 Python 项目所使用依赖库的文件。 我们可以用下面的命令安装一个新的 Python 依赖： # 安装一个依赖 poetry add requests # 安装一个仅在开发中使用的依赖（比如格式化工具 black） poetry add black --dev # 或 -D 对于一个已定义 pyproject.toml 的项目，我们可以用下面的命令安装所有依赖： # 安装所有依赖 poetry install # 安装除了仅限开发使用的依赖外的所有依赖库 poetry install --no-dev 使用 remove 关键词来移除某个依赖： poetry remove requests 更多 Poetry 命令行工具的使用，推荐大家参考 Poetry 官方文档：Poetry - Commands . ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:11:2","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"Node.js 版本更新 在开始之前，我先来介绍几个 Node.js 相关的概念： Node.js - A JavaScript runtime built on Chrome’s V8 JavaScript engine 是一个不依赖浏览器的 JavaScript 运行环境，大部分前端项目比如 Vue、React 和后端项目比如 Express、Koa 均依赖于 Node.js 生态系统； n - Interactively Manage Your Node.js Versions：是一个 Node.js 版本管理工具，我们可以使用 n 来安装不同版本的 Node.js 环境； npm 和 yarn，分别是 Node.js 的包管理工具，其中我更推荐大家使用后者（yarn）来管理安装 Node.js 依赖； 接下来，我们将在 WSL 中使用 n 来安装 Node.js 环境，并配置包管理工具 yarn 来管理 Node.js 环境中的依赖。 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:12:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"安装 Node.js 建议大家使用 n 来管理与安装 Node.js，便于切换版本和快捷安装。首先，我们使用 n-install 安装 n： curl -L https://git.io/n-install | bash n-install（也就是上面的命令）默认会自动帮我们将 n 的重要环境变量 PREFIX 和 N_PREFIX 设置到 $HOME/n，并将 n 安装到 $HOME/n/bin。同时，n-install 会帮助我们更新当前我们所使用的 Shell（比如 zsh），在相应的配置文件中将 $HOME/n/bin 添加到 PATH 中。最后，n-install 会帮我们安装最新的 LTS 版本的 Node.js 环境。 更多关于 n-install 的使用，请参考 n-install 的 README 文档 。 使用 n-install 安装好 n 以及 Node.js 之后，我们可以通过下面的命令进行验证： # 验证 n 的安装情况 n --version 6.7.0 # 验证 Node.js 的安装情况 node --version v12.18.3 # 验证 npm 的安装情况 npm --version 6.14.6 另外，我们也可以用 n 下载其他版本的 Node.js： # 下载最新的 LTS 版本 Node.js n lts # 下载特定版本的 Node.js n 10.16.0 直接运行命令 n 也可以进入 interactive 界面，让我们选择使用某个版本的 Node.js。 有关使用 n 下载安装与使用 Node.js 的命令和方法，请参考 n 的官方 README 文档 。 ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:13:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["工具"],"content":"配置 Node.js 包管理工具 接下来，我们安装 yarn ，推荐大家安装使用 yarn：这个更加现代、科学的 Node.js 包管理工具。刚刚下载的 Node.js 中包含有 npm，因此我们可以直接用 npm 来安装 yarn： npm install -g yarn 此时我们安装的 yarn 实际上是 1.22.0： yarn --version 1.22.4 此时我们安装的是 yarn 1.0 版本，也就是比较传统的管理安装 Node.js 依赖的工具，跟 npm 比较类似。yarn 在 2.0+ 版本中经历了重大的变化，因此如果我们需要对某个项目开启 yarn 的 2.0 版本，需要使用下面的命令手动开启： yarn set version berry 其中，yarn 2.0 所支持的 Plug and play - Plug’n’Play 功能是 yarn 2.0 的重磅功能，也是我们使用 yarn 2.0 的主要原因，Plug’n’Play 重点解决了 Node.js 的 node_modules 存在于每个项目中的问题，更多内容请见：yarn - Plug’n’Play 。需要注意的是，并非不是所有的 Node.js 库均支持 yarn 2.0，因此推荐预先查看你所使用的库是否支持 yarn 2.0：Compatibility Table 。 如果你之前使用 yarn 1.0 版本，推荐查看 yarn 官方的 1.0 至 2.0 版本迁移指南：Migrating from Yarn 1 。 有关在 VS Code 中开发 Node.js 项目的方法，更多请参考：Node.js tutorial in Visual Studio Code - Visual Studio Code Docs ","date":"2022-02-05","objectID":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/:14:0","tags":["wsl2"],"title":"wsl2搭建全过程","uri":"/wsl2%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"},{"categories":["新年"],"content":"2022 新年快乐！！！🎉🎉🎉✨ ","date":"2022-02-01","objectID":"/2022happynewyear/:0:1","tags":[2022],"title":"2022","uri":"/2022happynewyear/"},{"categories":["编程"],"content":"方法 方法的格式 object.method(arg1,arg2,etc...) 让我们快速看一下列表的各种方法的例子。 # Create a simple list lst = [1,2,3,4,5] 通过iPython和Jupyter笔记本，我们可以使用tab键快速查看所有可能的方法。列表中的方法有 append count extend insert pop remove reverse sort append() 允许我们将元素添加到列表的末尾： lst.append(6) lst 结果 [1, 2, 3, 4, 5, 6] count()方法将计算一个元素在列表中出现的次数。 # 查找2在列表中出现的次数 lst.count(2) 结果 1 你可以随时在Jupyter笔记本中使用Shift+Tab来获得更多关于该方法的帮助。在一般的Python中，你可以使用help()函数。 help(lst.count) Help on built-in function count: count(...) method of builtins.list instance L.count(value) -\u003e integer -- return number of occurrences of value ","date":"2022-01-15","objectID":"/python%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/:0:1","tags":["python"],"title":"python方法和函数","uri":"/python%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"函数 从形式上看，函数是一个有用的工具，它将一组语句组合在一起，以便它们可以被多次运行。它们还可以让我们指定参数，作为函数的输入。 在一个更基本的层面上，函数使我们不必一次又一次地重复编写相同的代码。如果你还记得关于字符串和列表的课程，记得我们用函数len()来获取一个字符串的长度。由于检查一个序列的长度是一项常见的任务，你会想写一个能在命令下反复进行的函数。 函数将是在 Python 中重复使用代码的最基本层次之一，它也将使我们开始思考程序设计（当我们学习面向对象编程时，我们将更深入地研究设计的想法）。 简单地说，当你打算多次使用一个代码块时，你应该使用函数。函数将允许你调用同一个代码块，而不需要多次编写它。这反过来又允许你创建更复杂的 Python 脚本。不过要真正理解这一点，我们应该实际写出我们自己的函数! 定义关键字 让我们看看如何在Python中构建出一个函数的语法。它有如下形式。 def name_of_function(arg1,arg2): ''' This is where the function's Document String (docstring) goes. When you call help() on your function it will be printed out. ''' # Do stuff here # Return desired result 解释 我们以def开头，然后是一个空格，接着是函数的名称。尽量保持名字的相关性，例如 用len()来表示 length() 函数。同样要注意名字的使用，不要和Python中内置函数（如len）同名。内置关键字 接下来是一对圆括号，里面有一些用逗号分隔的参数。这些参数是你的函数的输入。你将能够在你的函数中使用这些输入并引用它们。在这之后你要加一个冒号。 这是最重要的一步，您必须缩进才能正确开始函数内的代码。 Python 利用空格来组织代码。许多其他编程语言不这样做，所以请记住这一点。 接下来您将看到文档字符串，这是您编写函数基本描述的地方。使用 Jupyter 和 Jupyter Notebooks，您可以通过在函数名称后按 Shift+Tab 来阅读这些文档字符串。简单函数不需要文档字符串，但最好将它们放入其中，以便您或其他人可以轻松理解您编写的代码。 最后，你开始写你想执行的代码。 学习函数的最好方法是通过实例来学习。因此，让我们试着通过与我们之前学习的各种对象和数据结构相关的例子。 简单的函数 def say_hello(): print('hello') 用函数名和括号来调用函数 say_hello() 结果 hello 如果你忘记了小括号（），它将简单地显示 say_hello 是一个函数的事实。稍后我们将学习我们实际上可以将函数传入其他函数中！但现在，只需记住用（）调用函数就可以了。 say_hello 结果 \u003cfunction __main__.say_hello\u003e 接受参数 def greeting(name): print(f'Hello {name}') 传入参数 greeting('Jose') 结果 Hello Jose 注意这里如果不传入参数会报错。 greeting() 报错如下，提示name 需要一个参数 --------------------------------------------------------------------------- TypeError Traceback (most recent call last) \u003cipython-input-5-3ffcd7d44b66\u003e in \u003cmodule\u003e ----\u003e 1 greeting() TypeError: greeting() missing 1 required positional argument: 'name' 如果用如下写法，则可以不用传入参数。因为给name 指定了默认的参数。 def greeting(name=‘smith’): print(f'Hello {name}') 测试 greeting() 结果 Hello smith 使用return关键字 到目前为止，我们只看到了 print() 的使用，但如果我们真的想保存结果变量，我们需要使用 return 关键字。让我们看一些使用 return 语句的示例。 return 允许函数返回一个结果，然后可以将其存储为变量，或以用户想要的任何方式使用。 def add_num(num1,num2): return num1+num2 add_num(4,5) 结果 9 也可以把返回值作为变量存起来 result = add_num(4,5) print(result) 结果 9 如果输入两个字符串会发生什么？ add_num('one','two') 'onetwo' 常见问题：print和return 有什么区别？ return关键字允许你将一个函数的输出结果实际保存为一个变量。print()函数只是向你显示输出结果，但并不为将来的使用而保存它。让我们更详细地探讨一下这个问题。 def print_result(a,b): print(a+b) def return_result(a,b): return a+b print_result(10,5) 结果 15 如果您在 .py 脚本中运行它，您将看不到任何输出 return_result(10,5) 结果 15 将这个结果保存在变量中后 my_print = print_result(20,20) my_print 结果 40 查看变量类型 type(my_print) NoneType 请注意! 注意print_result()并没有让你把结果保存到一个变量中去！它只是把它打印出来，而print()在赋值时返回None! 它只是把它打印出来，print()对赋值返回无。 my_result = return_result(20,20) my_result 结果 40 查看变量类型 type(my_result) 结果是 int 变量可以重复使用 my_result1 + my_result1 结果 80 向内部函数中添加逻辑 验证数字是否是偶数 如果一个数字是偶数，那么 mod 2 (% 2) 应该为零。 2 % 2 0 21 % 2 1 20 % 2 == 0 True 21 % 2 == 0 False 让我们用它来构造一个函数。是偶数返回True,不是则返回False def even_check(number): return number % 2 == 0 even_check(20) 是偶数 True even_check(21) 不是偶数 False 验证列表中的数字是否是偶数 让我们返回一个布尔值，指示列表中的任何数字是否为偶数。注意这里 return 如何跳出循环并退出函数。 def check_even_list(num_list): # Go through each number for number in num_list: # Once we get a \"hit\" on an even number, we return True if number % 2 == 0: return True # Otherwise we don't do anything else: pass 如果都是奇数，那么没返回值了。 check_even_list([1,2,3]) True check_even_list([1,1,1]) 非常常见的错误，注意以下代码是错误的 def check_even_list(num_list): # Go through each number for number in num_list: # Once we get a \"hit\" on an even number, we return True if number % 2 == 0: return True # This is WRONG! This returns False at the very first odd number! # It doesn't end up checking the other numbers in the list! else: return False # 只会检查列表中第一个位置的数字，如果第一个数字是奇数，返回False然后直接跳出循环了，不会再验证后面的数字。 check_even_list([1,2,3]) False 正确的做法是我们需要在运行完整个循环之后发起一个返回 False。注意缩进。 def check_even_list(num_list): # Go through each number for number in num_list: # Once we get a \"hit\" on an even number, we return True if number % 2 == 0: return True # Don't do anything if its not even else: pass # Notice the indentation! This ensures we run through the entire for loop return False check_even_list([1,2,3]) 结果 True check_eve","date":"2022-01-15","objectID":"/python%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/:0:2","tags":["python"],"title":"python方法和函数","uri":"/python%E6%96%B9%E6%B3%95%E5%92%8C%E5%87%BD%E6%95%B0/"},{"categories":["编程"],"content":"python 语法 if、elif、else 语句 嘿，如果发生这种情况，请执行一些操作。否则，如果发生其他情况，请执行其他操作。否则，如果上述情况均未发生，请执行此操作。 if case1: perform action1 elif case2: perform action2 else: perform action3 例如 x = False if x: print('x was True!') else: print('I will be printed in any case where x is not true') #I will be printed in any case where x is not true 多分支结构 loc = 'Bank' if loc == 'Auto Shop': print('Welcome to the Auto Shop!') elif loc == 'Bank': print('Welcome to the bank!') else: print('Where are you?') #Welcome to the bank! for 循环 for 循环在 Python 中充当迭代器；它遍历序列中的项目或任何其他可迭代项目。我们了解的可以迭代的对象包括字符串、列表、元组，甚至是字典的内置可迭代对象，例如键或值。 这是 Python 中 for 循环的一般格式： for item in object: statements to do stuff 遍历列表 list1 = [1,2,3,4,5,6,7,8,9,10] for num in list1: print(num) 结果： 1 2 3 4 5 6 7 8 9 10 取余 用 % 来获取余数 # 3 Remainder 1 10 % 3 # 1 # 2 Remainder 4 18 % 7 #4 # 2 no remainder 4 % 2 #0 请注意，如果一个数可以完全整除且没有余数，则模调用的结果为 0。我们可以使用它来测试偶数，因为如果一个数模 2 等于 0，则意味着它是偶数！ 打印出list1中所有的偶数 for num in list1: if num % 2 == 0: print(num) 结果： 2 4 6 8 10 也可以加上else语句 for num in list1: if num % 2 == 0: print(num) else: print('Odd number') 结果： Odd number 2 Odd number 4 Odd number 6 Odd number 8 Odd number 10 例如 # Start sum at zero list_sum = 0 for num in list1: list_sum = list_sum + num print(list_sum) 结果： 55 另一种写法 # Start sum at zero list_sum = 0 for num in list1: list_sum += num print(list_sum) 结果： 55 我们已经在列表中使用了 for 循环，那么使用字符串呢？请记住字符串是一个序列，因此当我们遍历它们时，我们将访问该字符串中的每个项目。 for letter in 'This is a string.': print(letter) 结果： T h i s i s a s t r i n g . 现在让我们看看如何将 for 循环与元组一起使用. tup = (1,2,3,4,5) for t in tup: print(t) 结果： 1 2 3 4 5 当涉及到 for 循环时，元组具有特殊的品质。如果您正在遍历包含元组的序列，则该项目实际上可以是元组本身，这是元组解包的示例。在 for 循环中，我们将解压缩序列中的元组，我们可以访问该元组中的各个项目！ list2 = [(2,4),(6,8),(10,12)] for tup in list2: print(tup) 结果： (2, 4) (6, 8) (10, 12) 拆包 for (t1,t2) in list2: print(t1) 结果 2 6 10 使用序列中的元组，我们可以通过解包访问其中的项目！这是因为许多对象将通过元组传递它们的迭代。 在字典中使用for循环 d = {'k1':1,'k2':2,'k3':3} for item in d: print(item) 结果 k1 k2 k3 关于字典的新方法 .keys(), .values() and .items() 的使用 # Create a dictionary view object d.items() dict_items([('k1', 1), ('k2', 2), ('k3', 3)]) 由于 .items() 方法支持迭代，我们可以执行字典解包以分离键和值。 # 字典拆包 for k,v in d.items(): print(k) print(v) 结果： k1 1 k2 2 k3 3 如果你想获得一个真正的键、值或键/值元组的列表，你可以将视图转换为一个列表。 list(d.keys()) 结果 ['k1', 'k2', 'k3'] 请记住，字典是无序的，键和值以任意顺序返回。您可以使用 sorted() 获取排序列表。 sorted(d.values()) 结果 [1, 2, 3] 更多内容参考 while 循环 Python 中的 while 语句是执行迭代的最常用方法之一。只要条件为真，while 语句就会重复执行单个语句或一组语句。之所以称为“循环”，是因为代码语句一遍又一遍地循环，直到不再满足条件。 常用格式 while test: code statements else: final code statements 例如 x = 0 while x \u003c 10: print('x is currently: ',x) print(' x is still less than 10, adding 1 to x') x+=1 else: print('All Done!') 结果 x is currently: 0 x is still less than 10, adding 1 to x x is currently: 1 x is still less than 10, adding 1 to x x is currently: 2 x is still less than 10, adding 1 to x x is currently: 3 x is still less than 10, adding 1 to x x is currently: 4 x is still less than 10, adding 1 to x x is currently: 5 x is still less than 10, adding 1 to x x is currently: 6 x is still less than 10, adding 1 to x x is currently: 7 x is still less than 10, adding 1 to x x is currently: 8 x is still less than 10, adding 1 to x x is currently: 9 x is still less than 10, adding 1 to x All Done! 注意一共执行10次循环，当x=10时，while后条件为假，跳出循环，执行else语句。 关键字break, continue,pass 我们可以在循环中使用 break、continue 和 pass 语句来为各种情况添加额外的功能。这三个语句定义为 break：跳出当前最近的封闭循环。 continue：转到最近的封闭循环的顶部。 pass：什么都不做。 考虑 break 和 continue 语句，while 循环的一般格式如下所示 while test: code statement if test: break if test: continue else: break 和 continue 语句可以出现在循环体内的任何位置，但我们通常会将它们与 if 语句一起进一步嵌套，以根据某些条件执行操作。 x = 0 while x \u003c 10: print('x is currently: ',x) print(' x is still less than 10, adding 1 to x') x+=1 if x==3: print('x==3') else: print('continuing...') continue 结果 x is currently: 0 x is still less than 10, adding 1 to x continuing... x is currently: 1 x is still less than 10, adding 1 to x continuing... x is currently: 2 x is still less than 10, adding 1 to x x==3 x is currently: 3 x is still less than 10, adding 1 to x con","date":"2022-01-09","objectID":"/python%E8%AF%AD%E6%B3%95/:0:1","tags":["python"],"title":"python语法","uri":"/python%E8%AF%AD%E6%B3%95/"},{"categories":["编程"],"content":"运算 算数运算 运算符 描述 实例 + 加 - 两个对象相加 a + b 输出结果 30 - 减 - 得到负数或是一个数减去另一个数 a - b 输出结果 -10 * 乘 - 两个数相乘或是返回一个被重复若干次的字符串 a * b 输出结果 200 / 除 - x除以y b / a 输出结果 2 % 取模 - 返回除法的余数 b % a 输出结果 0 ** 幂 - 返回x的y次幂 a**b为10的20次方，输出结果100000000000000000000 // 取整除一返回商的整数部分 9//2 输出结果 4 , 9.0//2.0 输出结果 4.0 比较运算 运算符 描述 实例 == 等于 - 比较对象是否相等 (a == b)返回True。 != 不等于 - 比较两个对象是否不相等 (a != b) 返回 True. \u003c\u003e 不等于 - 比较两个对象是否不相等 (a \u003c\u003e b) 返回 True.这个运算符类似 != 。 \u003e 大于 - 返回a是否大于b (a \u003e b) 返回 True。 \u003c 小于 - 返回a是否小于b。所有比较运算符返回1表示真，返回0表示假。这分别与特殊的变量True和False等价。注意，这些变量名的大写。 (a \u003c b) 返回 True。 \u003e= 大于等于 - 返回a是否大于等于b。 (a \u003e= b) 返回 True。 \u003c= 小于等于 - 返回x是否小于等于y。 (a \u003c= b) 返回 True。 逻辑运算 运算符 描述 实例 and 布尔\"与\" - 如果a为False，a and b返回False，否则它返回b的计算值。 (a and b) 返回 False。 or 布尔\"或\" - 如果a是True，它返回True，否则它返回b的计算值。 (a or b) 返回True。 not 布尔\"非\" - 如果a为True，返回False。如果b为False，它返回True。 not(a and b) 返回 Ture。 成员计算 运算符 描述 实例 in 如果在指定的序列中找到值返回True，否则返回False. x 在 y 序列中，如果 x 在 y 序列中返回True not in 如果在指定的序列中没有找到值返回True，否则返回False. x 不在 y 序列中，如果 x 不在 y 序列中返回True。 Python运算符优先级，以下表格列出了从最高到最低优先级的所有运算符： 运算符 描述 ** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 \u003e\u003e « 右移，左移运算符 \u0026 位 ‘AND’ ^ | 位运算符 \u003c= \u003c \u003e \u003e= 比较运算符 \u003c\u003e == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not and or 逻辑运算符 变量名 变量名的命名规则 名称不能以数字开头。 名称中不能有空格，用_代替。 不能使用这些符号：'\",\u003c\u003e/?|\\()!@#$%^\u0026*~-+ 名称小写被认为是最佳实践 (PEP8)。 避免使用字符 'l'（小写字母 el）、'O'（大写字母 oh）或 'I'（大写字母眼睛）作为单字符变量名称。 避免使用在 Python 中具有特殊含义的词，如“list”和“str” 动态类型 例如1 my_dog = 2 print(my_dog) # 结果是 2 例如2 my_dogs = ['a','b'] print(my_dog) # 结果是['a','b'] 用name = object 来表示变量，一个等号代表赋值运算。 例如1 a = 1 print(a) # 结果是1 也可以重新赋值 a = a + a print(a) # 结果是2 捷径。+=，-=，*=，/= 例如 a += 10 相当于a = a + 10 用type()可以确定变量的类型。type()是内置函数。常见的类型有 int (for integer) #整型 float #浮点型（小数） str (for string) #字符串 list #列表 tuple #元组 dict (for dictionary) #字典 set #集合 bool (for Boolean True/False) #布尔型 例如 a = (1,2) type(a) #结果：tuple c = {1,2} type(c) #结果：set 字符串 在python中用字符串记录文本信息例如名称。 Python 中的字符串实际上是一个序列，这基本上意味着 Python 将字符串中的每个元素作为一个序列进行跟踪。例如，Python 将字符串“hello”理解为按特定顺序排列的字母序列。这意味着我们将能够使用索引来获取特定的字母（如第一个字母或最后一个字母）。 要在 Python 中创建字符串，您需要使用单引号或双引号。 'hello' \"hello\" #结果是相同的。hello 当内容需要输出单引号时，用双引号括起来 \"I'm ready to use the single quotes inside a string!\" 字符串长度检查len() len('Hello World') #结果 11，空格也算长度 字符串索引index 例如 s = 'Hello World' print(s) # 结果 Hello World print(s[0]) #结果H print(s[1]) #结果e print(s[2]) #结果l print(s[1:]) #结果ello World print(s[:3]) #结果Hel print(s[:]) #结果Hello World print(s[-1]) #结果d print(s[:-1]) #结果 Hello Worl print(s[::1]) #结果 Hello World print(s[::2]) #结果 HloWrd print(s[::-1]) #结果 dlroW olleH 解析 H e l l o W o r l d 0 1 2 3 4 5 6 7 8 9 10 #正序从0开始 -11 -10 -9 -8 -7 -6 -5 -4 -3 -2 -1 # 倒序 从-1开始 # 规则前包括，后不包括 # 例如 s = 'hello' print(s[1:3]) 包括位置1对应的内容，不包含位置3对应的内容。所以结果为el 倒序查找也是一样的。例如 print(s[-3:-1]) #结果为ll 两个冒号后面的数字是步长。 print(s[::2]) #结果为hlo 字符串一旦被创建，就不能更改或替换其中的元素了。更改会报错。 例如 s = 'hello world' s[0] = 'x' #报错内容TypeError: 'str' object does not support item assignment 虽然不能更改元素内容，但字符串可以做拼接。 例如 s = 'hello' s = s + 'world' print(s) #结果 helloworld 它也支持乘法 例如 letter = 'z' print(letter**10) #结果 zzzzzzzzzz 内置函数调用 格式： object.method(parameters) 对象.方法(参数) 例如 s = 'hello world' s.upper() #大写 # 结果 'HELLO WORLD' s.lower() #小写 #结果 'hello world' s.split('w') #分割，不包含被分割的元素 #结果 'hello ','orld' 打印格式化 我们可以使用 .format() 方法将格式化的对象添加到打印的字符串语句中。 例如： 'Insert another string with curly brackets: {}'.format('The inserted string') # 结果'Insert another string with curly brackets: The inserted string' 字符串格式化 字符串格式化的三种实现方式 旧的方式是使用 % 充当占位符 改进的方式是使用 .format()来实现 Python 3.6 引入的最新方法使用格式化的字符串文字，称为 f-strings。 举例1 print(\"I'm going to inject %s text here, and %s text here.\" %('some','more')) #结果：I'm going to inject some text here, and more text here x, y = 'some', 'more' print(\"I'm going to inject %s text here, and %s text here.\"%(x,y)) # 结果：I'm going to inject some text here, and more text here. 格式转换方法 比较%s 和%r使用时的不同，%s 使用的是str() 函数，%r 使用的是repr()函数。%r 能够重新创建它所代表的对象。 print('I have a %r.'%'pen') # 结果： I have a 'pen'. print('I have a %s.'%'pen') # 结果：I have a p","date":"2022-01-06","objectID":"/python%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/:0:1","tags":["python"],"title":"python对象和数据结构基础","uri":"/python%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/"},{"categories":["工具"],"content":"问题出现的原因 我的服务器的平台架构是IBM-Z无法拉取默认的x86平台的镜像，所以需要到docker-hub上找到IBM-Z对应的镜像才能使用。 首先进入Docker Hub 查找所需镜像 例如我需要下载mysql镜像的IBM-Z版本 搜索mysql ，左侧筛选IBM Z. 选择ibmcom/mysql-s390x 选择tags 复制5.7.34版本的下载路径，粘贴到服务器中即可下载。 ","date":"2022-01-04","objectID":"/%E4%B8%8D%E5%90%8C%E6%9E%B6%E6%9E%84%E5%B9%B3%E5%8F%B0%E4%B8%8Bdoker%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E5%8C%85%E6%9F%A5%E6%89%BE%E8%AF%B4%E6%98%8E/:0:1","tags":["docker"],"title":"不同架构平台下doker官方镜像包查找说明","uri":"/%E4%B8%8D%E5%90%8C%E6%9E%B6%E6%9E%84%E5%B9%B3%E5%8F%B0%E4%B8%8Bdoker%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E5%8C%85%E6%9F%A5%E6%89%BE%E8%AF%B4%E6%98%8E/"},{"categories":["数据库"],"content":"mysql中引用了一张表来存储mysql的用户信息 mysql.user ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:0","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"基础字段 Host： 访问数据库客户端机器的IP地址。’%’:通配符，匹配所有的ip地址 User： 用户名。超级管理员为root authentication_string： 密码的加密字符串 要注意的是，mysql是通过用户名（user）和客户端ip（host）来唯一确定一个用户。即，可以设置同一个用户名在不同的客户端登陆时的密码不同，登陆后的权限也不同。通过查看mysql.user的表结构也可以看出，host和user是作为联合主键存在的。 mysql\u003e desc mysql.user; +------------------------+-----------------------------------+------+-----+-----------------------+-------+ | Field | Type | Null | Key | Default | Extra | +------------------------+-----------------------------------+------+-----+-----------------------+-------+ | Host | char(60) | NO | PRI | | | | User | char(32) | NO | PRI | | | | Select_priv | enum('N','Y') | NO | | N | | | Insert_priv | enum('N','Y') | NO | | N | | | Update_priv | enum('N','Y') | NO | | N | | | Delete_priv | enum('N','Y') | NO | | N | | | Create_priv | enum('N','Y') | NO | | N | | | Drop_priv | enum('N','Y') | NO | | N | | | Reload_priv | enum('N','Y') | NO | | N | | | Shutdown_priv | enum('N','Y') | NO | | N | | | Process_priv | enum('N','Y') | NO | | N | | | File_priv | enum('N','Y') | NO | | N | | | Grant_priv | enum('N','Y') | NO | | N | | | References_priv | enum('N','Y') | NO | | N | | | Index_priv | enum('N','Y') | NO | | N | | | Alter_priv | enum('N','Y') | NO | | N | | | Show_db_priv | enum('N','Y') | NO | | N | | | Super_priv | enum('N','Y') | NO | | N | | | Create_tmp_table_priv | enum('N','Y') | NO | | N | | | Lock_tables_priv | enum('N','Y') | NO | | N | | | Execute_priv | enum('N','Y') | NO | | N | | | Repl_slave_priv | enum('N','Y') | NO | | N | | | Repl_client_priv | enum('N','Y') | NO | | N | | | Create_view_priv | enum('N','Y') | NO | | N | | | Show_view_priv | enum('N','Y') | NO | | N | | | Create_routine_priv | enum('N','Y') | NO | | N | | | Alter_routine_priv | enum('N','Y') | NO | | N | | | Create_user_priv | enum('N','Y') | NO | | N | | | Event_priv | enum('N','Y') | NO | | N | | | Trigger_priv | enum('N','Y') | NO | | N | | | Create_tablespace_priv | enum('N','Y') | NO | | N | | | ssl_type | enum('','ANY','X509','SPECIFIED') | NO | | | | | ssl_cipher | blob | NO | | NULL | | | x509_issuer | blob | NO | | NULL | | | x509_subject | blob | NO | | NULL | | | max_questions | int(11) unsigned | NO | | 0 | | | max_updates | int(11) unsigned | NO | | 0 | | | max_connections | int(11) unsigned | NO | | 0 | | | max_user_connections | int(11) unsigned | NO | | 0 | | | plugin | char(64) | NO | | mysql_native_password | | | authentication_string | text | YES | | NULL | | | password_expired | enum('N','Y') | NO | | N | | | password_last_changed | timestamp | YES | | NULL | | | password_lifetime | smallint(5) unsigned | YES | | NULL | | | account_locked | enum('N','Y') | NO | | N | | +------------------------+-----------------------------------+------+-----+-----------------------+-------+ ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:1","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"权限字段 Select_priv： 确定用户是否可以通过SELECT命令选择数据。 Insert_priv： 确定用户是否可以通过INSERT命令插入数据。 Update_priv： 确定用户是否可以通过UPDATE命令修改现有数据。 Delete_priv： 确定用户是否可以通过DELETE命令删除现有数据。 Create_priv： 确定用户是否可以创建新的数据库和表。 Drop_priv： 确定用户是否可以删除现有数据库和表。 Reload_priv： 确定用户是否可以执行刷新和重新加载MySQL所用各种内部缓存的特定命令，包括日志、权限、主机、查询和表。 Shutdown_priv： 确定用户是否可以关闭MySQL服务器。在将此权限提供给root账户之外的任何用户时，都应当非常谨慎。 Process_priv： 确定用户是否可以通过SHOW PROCESSLIST命令查看其他用户的进程。 File_priv： 确定用户是否可以执行SELECT INTO OUTFILE和LOAD DATA INFILE命令。 Grant_priv： 确定用户是否可以将已经授予给该用户自己的权限再授予其他用户。例如，如果用户可以插入、选择和删除foo数据库中的信息，并且授予了GRANT权限，则该用户就可以将其任何或全部权限授予系统中的任何其他用户。 References_priv： 目前只是某些未来功能的占位符；现在没有作用。 Index_priv： 确定用户是否可以创建和删除表索引。 Alter_priv： 确定用户是否可以重命名和修改表结构。 Show_db_priv： 确定用户是否可以查看服务器上所有数据库的名字，包括用户拥有足够访问权限的数据库。可以考虑对所有用户禁用这个权限，除非有特别不可抗拒的原因。 Super_priv： 确定用户是否可以执行某些强大的管理功能，例如通过KILL命令删除用户进程，使用SET GLOBAL修改全局MySQL变量，执行关于复制和日志的各种命令。 Create_tmp_table_priv： 确定用户是否可以创建临时表。 Lock_tables_priv： 确定用户是否可以使用LOCK TABLES命令阻止对表的访问/修改。 Execute_priv： 确定用户是否可以执行存储过程。此权限只在MySQL 5.0及更高版本中有意义。 Repl_slave_priv： 确定用户是否可以读取用于维护复制数据库环境的二进制日志文件。此用户位于主系统中，有利于主机和客户机之间的通信。 Repl_client_priv： 确定用户是否可以确定复制从服务器和主服务器的位置。 Create_view_priv： 确定用户是否可以创建视图。此权限只在MySQL 5.0及更高版本中有意义。关于视图的更多信息，参见第34章。 Show_view_priv： 确定用户是否可以查看视图或了解视图如何执行。此权限只在MySQL 5.0及更高版本中有意义。 Create_routine_priv： 确定用户是否可以更改或放弃存储过程和函数。此权限是在MySQL 5.0中引入的。 Alter_routine_priv： 确定用户是否可以修改或删除存储函数及函数。此权限是在MySQL 5.0中引入的。 Create_user_priv： 确定用户是否可以执行CREATE USER命令，这个命令用于创建新的MySQL账户。 Event_priv： 确定用户能否创建、修改和删除事件。这个权限是MySQL 5.1.6新增的。 Trigger_priv： 确定用户能否创建和删除触发器，这个权限是MySQL 5.1.6新增的。 ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:2","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"mysql.db表 user表中的每项权限为Y的时候，则代表该用户对所有数据库的所有表都拥有该权限。 而如果某个用户只对单独的某个数据库的某张表有该权限时，则user表中该权限对应的字段为N，并在db表中添加一条记录用来标识此项权限。 测试失败。给某个用户添加了一个权限，但是mysql.db中并没有增加记录。 ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:3","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"基础命令 ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:4","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"创建用户 create user 'username'@'host' identified by 'password'; (不建议用) 如果不填host（create user 'username' identified by 'password';），则默认为%:即所有ip的客户端均可访问。 ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:5","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"赋予权限 -- 赋予单个权限 grant all on database_name.table_name to 'username'@'host' [identified by 'password']; -- 赋予多个权限 grant insert, select on database_name.table_name to 'username'@'host' [identified by 'password']; 常见权限有：all, create, drop, insert, update, delete, select等。 如果带上[]里面的内则相当于修改此用户的密码。 这里发现一个问题，当修改密码或修改权限时，如果此用户已经登陆，则不会立刻受到权限修改的影响（过一段时间以后会不会影响暂没做测试。），还是可以正常的使用已经收回的权限。 ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:6","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"收回权限 -- 收回单个权限 revoke all on database_name.table_name from 'username'@'host'; -- 收回多个权限 revoke select, insert on database_name.table_name from 'username'@'host'; 与赋予权限不一样的是，收回权限时不允许同时修改密码，而且将to user 改为 from user。 ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:7","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"删除用户 drop user 'username'@'host'; ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:8","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"查看某个用户的权限 show grants for 'username'@'host'; +---------------------------------------------------------------------+ | Grants for root@localhost | +---------------------------------------------------------------------+ | GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT OPTION | | GRANT PROXY ON ''@'' TO 'root'@'localhost' WITH GRANT OPTION | +---------------------------------------------------------------------+ ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:9","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"查看MYSQL数据库中所有用户 mysql\u003e SELECT DISTINCT CONCAT('User: ''',user,'''@''',host,''';') AS query FROM mysql.user; +------------------------------------+ | query | +------------------------------------+ | User: 'root'@'%'; | | User: 'mysql.session'@'localhost'; | | User: 'mysql.sys'@'localhost'; | | User: 'root'@'localhost'; | +------------------------------------+ 4 rows in set (0.00 sec) ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:10","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"查看数据库中具体某个用户的权限 mysql\u003e show grants for 'root'@'%'; +-------------------------------------------------------------+ | Grants for root@% | +-------------------------------------------------------------+ | GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' WITH GRANT OPTION | +-------------------------------------------------------------+ 1 row in set (0.00 sec) ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:11","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"查看user表中某个用户的具体权限 mysql\u003e select * from mysql.user where user='root' \\G; *************************** 1. row *************************** Host: localhost User: root Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: Y Create_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y Create_tablespace_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0 plugin: mysql_native_password authentication_string: *064C811C8A9344D23DFC73BDBE590528C07A6FCC password_expired: N password_last_changed: 2022-07-26 13:03:51 password_lifetime: NULL account_locked: N ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:12","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"修改账号密码 -- 修改当前登录账号的密码 set password = password('pwd'); -- 修改别的账号密码 set password for 'username'@'host' = password('pwd'); -- 可以使用赋予权限的方式修改密码（上文提到过），用此种方式时最好赋予的是登陆权限，这样可以不影响账号当前的权限。 grant usage on *.* to 'username'@'host' identified by 'pwd'; ","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:13","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"mysql的各种权限（共27种） （以下操作都是以root身份登陆进行grant授权，以p1@localhost身份登陆执行各种命令。） usage 连接（登陆）权限，建立一个用户，就会自动授予其usage权限（默认授予）。 grant usage on *.* to 'p1'@'localhost' identified by '123'; 该权限只能用于数据库登陆，不能执行任何操作；且usage权限不能被回收，也即REVOKE用户并不能删除用户。 select 必须有select的权限，才可以使用select table grant select on pyt.* to ‘p1′@’localhost’; select * from shop; create 必须有create的权限，才可以使用create table grant create on pyt.* to ‘p1′@’localhost’; create routine 必须具有create routine的权限，才可以使用{create | alter | drop} {procedure | function} grant create routine on pyt.* to ‘p1′@’localhost’; -- 当授予create routine时，自动授予EXECUTE, ALTER ROUTINE权限给它的创建者： show grants for ‘p1′@’localhost’; +—————————————————————————+ Grants for p1@localhost +————————————————————————–+ | GRANT USAGE ON *.* TO ‘p1′@’localhost’ IDENTIFIED BY PASSWORD ‘*23AE809DDACAF96AF0FD78ED04B6A265E05AA257′ | | GRANT SELECT, CREATE, CREATE ROUTINE ON `pyt`.* TO ‘p1′@’localhost’| | GRANT EXECUTE, ALTER ROUTINE ON PROCEDURE `pyt`.`pro_shop1` TO ‘p1′@’localhost’ | +————————————————————————————-+ create temporary tables(注意这里是tables，不是table) 必须有create temporary tables的权限，才可以使用create temporary tables. grant create temporary tables on pyt.* to ‘p1′@’localhost’; [mysql@mydev ~]$ mysql -h localhost -u p1 -p pyt create temporary table tt1(id int); create view 必须有create view的权限，才可以使用create view grant create view on pyt.* to ‘p1′@’localhost’; create view v_shop as select price from shop; create user 要使用CREATE USER，必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 grant create user on *.* to ‘p1′@’localhost’; -- 也可以使用 grant insert on *.* to p1@localhost; insert 必须有insert的权限，才可以使用insert into …… values…. alter 必须有alter的权限，才可以使用alter table alter table shop modify dealer char(15); alter routine 必须具有alter routine的权限，才可以使用{alter |drop} {procedure|function} grant alter routine on pyt.* to ‘p1′@’ localhost ‘; drop procedure pro_shop; revoke alter routine on pyt.* from ‘p1′@’localhost’; [mysql@mydev ~]$ mysql -h localhost -u p1 -p pyt drop procedure pro_shop; ERROR 1370 (42000): alter routine command denied to user ‘p1′@’localhost’ for routine ‘pyt.pro_shop’ update 必须有update的权限，才可以使用update table update shop set price=3.5 where article=0001 and dealer=’A’; delete 必须有delete的权限，才可以使用delete from ….where….(删除表中的记录) drop 必须有drop的权限，才可以使用drop database db_name; drop table tab_name; drop view vi_name; drop index in_name; show database 通过show database只能看到你拥有的某些权限的数据库，除非你拥有全局SHOW DATABASES权限。 对于p1@localhost用户来说，没有对mysql数据库的权限，所以以此身份登陆查询时，无法看到mysql数据库： show databases; +——————–+ | Database | +——————–+ | information_schema| | pyt | | test | +——————–+ show view 必须拥有show view权限，才能执行show create view。 grant show view on pyt.* to p1@localho show create view v_shop; index 必须拥有index权限，才能执行[create |drop] index grant index on pyt.* to p1@localhost; create index ix_shop on shop(article); drop index ix_shop on shop; excute 执行存在的Functions,Procedures call pro_shop1(0001,@a)； +———+ | article | +———+ | 0001 | | 0001 | +———+ select @a; +——+ | @a | +——+ | 2 | +——+ lock tables 必须拥有lock tables权限，才可以使用lock tables grant lock tables on pyt.* to p1@localhost; lock tables a1 read; unlock tables; references 有了REFERENCES权限，用户就可以将其它表的一个字段作为某一个表的外键约束。 reload 必须拥有reload权限，才可以执行flush [tables | logs | privileges] grant reload on pyt.* to p1@localhost; ERROR 1221 (HY000): Incorrect usage of DB GRANT and GLOBAL PRIVILEGES grant reload on *.* to ‘p1′@’localhost’; flush tables; replication client 拥有此权限可以查询master server、slave server状态。 show master status; ERROR 1227 (42000): Access denied; you need the SUPER,REPLICATION CLIENT privilege for this operation grant Replication client on *.* to p1@localhost; -- 也可以使用下面的命令 grant super on *.* to p1@localhost; show master status; +——————+———-+————–+——————+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +——————+———-+————–+——————+ | mysql-bin.000006 | 2111 | | | +——————+———-+————–+——————+ show slave status; replication slave 拥有此权限可以查看从服务器，从主服务器读取二进制日志。 show slave hosts; ERROR 1227 (42000): Access denied; you need the REPLICATION SLAVE privilege fo","date":"2022-01-03","objectID":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/:0:14","tags":["mysql"],"title":"mysql的user表详解","uri":"/mysql%E7%9A%84user%E8%A1%A8%E8%AF%A6%E8%A7%A3/"},{"categories":["数据库"],"content":"常见命令 连接本地数据库与远程数据库(10.4.xx.xx:3306) mysql -h localhost -u root -p123 mysql -h 10.4.xx.xx -P 3306 -u root -p 显示数据库列表 show databases; 显示库中的数据表 show tables; 显示数据表的结构 describe 表名; 默认表结构类型为MYISAM,并在/var/lib/mysql/abc 目录下建立student.frm(表定义文件)，student.MDY(数据文件)，student.MYI(索引文件)。 建库 create database 库名; 建表 create table 表名 (字段设定列表); 例如： mysql\u003e create table test (id int(20)); 删库和删表 drop database 库名; drop table 表名; 将表中记录清空 delete from 表名; # 内容清空，自增id不会被清掉，自增id会保留 mysql\u003e truncate table users; # 数据库返回：“Query OK, 0 rows affected (0.04 sec)” #（成功返回0）（自增id也一同会被清掉) 显示表中的记录 select * from 表名; ","date":"2022-01-03","objectID":"/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:0:1","tags":["mysql"],"title":"mysql常用命令总结","uri":"/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["数据库"],"content":"库的基本操作 创建数据库 mysql\u003e create database ceshi; 连接数据库 mysql\u003e use ceshi; 查看当前使用的数据库 mysql\u003e select database(); 当前数据库包含的表信息 mysql\u003e show tables; 删除数据库 mysql\u003e drop database ceshi; ","date":"2022-01-03","objectID":"/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:0:2","tags":["mysql"],"title":"mysql常用命令总结","uri":"/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["数据库"],"content":"表的基本操作 命令 create table \u003c表名\u003e (\u003c字段名 1\u003e \u003c类型 1\u003e [,..\u003c字段名 n\u003e \u003c类型 n\u003e]); 例如 mysql\u003e create table Class( id int(4) not null primary key auto_increment, name varchar(25) not null, age int (4) not null default'0'); # default'0' 设置默认值为0 ,not null(不能为空) ,primary key（主键）,auto_increment（自增长） 获取表结构 命令 desc 表名，或者show columns from 表名 例如 mysql\u003e desc Class; mysql\u003e describe Class; mysql\u003e show columns from Class; 插入数据 命令 insert into \u003c表名\u003e [( \u003c字段名 1\u003e[,..\u003c字段名 n \u003e ])] values ( 值 1 )[, ( 值 n )] 例如 mysql\u003e insert into Class values(1,'Wrry',26),(2,'ZJW',28); 查询表中的数据 查询所有行 mysql\u003e select * from Class; 查询前几行数据 例如:查看表 Class 中前 3 行数据 mysql\u003e select * from Class limit 0,3; 或者 mysql\u003e select * from Class order by id limit 0,3; # order by id:以id排序 删除表中数据 命令 delete from 表名 where 表达式; 例如:删除表 Class 中编号为 6 的记录 mysql\u003e delete from MyClass where id=6; 修改表中数据 命令 update 表名 set 字段=新值,... where 条件; 例如 mysql\u003e update Class set name='AI' where id=1; 在表中增加字段 命令 alter table 表名 add 字段 类型 其他; 例如:在表 Class 中添加了一个字段 sex,类型为 varchar(25),默认值为 0 mysql\u003e alter table Class add sex varchar(25) default '0'; 更改表名 命令 rename table 原表名 to 新表名; 例如:在表 Class 名字更改为 MClass mysql\u003e rename table Class to MClass; 复制表 create table 新表名 like 原表名称; 例如 mysql\u003e create table Test like test; 删除表 命令:drop table \u003c表名\u003e 例如:删除表名为 MClass 的表 mysql\u003e drop table MClass; 更多操作参考 ","date":"2022-01-03","objectID":"/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:0:3","tags":["mysql"],"title":"mysql常用命令总结","uri":"/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["数据库"],"content":"Mysql查看触发器 连接数据库并进入库 use test; 查看当前库中所有表的触发器 mysql\u003e show triggers \\G; *************************** 1. row *************************** Trigger: trigupdate Event: UPDATE Table: account Statement: INSERT INTO myevent VALUES(1,'after update') Timing: AFTER Created: NULL sql_mode: Definer: root@localhost character_set_client: utf8 collation_connection: utf8_general_ci Database Collation: utf8_general_ci 1 row in set (0.00 sec) ERROR: No query specified 触发器的创建 新建表account，表中有两个字段，分别是 INT 类型的 accnum 和 DECIMAL 类型的 amount。SQL 语句和运行结果如下： mysql\u003e CREATE TABLE account( accnum INT(4), amount DECIMAL(10,2)); Query OK, 0 rows affected (0.49 sec) 创建一个名为 trigupdate 的触发器，每次 account 表更新数据之后都向 myevent 数据表中插入一条数据。创建数据表 myevent 的 SQL 语句和运行结果如下： mysql\u003e CREATE TABLE myevent( id INT(11) DEFAULT NULL, evtname CHAR(20) DEFAULT NULL); Query OK, 0 rows affected (0.26 sec) 创建 trigupdate 触发器的 SQL 代码如下： mysql\u003e CREATE TRIGGER trigupdate AFTER UPDATE ON account FOR EACH ROW INSERT INTO myevent VALUES(1,'after update'); Query OK, 0 rows affected (0.15 sec) 使用 SHOW TRIGGERS 语句查看触发器（在 SHOW TRIGGERS 命令后添加\\G，这样显示信息会比较有条理），SQL 语句和运行结果如下： mysql\u003e show triggers\\G; *************************** 1. row *************************** Trigger: trigupdate Event: INSERT Table: account Statement: INSERT INTO myevent VALUES(1,'after insert') Timing: AFTER Created: NULL sql_mode: Definer: root@localhost character_set_client: utf8 collation_connection: utf8_general_ci Database Collation: utf8_general_ci 1 row in set (0.00 sec) ERROR: No query specified 由运行结果可以看到触发器的基本信息。对以上显示信息的说明如下： Trigger 表示触发器的名称，在这里触发器的名称为 trigupdate； Event 表示激活触发器的事件，这里的触发事件为更新操作 UPDATE； Table 表示激活触发器的操作对象表，这里为 account 表； Statement 表示触发器执行的操作，这里是向 myevent 数据表中插入一条数据； Timing 表示触发器触发的时间，这里为更新操作之后（AFTER）； 还有一些其他信息，比如触发器的创建时间、SQL 的模式、触发器的定义账户和字符集等，这里不再一一介绍。 SHOW TRIGGERS 语句用来查看当前创建的所有触发器的信息。因为该语句无法查询指定的触发器，所以在触发器较少的情况下，使用该语句会很方便。如果要查看特定触发器的信息或者数据库中触发器较多时，可以直接从 information_schema 数据库中的 triggers 数据表中查找。 在triggers表中查看触发器信息 在 MySQL 中，所有触发器的信息都存在 information_schema 数据库的 triggers 表中，可以通过查询命令 SELECT 来查看，具体的语法如下： SELECT * FROM information_schema.triggers WHERE trigger_name= '触发器名'; 其中，'触发器名'用来指定要查看的触发器的名称，需要用单引号引起来。这种方式可以查询指定的触发器，使用起来更加方便、灵活。 下面使用 SELECT 命令查看 trigupdate 触发器，SQL 语句如下： SELECT * FROM information_schema.triggers WHERE TRIGGER_NAME= 'trigupdate'\\G; 上述命令通过 WHERE 来指定需要查看的触发器的名称，运行结果如下： mysql\u003e SELECT * FROM information_schema.triggers WHERE TRIGGER_NAME= 'trigupdate'\\G; *************************** 1. row *************************** TRIGGER_CATALOG: def TRIGGER_SCHEMA: test TRIGGER_NAME: trigupdate EVENT_MANIPULATION: INSERT EVENT_OBJECT_CATALOG: def EVENT_OBJECT_SCHEMA: test EVENT_OBJECT_TABLE: account ACTION_ORDER: 0 ACTION_CONDITION: NULL ACTION_STATEMENT: INSERT INTO myevent VALUES(1,'after insert') ACTION_ORIENTATION: ROW ACTION_TIMING: AFTER ACTION_REFERENCE_OLD_TABLE: NULL ACTION_REFERENCE_NEW_TABLE: NULL ACTION_REFERENCE_OLD_ROW: OLD ACTION_REFERENCE_NEW_ROW: NEW CREATED: NULL SQL_MODE: DEFINER: root@localhost CHARACTER_SET_CLIENT: utf8 COLLATION_CONNECTION: utf8_general_ci DATABASE_COLLATION: utf8_general_ci 1 row in set (0.01 sec) 由运行结果可以看到触发器的详细信息。对以上显示信息的说明如下： TRIGGER_SCHEMA 表示触发器所在的数据库； TRIGGER_NAME 表示触发器的名称； EVENT_OBJECT_TABLE 表示在哪个数据表上触发； ACTION_STATEMENT 表示触发器触发的时候执行的具体操作； ACTION_ORIENTATION 的值为 ROW，表示在每条记录上都触发； ACTION_TIMING 表示触发的时刻是 AFTER； 还有一些其他信息，比如触发器的创建时间、SQL 的模式、触发器的定义账户和字符集等，这里不再一一介绍。 上述 SQL 语句也可以不指定触发器名称，这样将查看所有的触发器，SQL 语句如下： SELECT * FROM information_schema.triggers \\G; 这个语句会显示 triggers 数据表中所有的触发器信息。 ","date":"2022-01-03","objectID":"/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/:0:4","tags":["mysql"],"title":"mysql常用命令总结","uri":"/mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"categories":["数据库"],"content":"实验环境 [root@hdss7-11 ~]# uname -r 3.10.0-1062.el7.x86_64 [root@hdss7-11 ~]# cat /etc/redhat-release CentOS Linux release 7.7.1908 (Core) [root@hdss7-11 ~]# master 10.4.7.11 slave1 10.4.7.12 slave2 10.4.7.21 ","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:0:1","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["数据库"],"content":"安装mysql5.7 查询并删除旧的MySQL(没有可以忽略) [root@hdss7-11 ~]# rpm -qa |grep mysql php-mysql-5.4.16-48.el7.x86_64 mysql57-community-release-el7-9.noarch [root@hdss7-11 ~]# rpm -e php-mysql-5.4.16-48.el7.x86_64 下载MySQL源 [root@hdss7-11 ~]# wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm repo的安装 [root@hdss7-11 ~]# rpm -ivh mysql57-community-release-el7-9.noarch.rpm warning: mysql57-community-release-el7-9.noarch.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY Preparing... ################################# [100%] Updating / installing... 1:mysql57-community-release-el7-9 ################################# [100%] 开始安装MySQL yum -y install mysql-community-server 启动mysql并查看状态 systemctl start mysqld.service systemctl status mysqld.service ● mysqld.service - MySQL Server Loaded: loaded (/usr/lib/systemd/system/mysqld.service; enabled; vendor preset: disabled) Active: active (running) since Mon 2022-01-03 18:12:46 CST; 15s ago Docs: man:mysqld(8) http://dev.mysql.com/doc/refman/en/using-systemd.html Process: 3241 ExecStart=/usr/sbin/mysqld –daemonize –pid-file=/var/run/mysqld/mysqld.pid $MYSQLD_OPTS (code=exited, status=0/SUCCESS) Process: 3187 ExecStartPre=/usr/bin/mysqld_pre_systemd (code=exited, status=0/SUCCESS) Main PID: 3244 (mysqld) CGroup: /system.slice/mysqld.service └─3244 /usr/sbin/mysqld –daemonize –pid-file=/var/run/m… Jan 03 18:12:41 hdss7-11.host.com systemd[1]: Starting MySQL Server… Jan 03 18:12:46 hdss7-11.host.com systemd[1]: Started MySQL Server. Hint: Some lines were ellipsized, use -l to show in full. 查看版本 mysql -V mysql Ver 14.14 Distrib 5.7.36, for Linux (x86_64) using EditLine wrapper 查找系统默认密码 cd /var/log grep -e \"password\" mysqld.log A temporary password is generated for root@localhost: kaNNUw-2y,Gc 设置新密码，密码修改为IThaipeng123. mysql -uroot -p 输入密码kaNNUw-2y,Gc mysql\u003e alter user 'root'@'localhost' identified by 'IThaipeng123.'; Query OK, 0 rows affected (0.01 sec) 如果有以下报错说明密码强度不够，需要加特殊字符。 mysql\u003e alter user ‘root’@’localhost’ identified by ‘IThaipeng123’; ERROR 1819 (HY000): Your password does not satisfy the current policy requirements 注意：三台服务器安装方法相同，这里只给出一台的说明。 三台MySQL搭建好之后，需要把时间同步开启，防火墙关闭 NTP配置 NTP服务端：10.4.7.11 NTP客户端：10.4.7.12 10.4.7.21 安装ntp服务（三台都需安装） yum install -y ntp 查看ntp安装包 [root@hdss7-11 ~]# rpm -qa |grep ntp ntp-4.2.6p5-29.el7.centos.2.x86_64 ntpdate-4.2.6p5-29.el7.centos.2.x86_64 7.11上修改NTP配置文件 vim /etc/ntp.conf 把配置文件下面四行注释掉： server 0.centos.pool.ntp.org iburst server 1.centos.pool.ntp.org iburst server 2.centos.pool.ntp.org iburst server 3.centos.pool.ntp.org iburst 然后在下面添加这几行： server 0.cn.pool.ntp.org iburst server 1.cn.pool.ntp.org iburst server 2.cn.pool.ntp.org iburst server 3.cn.pool.ntp.org iburst 启动ntp服务，并开机自启 systemctl start ntpd systemctl enable ntpd 查看ntp是否同步 [root@hdss7-11 ~]# ntpq -p remote refid st t when poll reach delay offset jitter ============================================================================== ntp5.flashdance 194.58.202.20 2 u 1 64 1 318.796 49.178 1.689 time.cloudflare 10.4.3.52 3 u 2 64 1 183.991 28.217 4.578 ntp6.flashdance 194.58.202.148 2 u 1 64 1 331.954 46.528 5.128 139.199.214.202 100.122.36.196 2 u 2 64 1 72.218 10.343 0.000 防火墙开启ntp默认端口udp123(可选，如果没开启防火墙则不用操作此步) [root@hdss7-11 ~]# firewall-cmd --permanent --zone=public --add-port=123/udp success [root@hdss7-11 ~]# firewall-cmd --reload success NTP 客户端配置 7.12 7.21 上修改ntp配置文件 vim /etc/ntp.conf #配置允许NTP Server时间服务器主动修改本机的时间 restrict 10.4.7.11 nomodify notrap noquery #注释掉其他时间服务器 #server 0.centos.pool.ntp.org iburst #server 1.centos.pool.ntp.org iburst #server 2.centos.pool.ntp.org iburst #server 3.centos.pool.ntp.org iburst #配置时间服务器为本地搭建的NTP Server服务器 server 10.4.7.11 同步主服务器(7.12 7.21 上操作） [root@hdss7-21 ~]# ntpdate -u 10.4.7.11 3 Jan 10:53:42 ntpdate[6675]: adjust time server 10.4.7.11 offset 0.015245 sec 查看NTP同步状态 [root@hdss7-21 ~]# ntpq -p remote refid st t when poll reach delay offset jitter ============================================================================== 10.4.7.11 139.199.21","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:0:2","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["数据库"],"content":"配置MySQL master主服务器 在/etc/my.cnf 中修改或者增加以下内容 [root@hdss7-11 ~]# tail -n 3 /etc/my.cnf server-id = 11 log-bin=master-bin log-slave-updates=true 重启mysql服务 systemctl restart mysqld 登录MySQL程序，给服务器授权 mysql -uroot -p 输入密码 mysql\u003egrant replication slave on *.* to 'myslave'@'10.4.7.%' identified by 'Haipengv123456?'; Query OK, 0 rows affected, 1 warning (0.00 sec) mysql\u003e flush privileges; Query OK, 0 rows affected (0.00 sec) mysql\u003e show master status; +-------------------+----------+--------------+------------------+-------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set | +-------------------+----------+--------------+------------------+-------------------+ | master-bin.000001 | 599 | | | | +-------------------+----------+--------------+------------------+-------------------+ 1 row in set (0.00 sec) file列显示的日志名，position 列显示偏移量。 ","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:0:3","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["数据库"],"content":"配置从服务器 7-12 server-id = 22 7-21 server-id = 23 在/etc/my.cnf 中修改或者增加以下内容： [root@hdss7-12 ~]# tail -n 3 /etc/my.cnf server-id = 22 ## 这里的ID不能与主服务器相同，也不能和其他从服务器相同 relay-log=relay-log-bin ## 从主服务器上同步日志到本地 relay-log-index=slave-relay-bin.index ## 定义relay-log的位置和名称 重启从服务器的MySQL 登录mysql # mysql -uroot -p Enter password: 配置同步 根据主服务器的结果来更改下面的master_log_file 和master_log_post 的参数 mysql\u003e change master to master_host='10.4.7.11',master_user='myslave',master_password='Haipengv123456?',master_log_file='master-bin.000001',master_log_pos=599; Query OK, 0 rows affected, 2 warnings (0.02 sec) 启动同步 mysql\u003e start slave; Query OK, 0 rows affected (0.35 sec) mysql\u003e 查看slave确保两个值都为yes mysql\u003e show slave status \\G *************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 10.4.7.11 Master_User: myslave Master_Port: 3306 Connect_Retry: 60 Master_Log_File: master-bin.000001 Read_Master_Log_Pos: 599 Relay_Log_File: relay-log-bin.000002 Relay_Log_Pos: 321 Relay_Master_Log_File: master-bin.000001 Slave_IO_Running: Yes Slave_SQL_Running: Yes ","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:0:4","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["数据库"],"content":"验证主从复制结果 在主服务器上创建数据库 10.4.7.11 主服务器 mysql\u003e create database db_test; Query OK, 1 row affected (0.00 sec) 查看主从服务器的数据库是否同步 主服务器： mysql\u003e show databases; +--------------------+ | Database | +--------------------+ | information_schema | | db_test | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec) slave1 mysql\u003e show databases; +--------------------+ | Database | +--------------------+ | information_schema | | db_test | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec) slave2 mysql\u003e show databases; +--------------------+ | Database | +--------------------+ | information_schema | | db_test | | mysql | | performance_schema | | sys | +--------------------+ 5 rows in set (0.00 sec) ","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:0:5","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["数据库"],"content":"拓展server-id的用途 server-id用于标识数据库实例，防止在链式主从、多主多从拓扑中导致SQL语句的无限循环： 标记binlog event的源实例 过滤主库binlog，当发现server-id相同时，跳过该event执行，避免无限循环执行。 如果设置了replicate-same-server-id=1，则执行所有event，但有可能导致无限循环执行SQL语句。 我们用两个例子来说明server-id为什么不要重复： ","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:0:6","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["数据库"],"content":"当主库和备库server-id重复时 由于默认情况replicate-same-server-id=0，因此备库会跳过所有主库同步的数据，导致主从数据的不一致。 ","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:0:7","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["数据库"],"content":"当两个备库server-id重复时 会导致从库跟主库的连接时断时连，产生大量异常。根据MySQL的设计，主库和从库通过事件机制进行连接和同步，当新的连接到来时，如果发现server-id相同，主库会断开之前的连接并重新注册新连接。当A库连接上主库时，此时B库连接到来，会断开A库连接，A库再进行重连，周而复始导致大量异常信息。 ","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:0:8","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["数据库"],"content":"生成server-id的规则 既然server-id不能相同，而当我们有10个实例时，怎么保证每个都不同呢？有几种常用的方法： 随机数 时间戳 IP地址+端口 在管理中心集中分配，生成自增ID 上面的这些方法都可以，但是注意不要超过了最大值2^32-1，同时值最好\u003e2。我采用的方法是IP地址后两位+本机MySQL实例序号，但如果是通过docker来进行管理多实例时，这个怎么生成大家可以想下有没有什么优美的解决方案。 ","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:0:9","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["数据库"],"content":"server-uuid配置 MySQL服务会自动创建并生成server-uuid配置： 读取${data_dir}/auto.cnf文件中的UUID 如果不存在，自动创建文件和生成新的UUID并读取 shell\u003e cat ~/mysql/data/auto.cnf [auto] server-uuid=fd5d03bc-cfde-11e9-ae59-48d539355108 这个auto.cnf配置风格类似于my.cnf，但这个文件只包含一个auto配置块和一行server-uuid配置。它是自动创建的，因此不要修改它的内容。 在主从拓扑中，主从可以知道互相的UUID，在主机上使用show slave hosts，在从机上使用show slave status查看Master_UUID字段。 server-uuid参数并不能取代server-id，他们有不同的作用。当主从同步时如果主从实例的server-uuid相同会报错退出，不过我们可以通过设置replicate-same-server-id=1来避免报错（不推荐）。 ","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:1:0","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["数据库"],"content":"参考资料 参考 ","date":"2022-01-03","objectID":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/:1:1","tags":["mysql"],"title":"mysql主从架构","uri":"/mysql%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/"},{"categories":["工具"],"content":"nginx 1.16.1 安装使用说明 1.创建目录 mkdir -p /var/temp/nginx 下载： https://nginx.org/en/download.html 解压 tar -zxvf nginx-1.16.1.tar.gz 安装编译依赖包： yum install -y gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel 2.进入nginx-1.16.1 编译参数 ./configure \\ --prefix=/usr/local/nginx \\ --pid-path=/var/run/nginx/nginx.pid \\ --lock-path=/var/lock/nginx.lock \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --with-http_gzip_static_module \\ --http-client-body-temp-path=/var/temp/nginx/client \\ --http-proxy-temp-path=/var/temp/nginx/proxy \\ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ --http-scgi-temp-path=/var/temp/nginx/scgi https://nginx.org/en/download.html ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"config 编译参数 nginx1.16编译安装configure参数： [root@363ee3055cf0 nginx-1.16.1]# ./configure --help --help print this message 打印帮助信息 --prefix=PATH set installation prefix 设置安装目录 --sbin-path=PATH set nginx binary pathname 设置sbin路径 --modules-path=PATH set modules path 设置模块路径 --conf-path=PATH set nginx.conf pathname 设置配置文件路径 --error-log-path=PATH set error log pathname 设置错误日志的路径 --pid-path=PATH set nginx.pid pathname 设置pid路径 --lock-path=PATH set nginx.lock pathname 设置锁路径 --user=USER set non-privileged user for 设置用户 worker processes --group=GROUP set non-privileged group for 设置组 worker processes --build=NAME set build name 设置构建名 --builddir=DIR set build directory 设置构建文件夹 --with-select_module enable select module 开启select模块 --without-select_module disable select module关闭 --with-poll_module enable poll module --without-poll_module disable poll module --with-threads enable thread pool support --with-file-aio enable file AIO support --with-http_ssl_module enable ngx_http_ssl_module --with-http_v2_module enable ngx_http_v2_module --with-http_realip_module enable ngx_http_realip_module --with-http_addition_module enable ngx_http_addition_module --with-http_xslt_module enable ngx_http_xslt_module --with-http_xslt_module=dynamic enable dynamic ngx_http_xslt_module --with-http_image_filter_module enable ngx_http_image_filter_module --with-http_image_filter_module=dynamic enable dynamic ngx_http_image_filter_module --with-http_geoip_module enable ngx_http_geoip_module --with-http_geoip_module=dynamic enable dynamic ngx_http_geoip_module --with-http_sub_module enable ngx_http_sub_module --with-http_dav_module enable ngx_http_dav_module --with-http_flv_module enable ngx_http_flv_module --with-http_mp4_module enable ngx_http_mp4_module --with-http_gunzip_module enable ngx_http_gunzip_module --with-http_gzip_static_module enable ngx_http_gzip_static_module --with-http_auth_request_module enable ngx_http_auth_request_module --with-http_random_index_module enable ngx_http_random_index_module --with-http_secure_link_module enable ngx_http_secure_link_module --with-http_degradation_module enable ngx_http_degradation_module --with-http_slice_module enable ngx_http_slice_module --with-http_stub_status_module enable ngx_http_stub_status_module --without-http_charset_module disable ngx_http_charset_module --without-http_gzip_module disable ngx_http_gzip_module --without-http_ssi_module disable ngx_http_ssi_module --without-http_userid_module disable ngx_http_userid_module --without-http_access_module disable ngx_http_access_module --without-http_auth_basic_module disable ngx_http_auth_basic_module --without-http_mirror_module disable ngx_http_mirror_module --without-http_autoindex_module disable ngx_http_autoindex_module --without-http_geo_module disable ngx_http_geo_module --without-http_map_module disable ngx_http_map_module --without-http_split_clients_module disable ngx_http_split_clients_module --without-http_referer_module disable ngx_http_referer_module --without-http_rewrite_module disable ngx_http_rewrite_module --without-http_proxy_module disable ngx_http_proxy_module --without-http_fastcgi_module disable ngx_http_fastcgi_module --without-http_uwsgi_module disable ngx_http_uwsgi_module --without-http_scgi_module disable ngx_http_scgi_module --without-http_grpc_module disable ngx_http_grpc_module --without-http_memcached_module disable ngx_http_memcached_module --without-http_limit_conn_module disable ngx_http_limit_conn_module --without-http_limit_req_module disable ngx_http_limit_req_module --without-http_empty_gif_module disable ngx_http_empty_gif_module --without-http_browser_module disable ngx_http_browser_module --without-http_upstream_hash_module disable ngx_http_upstream_hash_module --without-http_upstream_ip_hash_module disable ngx_http_upstream_ip_hash_module --without-http_upstream_least_conn_module disable ngx_http_upstream_least_conn_module --without-http_upstream_random_module disable ngx_http_upstream_random_module --without-http_upstrea","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:1","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"nginx 的进程模型 master 主进程 worker 工作进程 worker_processes 2; # 默认为1,配置为n-1 .n为cpu数量。 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"nginx事件处理。异步非阻塞。 events { # 默认使用epoll use epoll; # 每个worker 允许连接的客户端最大连接数 worker_connections 10240; } ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:1","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"配置文件详解： server { listen 89; server_name localhost; location / { root html; index imooc.html index.htm; } } /usr/local/nginx/html/imooc.html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eWelcome to immoc!\u003c/title\u003e \u003cstyle\u003e body { width: 35em; margin: 0 auto; font-family: Tahoma, Verdana, Arial, sans-serif; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eWelcome imooc!\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 或者： nginx.conf中添加 include imooc.conf; 创建imooc.conf文件。 /usr/local/nginx/conf/imooc.conf server { listen 89; server_name localhost; location / { root html; index imooc.html index.htm; } } 每次更改后都要重启服务。 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"常见pid报错 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"nginx.pid打开失败： 1.nginx: [error] invalid PID number \"\" in “/usr/local/nginx/logs/nginx.pid” 解决方法： 使用nginx -c的参数指定nginx.conf文件的位置 然后再重新启动，解决问题，可以通过ps -ef|grep nginx 看到服务已经启动成功。 /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 2.nginx: [error] open() “/var/run/nginx/nginx.pid” failed (2: No such file or directory) 提示信息说明在 /var/run/nginx/ 目录下找不到 nginx.pid 文件，解决方式有两种 第一种方式：创建默认目录 /var/run/nginx/ ； 第二种方式：修改 nginx.conf 文件，指定 pid文件 所在目录。 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:1","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"日志切割：(手动) cat_my_log.sh #!/bin/bash LOG_PATH=\"/var/log/nginx/\" RECORD_TIME=$(date -d \"yesterday\" +%Y-%m-%d+%H:%M) PID=/var/run/nginx/nginx.pid mv ${LOG_PATH}/access.log ${LOG_PATH}/access.${RECORD_TIME}.log mv ${LOG_PATH}/error.log ${LOG_PATH}/error.${RECORD_TIME}.log #向nginx主进程发送信号，用于重新打开日志文件 kill -USR1 `cat $PID` chmod +x cat_my_log.sh ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"日志切割：(定时) 1.安装定时任务 yum install crontabs 2.crontab -e 编辑并添加一行新的任务 */1 * * * * /usr/local/nginx/sbin/cut_my_log.sh 3.重启定时任务 service crond restart 4.常用定时任务 service crond start service crond stop service crond reload #重新加载 service crond restart #重启服务 crontab -l #查看任务列表 crontab -e # 编辑任务 每分钟执行 */1 * * * * 每日凌晨（每天晚上23：59）执行： 59 23 * * * 每日凌晨1点执行： 0 1 * * * 每天为数据库定时备份：参考 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:6:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"虚拟主机-使用nginx为静态资源提供服务 静态资源可以是mp4、png、jpg等等。 /usr/local/nginx/conf/imooc.conf中创建静态资源路径。 server { listen 90; server_name localhost; location / { root /home/foodie-shop; index index.html; } location /static { alias /home/imooc; } location /imooc { root /home; } } 请求/home/imooc下的资源。 两种写法： 一、正常请求： location /imooc { root /home; } 直接请求： http://10.4.7.129:90/imooc/456.jpg 二、给路径起别名： 将/home/imooc创建别名 为/static location /static { alias /home/imooc; } 请求时用别名请求 http://10.4.7.129:90/static/456.jpg 将imooc.conf文件内容应用到nginx.conf中 编辑/usr/local/nginx/conf/nginx.conf 单独添加一行： include imooc.conf; 检测配置是否正确： /usr/local/nginx/sbin/nginx -t nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful 重启nginx /usr/local/nginx/sbin/nginx -s reload 测试结果： http://10.4.7.129:90/imooc/456.jpg http://10.4.7.129:90/static/456.jpg ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:7:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"gzip压缩提升请求效率 #开启gzip压缩功能，目的：提高传输效率，节约带宽 gzip on; #限制最小压缩，小于1字节的文件不会压缩 gzip_min_length 1; #的定义压缩的级别（压缩比，文件越大，压缩越多，但是cpu使用会越多） gzip_comp_level 3; #定义压缩文件类型 gzip_types text/plain application/javascript application/x-javascript test/css application/xml text/javascript application/x-httpd/php image/jpeg image/gif image/png application/json; ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:8:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"location匹配规则 空格：默认匹配，普通匹配 server { listen 91; server_name localhost; location / { root html; index imooc.html index.htm; } } = ：精确匹配 server { listen 91; server_name localhost; #精确匹配 location = / { root html; index imooc.html index.htm; } } 正则表达式。 /home/imooc/img [root@centos7 img]# ll total 808 -rw-r--r--. 1 root root 25125 Jun 30 19:40 456.jpg -rw-r--r--. 1 root root 25125 Dec 19 00:12 456.JPG -rw-r--r--. 1 root root 383222 Dec 13 19:25 AutoPlayOptIn.gif -rw-r--r--. 1 root root 383222 Dec 19 00:17 AutoPlayOptIn.GIF ~* ：匹配正则表达式，*代表不区分大小写 http://10.4.7.129:92/imooc/img/456.JGP (可以访问)不论是否定义了.JPG这种类型都能访问。 ~ ：匹配正则表达式，区分大小写 http://10.4.7.129:92/imooc/img/456.JGP (不能访问)因为没有定义.JPG这种类型能访问。 server { listen 92; server_name localhost; #正则表达式。*代表不区分大小写 location ~* \\.(GIF|png|bmp|jpg|jpeg) { root /home; } } server { listen 92; server_name localhost; #正则表达式。*代表不区分大小写 location ~ \\.(GIF|png|bmp|jpg|jpeg) { root /home; } } ^~ 以某个字符路径开头请求 server { listen 93; server_name localhost; #^~ 以某个字符路径开头请求 location ^~ /imooc/img { root /home; } } ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:9:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"DNS解析域名 user-\u003e client(www.imooc.com ) -\u003e nginx(代理服务器192.168.1.88 小区大门) —\u003e tomcat1 （目标服务器 内网） ##号楼##室 ​ —\u003e tomcat2 （目标服务器 内网）##号楼##室 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:10:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"用switchhosts 模拟本地域名解析访问 https://cloud.tencent.com/developer/article/1408956 https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Foldj%2FSwitchHosts%2Freleases%2Fdownload%2Fv3.3.12%2FSwitchHosts-win32-ia32_v3.3.12.5349.zip 自定义hosts 一键切换。不用更改本机hosts 定义nginx-dev-imooc 的hosts 添加映射： 10.4.7.129 www.imooc.com 访问： www.imooc.com 显示10.4.7.129 默认界面 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:11:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"跨域访问 当出现403跨域错误的时候 No 'Access-Control-Allow-Origin' header is present on the requested resource，需要给Nginx服务器配置响应的header参数： 只需要在Nginx的配置文件中配置以下参数： location / { #允许跨域请求的域，*代表所有 add_header 'Access-Control-Allow-Origin' *; #允许请求的方法，比如GET, POST, DELETE，PUT add_header 'Access-Control-Allow-Methods' *; #允许带上cookie请求 add_header 'Access-Control-Allow-Credentails' 'true'; #允许请求的HEADER add_header 'Access-Control-Allow-Headers' *; if ($request_method = 'OPTIONS') { return 204; } } ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:12:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"nginx 防盗链技术支持 #对源站点验证 valid_referers *.imooc.com; #非法引入会进入下方判断 if ($invalid_referer) { return 404; } ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:13:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"nginx 模块化体系 [root@centos7 nginx-1.16.1]# ll total 756 drwxr-xr-x. 6 1001 1001 4096 Dec 17 04:04 auto #一些判断操作系统支持，编译等相关的文件 -rw-r--r--. 1 1001 1001 296463 Aug 13 2019 CHANGES #版本的更改日志 -rw-r--r--. 1 1001 1001 452171 Aug 13 2019 CHANGES.ru #俄版版本的更改日志 drwxr-xr-x. 2 1001 1001 168 Dec 17 04:04 conf #配置文件夹 -rwxr-xr-x. 1 1001 1001 2502 Aug 13 2019 configure #编译配置程序 drwxr-xr-x. 4 1001 1001 72 Dec 17 04:04 contrib #提供了语法高亮支持脚本，让vim打开时，语法高亮。需要拷贝contrib 中到 本地vim目录(如果根目录没有该目录，先mkdir ~/.vim) drwxr-xr-x. 2 1001 1001 40 Dec 17 04:04 html #默认页面 -rw-r--r--. 1 1001 1001 1397 Aug 13 2019 LICENSE #许可证书 -rw-r--r--. 1 root root 355 Dec 17 04:19 Makefile #编译后的文件 drwxr-xr-x. 2 1001 1001 21 Dec 17 04:04 man #使用手册 drwxr-xr-x. 3 root root 174 Dec 17 04:20 objs #第三方插件 -rw-r--r--. 1 1001 1001 49 Aug 13 2019 README drwxr-xr-x. 9 1001 1001 91 Dec 17 04:04 src #源码 cd conf [root@centos7 conf]# ll total 40 -rw-r--r--. 1 1001 1001 1077 Aug 13 2019 fastcgi.conf -rw-r--r--. 1 1001 1001 1007 Aug 13 2019 fastcgi_params -rw-r--r--. 1 1001 1001 2837 Aug 13 2019 koi-utf -rw-r--r--. 1 1001 1001 2223 Aug 13 2019 koi-win -rw-r--r--. 1 1001 1001 5231 Aug 13 2019 mime.types -rw-r--r--. 1 1001 1001 2656 Aug 13 2019 nginx.conf # 核心配置文件 -rw-r--r--. 1 1001 1001 636 Aug 13 2019 scgi_params -rw-r--r--. 1 1001 1001 664 Aug 13 2019 uwsgi_params -rw-r--r--. 1 1001 1001 3610 Aug 13 2019 win-utf [root@centos7 html]# ll total 8 -rw-r--r--. 1 1001 1001 494 Aug 13 2019 50x.html -rw-r--r--. 1 1001 1001 612 Aug 13 2019 index.html [root@centos7 objs]# ll total 3888 -rw-r--r--. 1 root root 17763 Dec 17 04:19 autoconf.err -rw-r--r--. 1 root root 40485 Dec 17 04:19 Makefile -rwxr-xr-x. 1 root root 3857136 Dec 17 04:20 nginx -rw-r--r--. 1 root root 5327 Dec 17 04:20 nginx.8 -rw-r--r--. 1 root root 7363 Dec 17 04:19 ngx_auto_config.h -rw-r--r--. 1 root root 657 Dec 17 04:19 ngx_auto_headers.h -rw-r--r--. 1 root root 5975 Dec 17 04:19 ngx_modules.c -rw-r--r--. 1 root root 32552 Dec 17 04:20 ngx_modules.o drwxr-xr-x. 9 root root 91 Dec 17 04:19 src [root@centos7 src]# ll total 20 drwxr-xr-x. 2 1001 1001 4096 Dec 17 04:04 core #核心源码 drwxr-xr-x. 3 1001 1001 4096 Dec 17 04:04 event #事件 drwxr-xr-x. 4 1001 1001 4096 Dec 17 04:04 http drwxr-xr-x. 2 1001 1001 4096 Dec 17 04:04 mail drwxr-xr-x. 2 1001 1001 74 Dec 17 04:04 misc #辅助代码 drwxr-xr-x. 3 1001 1001 18 Dec 17 04:04 os #系统 drwxr-xr-x. 2 1001 1001 4096 Aug 13 2019 stream [root@centos7 http]# ls modules ngx_http_file_cache.c ngx_http_request.h ngx_http_upstream_round_robin.h ngx_http.c ngx_http.h ngx_http_script.c ngx_http_variables.c ngx_http_cache.h ngx_http_header_filter_module.c ngx_http_script.h ngx_http_variables.h ngx_http_config.h ngx_http_parse.c ngx_http_special_response.c ngx_http_write_filter_module.c ngx_http_copy_filter_module.c ngx_http_postpone_filter_module.c ngx_http_upstream.c v2 ngx_http_core_module.c ngx_http_request_body.c ngx_http_upstream.h ngx_http_core_module.h ngx_http_request.c ngx_http_upstream_round_robin.c ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:14:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"负载均衡 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:15:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"四层负载均衡 主要是为了将请求分流到不同服务器 F5 硬负载均衡 基于硬件、商业化 LVS 四层负载均衡 Haproxy 四层负载均衡 Nginx 四层负载均衡 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:15:1","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"七层负载均衡 基于应用层HTTP协议进行负载均衡 Nginx 七层负载均衡 Haproxy 七层负载均衡 apache 七层负载均衡 四层主要是tcp、udp转发请求，而不是处理请求 七层会处理请求，可以过滤、压缩、缓存等 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:15:2","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"DNS 地域负载均衡 可以根据请求者地域，分配到最近的服务器 减少网络传输的损耗 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:15:3","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"使用Nginx搭建三台tomcat集群 tomcat1 :10.4.7.11 tomcat2 :10.4.7.12 tomcat3 :10.4.7.21 tomcat安装：10.4.7.{11,12,21}都要安装 yum install tomcat -y yum install tomcat-webapps tomcat-admin-webapps tomcat-docs-webapp tomcat-javadoc #关闭防火墙 systemctl stop firewalld systemctl disable firewalld #启动tomcat systemctl restart tomcat 10.4.7.129 (nginx服务器)上配置tomcat集群 vim imooc.conf upstream tomcats { server 10.4.7.11:8080; server 10.4.7.12:8080; server 10.4.7.21:8080; } server { listen 80; server_name www.tomcats.com; location / { proxy_pass http://tomcats; } } 重启nginx /usr/local/nginx/sbin/nginx -s reload windwos配置hosts规则： 10.4.7.129 www.tomcats.com 测试访问。 www.tomcats.com 请求会平均分配给后面三台tomcat. 参考：http://tengine.taobao.org/book/chapter_05.html ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:16:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"负载均衡之轮询 默认nginx使用的是轮询。交替出现。出现次数均等。 修改每台tomcat默认页面 /usr/share/tomcat/webapps/ROOT/index.jsp 第37行。home改成对应IP最后一位。 37 \u003cspan id=\"nav-home\"\u003e\u003ca href=\"${tomcatUrl}\"\u003e12\u003c/a\u003e\u003c/span\u003e 重启tomcat systemctl restart tomcat ![nginx 轮询](/postimages/nginx 轮询.webp) 11 12 21 会交替出现。 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:17:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"负载均衡之权重-加权轮询 weight 值越大，出现的次数越多（后端服务器被访问的次数就越多）。 配置在upstream 模块内。 upstream tomcats { server 10.4.7.11:8080 weight=1; server 10.4.7.12:8080 weight=2; server 10.4.7.21:8080 weight=3; } 11:12:21 = 1:2:3 21出现几率最大。 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:18:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"upstream 指令参数 max_conns :限制*number*到代理服务器的最大同时活动连接数.默认值为零，表示没有限制。如果启用了idle keepalive 连接、多个worker 和共享内存 ，则代理服务器的 active 和 idle 连接总数可能会超过该max_conns值。允许最大连接数。 限制每台server的连接数，用于保护避免过载起到限流作用。 测试参考配置如下： #worker 进程设置1个，便于测试观察成功的连接数。 worker_processes 1 upstream tomcats { server 10.4.7.11:8080 max_conns=2; server 10.4.7.12:8080 max_conns=2; server 10.4.7.21:8080 max_conns=2; } slow_start:当节点恢复，不立即加入,而是等待 slow_start 后加入服务对列.(仅商业版支持) 测试参考配置如下： upstream tomcats { server 10.4.7.11:8080 weight=6 slow_start=60s; server 10.4.7.12:8080 weight=2; server 10.4.7.21:8080 weight=2; } 注意： 该参数不能使用在hash 和random load balancing中 如果在upstream中只有一台server，则该参数失效。 down :将服务器标记为永久不可用。 测试参考配置如下： upstream tomcats { server 10.4.7.11:8080 down; server 10.4.7.12:8080 weight=2; server 10.4.7.21:8080 weight=2; } backup:将服务器标记为备份服务器,只有在其他的服务器都宕机以后，自己才会加入到集群中，被用户访问到。 该参数不能与 hash 、ip_hash 和随机 负载平衡方法一起使用。 upstream tomcats { server 10.4.7.11:8080 backup; server 10.4.7.12:8080 weight=1; server 10.4.7.21:8080 weight=1; } max_fails:失败几次，则标记server已宕机，剔出上游服务。 fail_timeout:表示失败的重试时间。 假设目前设置如下： max_fails=2 fail_timeout=15s 则表示在15秒内请求某一server失败达到2次后，则认为该server已经挂了或者宕机了，随后再过15s，这15s内不会有新的请求到达刚刚挂掉的节点上，而是会请求到正常运作的server，15秒后会在有新请求尝试连接挂掉的server，如果还是失败，重复上一过程，直到恢复。 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:19:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"使用keepalive提高吞吐量 https://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive 测试配置： upstream tomcats { server 10.4.7.11:8080 weight=1; server 10.4.7.12:8080 weight=1; server 10.4.7.21:8080 weight=1; keepalive 32; #配置长连接的数量，保持连接可以提高吞吐量 } server { listen 80; server_name www.tomcats.com; location / { proxy_pass http://tomcats; proxy_http_version 1.1; #代表上面长连接的版本号，（默认1.0，但1.0不是长链接） proxy_set_header Connection \"\"; } } ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:20:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"负载均衡之ip_hash hash算法 hash(ip) % node_counts = index 算出用户访问的服务器具体是哪一台 保证用户访问的服务器是同一台，保持会话一致 测试配置： upstream tomcats { ip_hash; server 10.4.7.11:8080; server 10.4.7.12:8080; server 10.4.7.21:8080; } 10.4.7.110 10.4.7.120 —\u003e hash(10 4 7) 10.4.7.210 分段进行计算，同一片区域，会访问到一个里 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:21:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"负载均衡之url_hash 通过配置hash $request_uri 开启url_hash ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:21:1","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"nginx控制浏览器缓存 1、设置静态内容的过期时间(expires time;) location /static { alias /home/naga; expires 10s; } 2、固定时间 expires @[time] expires @22h30s; 代表晚上10:30pm失效，浏览器会自动计算时间差 3、 expires -[time] expires -1h; 距离现在的1小时之前就失效了，相当于不用缓存 4、expires eposh; 不使用缓存 5、expires off; 默认值，其实就是不管，由浏览器自己使用自己的默认缓存 6、expires max; 缓存不会过期，除非修改过。 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:22:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"上游服务静态内容缓存 keys_zone 是内存缓存 max_size 是硬盘缓存 upstream xxx { ... } # proxy_cache_path 设置缓存保存的地址，目录会自动创建 # keys_zone 设置共享内存，以及占用的空间大小 ## 内存缓存 ## (mycache是共享内存名，下面) # max_size 设置缓存大小 # inactive 超过此时间，缓存自动清理 # use_temp_path=off 关闭临时目录 proxy_cache_path /usr/local/nginx/upstream_cache keys_zone=mycache:50m max_size=30g inactive=8h use_temp_path=off; server { listen 80; server_name www.naga.cn; #开启并且使用缓存 proxy_cache mycache; #针对200和304状态码的缓存设置过期时间 proxy_cache_valid 200 304 8h; } ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:23:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"使用nginx 配置https域名证书 安装ssl模块 要在nginx中配置https,及必须安装ssl模块，也就是‘http_ssl_module’. 进入到nginx解压目录：nginx-1.16.1 新增ssl模块（原来的模块需要保留）–with-http_ssl_module ./configure \\ --prefix=/usr/local/nginx \\ --pid-path=/var/run/nginx/nginx.pid \\ --lock-path=/var/lock/nginx.lock \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --with-http_gzip_static_module \\ --http-client-body-temp-path=/var/temp/nginx/client \\ --http-proxy-temp-path=/var/temp/nginx/proxy \\ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \\ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \\ --http-scgi-temp-path=/var/temp/nginx/scgi \\ --with-http_ssl_module 编译和安装： make make install ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:24:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"配置ssl 1、云上申请证书，审核完成后将证书下载下来，nginx包含两个文件，一个crt证书文件，一个key密钥文件 2、将文件上传到云服务器，可以放在conf下 3、修改nginx.conf (事先在nginx里面加入ssl模块 –with-http_ssl_module, 安装后通过 ./nginx -V 查看 ) server { listen 443; server_name localhost; # 开启ssl ssl on; # 配置ssl证书 因为放在conf下的，和nginx.conf同一路径，就这样写就行 ssl_certificate 1_www.imoocdsp.com_bundle.crt; # 配置证书秘钥 ssl_certificate_key 2_www.imoocdsp.com.key; # ssl会话cache ssl_session_cache shared:SSL:1m; # ssl会话超时时间 ssl_session_timeout 5m; # 配置加密套件，写法遵循 openssl 标准 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; } ### 将http的请求转发到https server { listen 80; server_name localhost; # 排除法 if ($http_name ~* \"^online$\" ) { rewrite ^/(.*)$ https://localhost/online/ permanent; } rewrite ^ https://$host$1 permanent; } ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:25:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"动静分离 1.分布式 2.前后端解耦 3.静态归nginx 4.接口服务化 静态数据：css/js/html/images/audios/videos/… 动态数据：得到的响应可能会和上次不同。 动静分离的问题 跨域： springboot nginx jsonp 分布式会话： 分布式缓存中间件Redis ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:26:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"nginx高可用HA keepalived 双机主备 keepalived 使用的是虚拟路由冗余协议 VRRP ，这个协议的特点如下： 1、解决内网单机故障的路由协议， 2、用于构建过个路由MASTER BACKUP，将几台提供相同服务的路由器组成一个路由器组。一个路由就是nginx 3、虚拟IP-VIP（Virtual IP Address） 过程：用户不直接访问nginx，访问虚拟IP，这个虚拟IP是绑定了nginx的master节点，会根据这个关系解析出来结果。 master主节点挂了，心跳检测到后会让虚拟IP找到备用机，多个备用机会根据权重选择。 此外，主备节点的硬件配置应一样。 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:27:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"安装keepalived 解压后进入文件夹进行配置，类似nginx，但是需要用 –sysconf=/etc指定配置文件地址 yum -y install libnl libnl-devel ./configure --prefix=/usr/local/keepalived --sysconf=/etc make \u0026\u0026 make install prefix：keepalived安装的位置 sysconf：keepalived核心配置文件所在位置，固定位置，改成其他位置则keepalived启动不了。会报错。 libnl libnl-devel 是libnl/libnl-3依赖包。 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:28:0","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"核心配置文件： !Configuration File for keepalived # 全局配置 global_defs { # 节点故障，切换了节点之后会通知管理员，下面还要配置邮箱的协议等，可以不要 notification_email { 123456@qq.com } notification_email_from Alexandre.Cassen@firewall.loc smtp_server 192.168.200.1 smtp_connect_timeout 30 # 路由ID：当前安装keepalived节点主机的标识符，全局唯一 router_id naga_170 vrrp_skip_check_adv_addr vrrp_strict vrrp_garp_interval 0 vrrp_gna_interval 0 } #基于VRRP协议的对象，计算机节点 vrrp_instance VI_1 { state MASTER # 表示当前为nginx的master主节点 interface eth0 # 当前实例绑定的网卡， 用 ip addr查看 virtual_router_id 51 #虚拟路由ID，主备节点需要一致 priority 100 #权重，备机优先级越高就成为新的master advert_int 1 # 主备心跳检查，时间间隔1s authentication { # 认证授权，防止非法节点。每个节点一样就可以 auth_type PASS auth_pass 1111 } virtual_ipaddress { # 虚拟IP，用一个就可以了 192.168.17.17 #192.168.200.17 #192.168.200.18 } } #下面的都可以不要 virtual_server 192.168.200.100 443 { delay_loop 6 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 192.168.201.100 443 { weight 1 SSL_GET { url { path / digest ff20ad2481f97b1754ef3e12ecd3a9cc } url { path /mrtg/ digest 9b3a0c85a887a256d6939da88aabd8cd } connect_timeout 3 retry 3 delay_before_retry 3 } } } virtual_server 10.10.10.2 1358 { delay_loop 6 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP sorry_server 192.168.200.200 1358 real_server 192.168.200.2 1358 { weight 1 HTTP_GET { url { path /testurl/test.jsp digest 640205b7b0fc66c1ea91c463fac6334d } url { path /testurl2/test.jsp digest 640205b7b0fc66c1ea91c463fac6334d } url { path /testurl3/test.jsp digest 640205b7b0fc66c1ea91c463fac6334d } connect_timeout 3 retry 3 delay_before_retry 3 } } real_server 192.168.200.3 1358 { weight 1 HTTP_GET { url { path /testurl/test.jsp digest 640205b7b0fc66c1ea91c463fac6334c } url { path /testurl2/test.jsp digest 640205b7b0fc66c1ea91c463fac6334c } connect_timeout 3 retry 3 delay_before_retry 3 } } } virtual_server 10.10.10.3 1358 { delay_loop 3 lb_algo rr lb_kind NAT persistence_timeout 50 protocol TCP real_server 192.168.200.4 1358 { weight 1 HTTP_GET { url { path /testurl/test.jsp digest 640205b7b0fc66c1ea91c463fac6334d } url { path /testurl2/test.jsp digest 640205b7b0fc66c1ea91c463fac6334d } url { path /testurl3/test.jsp digest 640205b7b0fc66c1ea91c463fac6334d } connect_timeout 3 retry 3 delay_before_retry 3 } } real_server 192.168.200.5 1358 { weight 1 HTTP_GET { url { path /testurl/test.jsp digest 640205b7b0fc66c1ea91c463fac6334d } url { path /testurl2/test.jsp digest 640205b7b0fc66c1ea91c463fac6334d } url { path /testurl3/test.jsp digest 640205b7b0fc66c1ea91c463fac6334d } connect_timeout 3 retry 3 delay_before_retry 3 } } } 示例： #### 第一台 #### ! Configuration File for keepalived #全局变量-路由id，标识主机id global_defs { router_id keep_140 } #计算机节点 vrrp_instance VI_1 { state MASTER #标示当前机器为主节点，从节点BACKUP interface ens33 #当前网卡 virtual_router_id 51 #保持主备机一致 priority 100 #权重，最高的当选下一任主机 advert_int 1 #检查时间间隔1s authentication { #认证授权，防止非法节点进入 auth_type PASS auth_pass 1111 } virtual_ipaddress { #虚拟ip 10.4.7.211 } } #### 第二台 #### ! Configuration File for keepalived #全局变量-路由id，标识主机id global_defs { router_id keep_141 } #计算机节点 vrrp_instance VI_1 { state BACKUP #标示当前机器为从节点 interface ens33 #当前网卡 virtual_router_id 51 #保持主备机一致 priority 80 #权重，最高的当选下一任主机 advert_int 1 #检查时间间隔1s authentication { #认证授权，防止非法节点进入 auth_type PASS auth_pass 1111 } virtual_ipaddress { #虚拟ip，保持和主节点一致 10.4.7.211 } } 测试： 两台机器nginx 和keeplived进程都在。两台一主一备的目的是，主服务器keeplived挂了，vip切到备服务器上，业务不中断。默认vip是在主上生效的。主备的keepalived进程都在，vip会在主上生效。vip切到备服务器上时.主服务器上的keepalived恢复了。vip会再次切回到主服务器上。 ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:28:1","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["工具"],"content":"keepalived配置Nginx自动启动 这时如果nginx挂了，keepalived没有挂，还是会无法访问。 1.脚本（主从都配置） cd /etc/keepalived vim check_nginx_alive.sh #!/bin/bash A=`ps -C nginx --no-header | wc -l` # 进程数是0的话，就尝试重启nginx if [ $A -eq 0 ]; then /usr/local/nginx/sbin/nginx # 等一会儿再次检查ngxin，如果nginx没有启动成功，则停止当前机器的keepalived，使用备用机器 sleep 3 if [ `ps -C nginx --no-header | wc -l` -eq 0 ]; then killall keepalived fi fi 执行这个脚本后，会检测nginx，挂掉会重启nginx。 我们将它配置到keepalived配置文件里。 ! Configuration File for keepalived global_defs { router_id keep_140 } vrrp_script check_nginx_alive { script \"/etc/keepalived/check_nginx_alive.sh\" interval 2 #每隔两秒钟运行脚本检测 weight 10 #脚本运行成功，升级权重+10 } vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 10.4.7.211 } #在此执行上面的定时器 track_script{ check_nginx_alive } } 双机主备缺点 这样我们就能保证高可用的架构了，但是双机主备会有资源浪费的问题，主机永远不挂机，备机白干活儿。 Keepalived 双主热备 双机使用两个虚拟IP，互为主备。 使用DNS轮询两个虚拟IP进行访问，这样两台服务器都可以使用了。解析域名的时候，给域名解析两个云服务器的ip地址，再均衡权重即可。 配置（原主节点）： ! Configuration File for keepalived global_defs { router_id keep_140 } vrrp_script check_nginx_alive { script \"/etc/keepalived/check_nginx_alive.sh\" interval 2 #每隔两秒钟运行脚本检测 weight 10 #脚本运行成功，升级权重+10 } #211主节点 vrrp_instance VI_1 { state MASTER interface ens33 virtual_router_id 51 priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 10.4.7.211 } track_script{ check_nginx_alive } } #212从节点 vrrp_instance VI_2 { #名字要改 state BACKUP interface ens33 virtual_router_id 52 #换了一组实例，改 priority 80 advert_int 1 authentication { auth_type PASS auth_pass 1111 } track_script { check_nginx_alive } virtual_ipaddress { 10.4.7.212 #VIP更改 虚拟ip virtual IP } track_script{ check_nginx_alive } } 配置（原从节点）： ! Configuration File for keepalived global_defs { router_id keep_141 } vrrp_script check_nginx_alive { script \"/etc/keepalived/check_nginx_alive.sh\" interval 2 #每隔两秒钟运行脚本检测 weight 10 #脚本运行成功，升级权重+10 } #211从节点 vrrp_instance VI_1 { state BACKUP interface ens33 virtual_router_id 51 priority 80 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 10.4.7.211 } track_script { check_nginx_alive } } #212主节点 vrrp_instance VI_2 { #第二组实例 state MASTER interface ens33 virtual_router_id 52 #第二组router_id priority 100 advert_int 1 authentication { auth_type PASS auth_pass 1111 } virtual_ipaddress { 10.4.7.212 #改为第二个虚拟ip } track_script { check_nginx_alive } } ","date":"2022-01-02","objectID":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:28:2","tags":["nginx"],"title":"nginx安装与使用","uri":"/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"Kubernetes （1.22.2）安装手册（Ubuntu非高可用版） ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:0:0","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"安装前准备工作 ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:1:0","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"（重要！）安装k8s 1.22.2 版本需要的硬件条件： 所有节点： cpu数量2个及以上 4G 以上内存 不用开虚拟化 (重要！！)虚拟机不要用克隆，每台都要单独创建否则会出问题。 未安装docker 之前创建一个快照。 安装docker、kubelet，并初始化集群后在创建一个快照。 未安装cni插件之前创建一个快照，以便于随时更改calico 和fluence kubeadm 初始化失败检查，重置kubeadm。 ip 地址规划： master: 10.4.7.60/24 gw:10.4.7.254 dns:114.114.114.114 worker1: 10.4.7.61/24 gw:10.4.7.254 dns:114.114.114.114 worker1: 10.4.7.61/24 gw:10.4.7.254 dns:114.114.114.114 各节点安装时需要更换apt源：(更新和安装deb包都很快！！！) http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:1:1","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"1. 设置hosts解析 操作节点：所有节点（master）均需执行 修改hostname hostname必须只能包含小写字母、数字、\",\"、\"-\"，且开头结尾必须是小写字母或数字 # 在master节点 hostnamectl set-hostname master #设置master节点的hostname # slave1节点 hostnamectl set-hostname worker1 # slave2节点 hostnamectl set-hostname worker2 ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:1:2","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"2. 调整系统配置 操作节点： 所有的master和slave节点（master,k8s-slave）需要执行 本章下述操作均以master为例，其他节点均是相同的操作（ip和hostname的值换成对应机器的真实值） 设置iptables iptables -P FORWARD ACCEPT /etc/init.d/ufw stop ufw disable 关闭swap swapoff -a # 防止开机自动挂载 swap 分区 rm /swap.img sed -i '/ swap / s/^\\(.*\\)$/#\\1/g' /etc/fstab 修改内核参数 cat \u003c\u003cEOF \u003e /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 net.ipv4.ip_forward=1 vm.max_map_count=262144 EOF modprobe br_netfilter sysctl -p /etc/sysctl.d/k8s.conf 设置apt源 apt-get update \u0026\u0026 apt-get install -y apt-transport-https ca-certificates software-properties-common curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository \"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" add-apt-repository \"deb [arch=amd64] https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main\" apt-get update #若上步出现NO_PUBLICKEY问题，参考https://www.cnblogs.com/jiangzuo/p/13667011.html ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:1:3","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"3. 安装docker 操作节点： 所有节点 apt-get install docker-ce=5:20.10.9~3-0~ubuntu-focal systemctl enable docker \u0026\u0026 systemctl start docker 注意要关闭docker 默认的cgroup 否则会出现kubeadm 初始化失败！！！！ 这是cgroup驱动问题。默认情况下Kubernetes cgroup驱动程序设置为system，但docker设置为systemd。我们需要更改Docker cgroup驱动，通过创建配置文件/etc/docker/daemon.json并添加以下行： {\"exec-opts\": [\"native.cgroupdriver=systemd\"]} 然后，为使配置生效，你必须重启docker和kubelet。 systemctl daemon-reloadsystemctl restart dockersystemctl restart kubelet 重置kubeadm sudo kubeadm reset 查看所有节点是否有污点 kubectl get nodes -o json | jq '.items[].spec.taints' ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:1:4","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"给kubectl 设置别名为k，永久生效。 退出当前用户在进入就生效了。 vi .bashrc alias k='kubectl' source ~/.bashrc 删除master节点上的污点，删除后pod可以调度到master上。 kubectl taint nodes --all node-role.kubernetes.io/master- ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:1:5","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"使用kubectl中的强制删除命令 kubectl delete pod podName -n NAMESPACE --force --grace-period=0 ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:1:6","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"自动补全 apt install bash-completion // locate bash_completion source /usr/share/bash-completion/bash_completion source \u003c(kubectl completion bash) echo \"source \u003c(kubectl completion bash)\" \u003e\u003e ~/.bashrc source ~/.bashrc 查看所有pod kubectl get po -owide -A ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:1:7","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"部署kubernetes ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:0","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"1. 安装 kubeadm, kubelet 和 kubectl 操作节点： 所有的master和slave节点(master,k8s-slave) 需要执行 apt-get install kubelet=1.22.2-00 kubectl=1.22.2-00 kubeadm=1.22.2-00 ## 查看kubeadm 版本 kubeadm version ## 设置kubelet开机启动 systemctl enable kubelet ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:1","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"2. 初始化配置文件 操作节点： 只在master节点（master）执行 kubeadm config print init-defaults \u003e kubeadm.yaml apiVersion: kubeadm.k8s.io/v1beta3 bootstrapTokens: - groups: - system:bootstrappers:kubeadm:default-node-token token: abcdef.0123456789abcdef ttl: 24h0m0s usages: - signing - authentication kind: InitConfigurationx localAPIEndpoint: advertiseAddress: 10.4.7.60 #修改为master 的IP bindPort: 6443 nodeRegistration: criSocket: /var/run/dockershim.sock name: node # 删掉此行，删掉此行，删掉此行 imagePullPolicy: IfNotPresent taints: null --- apiServer: timeoutForControlPlane: 4m0s apiVersion: kubeadm.k8s.io/v1beta3 certificatesDir: /etc/kubernetes/pki clusterName: kubernetes controllerManager: {} dns: {} etcd: local: dataDir: /var/lib/etcd imageRepository: registry.aliyuncs.com/google_containers kind: ClusterConfiguration kubernetesVersion: 1.22.2 networking: dnsDomain: cluster.local podSubnet: 10.244.0.0/16 #添加此行 serviceSubnet: 10.96.0.0/12 scheduler: {} ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:2","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"3. 提前下载镜像 操作节点：只在master节点（master）执行 # 提前下载镜像到本地 kubeadm config images pull --config kubeadm.yaml [config/images] Pulled registry.aliyuncs.com/google_containers/kube-apiserver:v1.22.2 [config/images] Pulled registry.aliyuncs.com/google_containers/kube-controller-manager:v1.22.2 [config/images] Pulled registry.aliyuncs.com/google_containers/kube-scheduler:v1.22.2 [config/images] Pulled registry.aliyuncs.com/google_containers/kube-proxy:v1.22.2 [config/images] Pulled registry.aliyuncs.com/google_containers/pause:3.5 [config/images] Pulled registry.aliyuncs.com/google_containers/etcd:3.5.0-0 [config/images] Pulled registry.aliyuncs.com/google_containers/coredns:v1.8.4 ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:3","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"4. 初始化master节点 操作节点：只在master节点（k8s-master）执行 kubeadm init --config kubeadm.yaml 若初始化成功后，最后会提示如下信息： ... To start using your cluster, you need to run the following as a regular user: mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config Alternatively, if you are the root user, you can run: export KUBECONFIG=/etc/kubernetes/admin.conf You should now deploy a pod network to the cluster. Run \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at: https://kubernetes.io/docs/concepts/cluster-administration/addons/ Then you can join any number of worker nodes by running the following on each as root: kubeadm join 10.4.7.60:6443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:3a7987c9f5007ebac7980e6614281ee0e064c760c8db012471f9f662289cc9ce 接下来按照上述提示信息操作，配置kubectl客户端的认证 mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config **⚠️注意：**此时使用 kubectl get nodes查看节点应该处于notReady状态，因为还未配置网络插件 若执行初始化过程中出错，根据错误信息调整后，执行kubeadm reset后再次执行init操作即可 ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:4","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"5. 添加slave节点到集群中 操作节点：所有的slave节点（worker1`worker2`）需要执行 在每台slave节点，执行如下命令，该命令是在kubeadm init成功后提示信息中打印出来的，需要替换成实际init后打印出的命令。 kubeadm join 10.4.7.60:6443 --token abcdef.0123456789abcdef \\ --discovery-token-ca-cert-hash sha256:3a7987c9f5007ebac7980e6614281ee0e064c760c8db012471f9f662289cc9ce ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:5","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"6. 安装calico插件 操作节点：只在master节点（master）执行 方式一：直接安装（未使用！！！） 下载资源文件 wget https://docs.projectcalico.org/manifests/calico-etcd.yaml 修改配置 注释掉文件的前22行 1 --- 2 # Source: calico/templates/calico-etcd-secrets.yaml 3 # The following contains k8s Secrets for use with a TLS enabled etcd cluster. 4 # For information on populating Secrets, see http://kubernetes.io/docs/user-guide/secrets/ 5 #apiVersion: v1 6 #kind: Secret 7 #type: Opaque 8 #metadata: 9 # name: calico-etcd-secrets 10 # namespace: kube-system 11 #data: 12 # Populate the following with etcd TLS configuration if desired, but leave blank if 13 # not using TLS for etcd. 14 # The keys below should be uncommented and the values populated with the base64 15 # encoded contents of each file that would be associated with the TLS data. 16 # Example command for encoding a file contents: cat \u003cfile\u003e | base64 -w 0 17 # etcd-key: null 18 # etcd-cert: null 19 # etcd-ca: null 20 --- 21 # Source: calico/templates/calico-config.yaml 22 # This ConfigMap is used to configure a self-hosted Calico installation. 23 kind: ConfigMap 24 apiVersion: v1 25 metadata: 26 name: calico-config 27 namespace: kube-system ... 修改configmap 注意30-35行，其中etcd_endpoints换成环境的etcd地址 23 kind: ConfigMap 24 apiVersion: v1 25 metadata: 26 name: calico-config 27 namespace: kube-system 28 data: 29 # Configure this with the location of your etcd cluster. 30 etcd_endpoints: \"https://10.4.7.60:2379\" 31 # If you're using TLS enabled etcd uncomment the following. 32 # You must also populate the Secret below with these files. 33 etcd_ca: \"/calico-secrets/etcd-ca\" # \"/calico-secrets/etcd-ca\" 34 etcd_cert: \"/calico-secrets/etcd-cert\" # \"/calico-secrets/etcd-cert\" 35 etcd_key: \"/calico-secrets/etcd-key\" # \"/calico-secrets/etcd-key\" 36 # Typha is disabled. 37 typha_service_name: \"none\" 38 # Configure the backend to use. 39 calico_backend: \"bird\" 添加calico-node环境变量 注意297-302行为新添加 285 containers: 286 # Runs calico-node container on each Kubernetes node. This 287 # container programs network policy and routes on each 288 # host. 289 - name: calico-node 290 image: docker.io/calico/node:v3.20.0 291 envFrom: 292 - configMapRef: 293 # Allow KUBERNETES_SERVICE_HOST and KUBERNETES_SERVICE_PORT to be overridden for eBPF mode. 294 name: kubernetes-services-endpoint 295 optional: true 296 env: 297 - name: KUBERNETES_SERVICE_HOST 298 value: \"10.4.7.60\" 299 - name: KUBERNETES_SERVICE_PORT 300 value: \"6443\" 301 - name: KUBERNETES_SERVICE_PORT_HTTPS 302 value: \"6443\" 303 # The location of the etcd cluster. 304 - name: ETCD_ENDPOINTS 305 valueFrom: 306 configMapKeyRef: 307 name: calico-config 308 key: etcd_endpoints 309 # Location of the CA certificate for etcd. 310 - name: ETCD_CA_CERT_FILE 修改CIDR 注意371-372行，value值为k8s集群初始化的pod-network-cidr 370 # no effect. This should fall within `--cluster-cidr`. 371 - name: CALICO_IPV4POOL_CIDR 372 value: \"10.244.0.0/16\" 373 # Disable file logging so `kubectl logs` works. 374 - name: CALICO_DISABLE_FILE_LOGGING 375 value: \"true\" 创建secret kubectl -n kube-system create secret generic calico-etcd-secrets --from-file=etcd-ca=/etc/kubernetes/pki/etcd/ca.crt --from-file=etcd-cert=/etc/kubernetes/pki/etcd/healthcheck-client.crt --from-file=etcd-key=/etc/kubernetes/pki/etcd/healthcheck-client.key 创建calico资源清单 kubectl apply -f calico-etcd.yaml ​ 等待pod启动完成 kubectl -n kube-system get po NAME READY STATUS RESTARTS AGE calico-kube-controllers-59db5cf8fd-fpzdq 1/1 Running 1 32m calico-node-d2xq4 1/1 Running 1 32m calico-node-ppzjk calico插件包： docker.io/calico/cni:v3.20.2 docker.io/calico/pod2daemon-flexvol:v3.20.2 docker.io/calico/node:v3.20.2 方式二：使用operator安装(已成功！！！！！！) 安装operator kubectl create -f https://docs.projectcalico.org/manifests/tigera-operator.yaml 等待operator pod安装启动完成 kubectl -n tigera-operator get po NAME READY STATUS RESTARTS AGE tigera-operator-698876cbb5-kfpb2 1/1 Running 0 38m 镜像拉取比较慢，可以手动去节点docker pull拉取 编辑calico配置 vim custom-resources.yaml apiVersion: operator.tigera.io/v1 kind: Installation metadata: name: default","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:6","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"7. 验证集群 操作节点： 在master节点（k8s-master）执行 kubectl get nodes #观察集群节点是否全部Ready 创建测试nginx服务 kubectl run test-nginx --image=nginx:alpine 查看pod是否创建成功，并访问pod ip测试是否可用 kubectl get po -o wide NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES test-nginx-5bd8859b98-5nnnw 1/1 Running 0 9s 10.244.1.2 k8s-slave1 \u003cnone\u003e \u003cnone\u003e curl 10.244.1.2 ... \u003ch1\u003eWelcome to nginx!\u003c/h1\u003e \u003cp\u003eIf you see this page, the nginx web server is successfully installed and working. Further configuration is required.\u003c/p\u003e \u003cp\u003eFor online documentation and support please refer to \u003ca href=\"http://nginx.org/\"\u003enginx.org\u003c/a\u003e.\u003cbr/\u003e Commercial support is available at \u003ca href=\"http://nginx.com/\"\u003enginx.com\u003c/a\u003e.\u003c/p\u003e \u003cp\u003e\u003cem\u003eThank you for using nginx.\u003c/em\u003e\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:7","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["编程"],"content":"8. 清理环境 如果你的集群安装过程中遇到了其他问题，我们可以使用下面的命令来进行重置： # 在全部集群节点执行 kubeadm reset ifconfig cni0 down \u0026\u0026 ip link delete cni0 ifconfig flannel.1 down \u0026\u0026 ip link delete flannel.1 rm -rf /run/flannel/subnet.env rm -rf /var/lib/cni/ mv /etc/kubernetes/ /tmp mv /var/lib/etcd /tmp mv ~/.kube /tmp iptables -F iptables -t nat -F ipvsadm -C ip link del kube-ipvs0 ip link del dummy0 设置apt源报错。换源 apt-get update \u0026\u0026 apt-get install -y apt-transport-https ca-certificates software-properties-common curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | apt-key add - curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | apt-key add - add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\" add-apt-repository \"deb [arch=amd64] https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main\" apt-get update #若上步出现NO_PUBLICKEY问题，参考https://www.cnblogs.com/jiangzuo/p/13667011.html 未安装cni插件pod状态 coredns-7f6cbbb7b8-c778v pod 不能启动因为未安装cni插件。 events: Warning FailedScheduling 43s (x2 over 2m13s) default-scheduler 0/3 nodes are available: 3 node(s) had taint {node.kubernetes.io/not-ready: }, that the pod didn't tolerate. root@master:~# k get po -A -owide NAMESPACE NAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATES kube-system coredns-7f6cbbb7b8-c778v 0/1 Pending 0 3m54s \u003cnone\u003e \u003cnone\u003e \u003cnone\u003e \u003cnone\u003e kube-system coredns-7f6cbbb7b8-px7cm 0/1 Pending 0 3m54s \u003cnone\u003e \u003cnone\u003e \u003cnone\u003e \u003cnone\u003e kube-system etcd-master 1/1 Running 0 4m7s 10.4.7.70 master \u003cnone\u003e \u003cnone\u003e kube-system kube-apiserver-master 1/1 Running 0 4m7s 10.4.7.70 master \u003cnone\u003e \u003cnone\u003e kube-system kube-controller-manager-master 1/1 Running 0 4m7s 10.4.7.70 master \u003cnone\u003e \u003cnone\u003e kube-system kube-proxy-5w6c4 1/1 Running 0 3m23s 10.4.7.71 worker1 \u003cnone\u003e \u003cnone\u003e kube-system kube-proxy-6jnkr 1/1 Running 0 3m20s 10.4.7.72 worker2 \u003cnone\u003e \u003cnone\u003e kube-system kube-proxy-hcwtz 1/1 Running 0 3m54s 10.4.7.70 master \u003cnone\u003e \u003cnone\u003e kube-system kube-scheduler-master 1/1 Running 0 4m8s 10.4.7.70 master \u003cnone\u003e \u003cnone\u003e ","date":"2022-01-02","objectID":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/:2:8","tags":["k8s"],"title":"k8s集群搭建","uri":"/k8s%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"},{"categories":["工具"],"content":"一、Ubuntu20.10 server LTS安装 LTS（长期支持版） 支持以下处理器 amd64 (Intel/AMD 64-bit) arm64 (64-bit ARM) ppc64el (POWER8 and POWER9) s390x (IBM Z and LinuxONE) 最低配置 CPU: 1g或者更高 RAM: 1g或者更高 Disk: 不小于2.5G 桌面版和服务器版不同 Ubuntu服务器版和Ubuntu桌面版使用相同的Apt库。 一个主要区别是用于桌面版的图形环境没有为服务器安装。这包括图形服务器本身、图形实用程序和应用程序，以及桌面用户所需的各种用户支持服务。 镜像下载地址 https://releases.ubuntu.com/20.04/ 开机引导启动 ESC、F2、F10、或F12 快捷键 ESC go back F1 open help menu Control-Z, F2 switch to shell Control-L, F3 redraw screen Control-T, F4 toggle rich mode (colour, unicode) on and off 更换清华源 参考 1.备份源文件 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak 2.打开sources.list: sudo gedit /etc/apt/sources.list 加入清华源 deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal universe deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates universe deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security universe deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security multiverse 3.刷新软件源信息： sudo apt-get update 4.更新软件 sudo apt-get upgrade 5.如果更新报以下错误 Ign:1 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal InRelease Ign:2 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-updates InRelease Ign:3 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-backports InRelease Ign:4 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-security InRelease Err:5 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal Release Certificate verification failed: The certificate is NOT trusted. The certificate chain uses expired certificate. Could not handshake: Error in the certificate verification. [IP: 101.6.15.130 443] Err:6 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-updates Release Certificate verification failed: The certificate is NOT trusted. The certificate chain uses expired certificate. Could not handshake: Error in the certificate verification. [IP: 101.6.15.130 443] Err:7 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-backports Release Certificate verification failed: The certificate is NOT trusted. The certificate chain uses expired certificate. Could not handshake: Error in the certificate verification. [IP: 101.6.15.130 443] Err:8 https://mirrors.tuna.tsinghua.edu.cn/ubuntu focal-security Release Certificate verification failed: The certificate is NOT trusted. The certificate chain uses expired certificate. Could not handshake: Error in the certificate verification. [IP: 101.6.15.130 443] 将源中https改为http即可 ","date":"2022-01-02","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/:0:1","tags":["ubuntu"],"title":"ubuntu使用上篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/"},{"categories":["工具"],"content":"二、包管理 后缀名为.deb 安装软件包nmap sudo apt install nmap 卸载软件包nmap sudo apt remove nmap 卸载多个包用空格分隔。 更新包索引 APT 包索引本质上是/etc/apt/sources.list文件和/etc/apt/sources.list.d目录中定义的存储库中可用包的数据库。 sudo apt update aptitude-包管理工具 aptitude 在删除一个包时，会同时删除本身所依赖的包。这样，系统中不会残留无用的包，整个系统更为干净。 常用包管理命令 aptitude update 更新可用的包列表 aptitude upgrade 升级可用的包 aptitude dist-upgrade 将系统升级到新的发行版 aptitude install pkgname 安装包 aptitude remove pkgname 删除包 aptitude purge pkgname 删除包及其配置文件 aptitude search string 搜索包 aptitude show pkgname 显示包的详细信息 aptitude clean 删除下载的包文件 aptitude autoclean 仅删除过期的包文件 查看程序所需依赖包 root@liujie-desktop:~# apt-cache depends freeradius freeradius 依赖: lsb-base 依赖: libc6 依赖: libfreeradius2 依赖: libgdbm3 依赖: libltdl7 依赖: libpam0g 依赖: libperl5.10 依赖: libpython2.6 依赖: libssl0.9.8 依赖: zlib1g 依赖: freeradius-common 依赖: ssl-cert 依赖: adduser 建议: freeradius-ldap 建议: freeradius-postgresql 建议: freeradius-mysql 建议: freeradius-krb5 aptitude 安装nmap sudo aptitude install nmap aptitude 卸载nmap sudo aptitude remove nmap dpkg-包管理器 它可以安装、删除和构建包，但与其他包管理系统不同，它不能自动下载和安装包或其依赖项。Apt和Aptitude 是较新的，并且在 dpkg 之上添加了附加功能。 列出系统包数据库中的所有包，包括所有已安装和已卸载的包。 dpkg -l 通过 grep 管道输出以查看是否安装了特定的包： dpkg -l | grep apache2 要列出包安装的文件，在本例中为 ufw 包，请输入： dpkg -L ufw 如果你不确定安装了哪个包的文件，dpkg -S也许可以告诉你。例如： dpkg -S /etc/host.conf base-files: /etc/host.conf 输出显示/etc/host.conf属于 base-files 包。 您可以.deb通过输入以下内容来安装本地文件： sudo dpkg -i zip_3.0-4_amd64.deb 卸载软件包可以通过以下方式完成： sudo dpkg -r zip 注意：在大多数情况下，不推荐使用 dpkg 卸载软件包。最好使用处理依赖关系的包管理器，以确保系统处于一致状态。它不会卸载相关依赖包。 ","date":"2022-01-02","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/:0:2","tags":["ubuntu"],"title":"ubuntu使用上篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/"},{"categories":["工具"],"content":"三、无人值守批量安装Ubuntu server 20.04.3 使用PXE自动从网络加载安装程序，发起安装。 使用Ubuntu的自动安装功能，自动加载cloud-init安装配置，完成操作系统的自动选择。 需要装有pxe的服务端，服务器需要安装的软件有tftp客户端，dnsmasq 服务端，tftp服务端可以在dnsmasq.conf中配置。 apt install tftp apt install dnsmasq 需要安装系统的客户端（此时用虚拟机创建一个空的虚拟机。需要第一启动项为网卡启动，并且默认uefi启动） PXE 安装流程 ​ PXE（Pre-boot Execution Environment/预启动执行环境）的实现依赖于网卡，只有支持PXE Client的网卡才能实现网络自动安装。这种网卡实现DHCP Client和 TFTP Client，在BIOS的引导下通过DHCP协议自动分配IP地址，通过TFTP获取最小内核，然后在最小内核环境下通过HTTP协议或NFS协议获取Ubuntu安装版本。之后最小内核引导进行Ubuntu 20.04的安装。下图是详细的安装流程。 上图有几个前提： 网卡支持PXE，今年新出的网卡基本都支持，同时BIOS的启动项也要配置，请大家自行研究。 UEFI启动才会请求bootx64.efi，如果是传统启动模式（Legacy），那么PXE Client会请求pxelinux.0。 可以采用nfsboot方式，这个流程采用的是iso镜像下载再安装的方式。 以下引导方式为uefi，虚拟机客户端需要将bios模式改为uefi模式，同时，将开机启动项将从网卡启动设置为第一启动项。 安装必须的服务端软件 安装DHCP、TFTP服务器 dnsmasq同时实现了DHCP、TFTP、DNS三种服务器 sudo apt-get install dnsmasq 安装HTTP服务器 HTTP Server有很多，大家可以使用自己的熟悉的服务器如nginx，这里使用的是apache2 sudo apt-get install apache2 准备启动文件 下载uefi 引导文件，shim.signed、grub-efi-amd64-signed 安全启动链加载的引导程序 apt-get download shim.signed apt-get download grub-efi-amd64-signed 下载ubuntu 20.04 server iso 这个直接去官网下载，我下载的是ubuntu-20.04.3-live-server-amd64.iso，需要注意的是只有live版本才能支持subiquity https://ubuntu.com/download/server 创建TFTP 文件夹 TFTP 文件夹是TFTP服务的根目录，PXE启动过程中下载的文件都存在在该目录中 tftp ├── boot │ └── live-server │ ├── initrd │ └── vmlinuz ├── grub │ ├── bootx64.efi │ ├── font.pf2 │ └── grub.cfg └── grubx64.efi 说明 bootx64.efi、grubx64.efi 引导程序，来自shim.signed 安装包 grub.cfg 自建 其他文件来自 ubuntu安装包 五个文件是需要的，但是目录结构是我自建的，大家可以根据自己的喜好修改 创建目录 在 /tftp (可根据实际情况修改)目录下创建 tftp目录 mkdir /tftp mkdir /tftp/grub mkdir /tftp/boot mkdir /tftp/boot/live-server 获取引导文件 在安装包下载目录创建一个shim文件夹 解压shim安装包到shim文件夹 dpkg -x \u003c%刚才下载的shim.signed 安装包包名%\u003e shim 解压grub安装包到grub文件夹 拷贝引导文件到tftp目录 cp ./root/grub/usr/lib/grub/x86_64-efi-signed/grubnetx64.efi.signed /tftp/grubx64.efi cp ./root/shim/usr/lib/shim/shimx64.efi.signed /tftp/grub/bootx64.efi 获取内核镜像文件 在下载目录mount iso文件 sudo mount ubuntu-20.04.3-live-server-amd64.iso /media 系统会提示只读，不影响使用 mount: /media: WARNING: device write-protected, mounted read-only. 拷贝内核镜像文件 cp /media/casper/initrd /tftp/boot/live-server cp /media/casper/vmlinuz /tftp/boot/live-server 拷贝grub文件 grub.cfg拷贝过来做个参考，内容会被全部修改掉 cp /media/grub/font.pf2 /tftp/grub cp /media/grub/grub.cfg /tftp/grub 配置dnsmasq（默认端口53udp） tftp默认端口69 关键配置有以下几个 配置DHCP 地址段 配置引导文件目录 配置tftp 根目录 配置日志路径 配置服务网卡，多网卡机器需关注 # 配置外网DNS服务器地址 server=10.4.7.254 # 指定服务的网卡 interface=ens33,lo # 绑定端口 bind-interfaces # 设置DHCP分发IP端范围、地址掩码、IP地址有效时间 dhcp-range=10.4.7.240,10.4.7.241,255.255.255.0,12h # 指定网关地址 和安装无关，应该可以不配置 dhcp-option=3,10.4.7.254 # 指定DNS服务器地址 和安装无关，应该可以不配置 dhcp-option=6,10.4.7.254 # 设置引导程序相对tftp根目录的路径 dhcp-match=set:efi-x86_64,option:client-arch,7 dhcp-boot=tag:efi-x86_64,grub/bootx64.efi # 打开tftp服务 enable-tftp # 设置tftp根路径 tftp-root=/tftp # 设置日志路径 log-facility=/var/log/dnsmasq.log 修改配置后，重启dnsmasq服务才能生效。 创建HTTP文件夹 apache2的默认服务根目录是 /var/www/html，不修改他，在他下面创建目录 html/ ├── autoinstall │ ├── meta-data │ └── user-data ├── index.html └── iso └── ubuntu-20.04.2-live-server-amd64.iso 说明 autoinstall 目录存放参数自动配置文件，user-data、meta-data是cloud-init要求的文件名 iso 目录存放操作系统镜像文件 创建目录 mkdir /var/www/html/autoinstall mkdir /var/www/html/iso 拷贝iso文件 到下载目录拷贝iso文件 cp ubuntu-20.04.3-live-server-amd64.iso /var/www/html/iso 创建参数自动配置文件 先创建空文件，meta-data无需修改，user-data后续章节会详细描述配置 touch /var/www/html/autoinstall/user-data touch /var/www/html/autoinstall/meta-data 配置grub.cfg if loadfont /grub/font.pf2 ; then set gfxmode=auto insmod efi_gop insmod efi_uga insmod gfxterm terminal_output gfxterm fi set menu_color_normal=white/black set menu_color_highlight=black/light-gray set timeout=5 menuentry \"Ubuntu server 20.04.3 autoinstall\" { set gfxpayload=keep linux /boot/live-server/vmlinuz root=/dev/ram0 ramdisk_size=1500000 ip=dhcp url='http://10.4.7.150/iso/ubuntu-20.04.3-live-server-amd64.iso' autoinstall ds=nocloud-net\\;s=http://10.4.7.150/autoinstall/ --- initrd /boot/live-server/initrd } menuentry 之前是配置样式，也可以删除，重点关注menuentry \"Ubuntu server 20.04 autoinstall\" 内的配置。 指定镜像文件相对于tftp根目录的路径 /boot/live-server/initrd ","date":"2022-01-02","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/:0:3","tags":["ubuntu"],"title":"ubuntu使用上篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/"},{"categories":["工具"],"content":"四、Ubuntu 网络配置 要快速识别所有可用的以太网接口，您可以使用如下所示的 ip 命令。 root@lhp-server:/etc/netplan# ip a 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: ens33: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:0c:29:da:c6:09 brd ff:ff:ff:ff:ff:ff inet 10.4.7.142/24 brd 10.4.7.255 scope global ens33 valid_lft forever preferred_lft forever inet6 fe80::20c:29ff:feda:c609/64 scope link valid_lft forever preferred_lft forever 另一个可以帮助识别系统可用的所有网络接口的应用程序是 lshw 命令。此命令提供有关特定适配器的硬件功能的更多详细信息。在下面的示例中，lshw 显示了一个具有eth1逻辑名称的以太网接口以及总线信息、驱动程序详细信息和所有支持的功能。 root@lhp-server:/etc/netplan# lshw -class network *-network description: Ethernet interface product: 82545EM Gigabit Ethernet Controller (Copper) vendor: Intel Corporation physical id: 1 bus info: pci@0000:02:01.0 logical name: ens33 version: 01 serial: 00:0c:29:da:c6:09 size: 1Gbit/s capacity: 1Gbit/s width: 64 bits clock: 66MHz capabilities: pm pcix bus_master cap_list rom ethernet physical logical tp 10bt 10bt-fd 100bt 100bt-fd 1000bt-fd autonegotiation configuration: autonegotiation=on broadcast=yes driver=e1000 driverversion=7.3.21-k8-NAPI duplex=full ip=10.4.7.142 latency=0 link=yes mingnt=255 multicast=yes port=twisted pair speed=1Gbit/s resources: irq:19 memory:fd5c0000-fd5dffff memory:fdff0000-fdffffff ioport:2000(size=64) memory:fd500000-fd50ffff ethtool 是一个程序，用于显示和更改以太网卡设置，例如自动协商、端口速度、双工模式和 LAN 唤醒。以下是如何查看以太网接口支持的功能和配置设置的示例。 root@lhp-server:/etc/netplan# ethtool ens33 Settings for ens33: Supported ports: [ TP ] Supported link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Full Supported pause frame use: No Supports auto-negotiation: Yes Supported FEC modes: Not reported Advertised link modes: 10baseT/Half 10baseT/Full 100baseT/Half 100baseT/Full 1000baseT/Full Advertised pause frame use: No Advertised auto-negotiation: Yes Advertised FEC modes: Not reported Speed: 1000Mb/s Duplex: Full Port: Twisted Pair PHYAD: 0 Transceiver: internal Auto-negotiation: on MDI-X: off (auto) Supports Wake-on: d Wake-on: d Current message level: 0x00000007 (7) drv probe link Link detected: yes 要临时配置 IP 地址，可以通过以下方式使用 ip 命令。修改 IP 地址和子网掩码以符合您的网络要求。ip 命令允许您配置立即生效的设置，但是它们不是持久的并且会在重新启动后丢失。 sudo ip addr add 10.102.66.200/24 dev ens33 然后可以使用 ip 来设置链接的开启或关闭。 ip link set dev ens33 up ip link set dev ens33 down 验证enp0s25的IP地址配置，可以通过以下方式使用ip命令。 ip address show dev enp0s25 10: enp0s25: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default qlen 1000 link/ether 00:16:3e:e2:52:42 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 10.102.66.200/24 brd 10.102.66.255 scope global dynamic eth0 valid_lft 2857sec preferred_lft 2857sec inet6 fe80::216:3eff:fee2:5242/64 scope link valid_lft forever preferred_lft forever6 要配置默认网关，您可以按以下方式使用 ip 命令。修改默认网关地址以符合您的网络要求。 sudo ip route add default via 10.102.66.1 要验证您的默认网关配置，您可以按以下方式使用 ip 命令。 ip route show default via 10.102.66.1 dev eth0 proto dhcp src 10.102.66.200 metric 100 10.102.66.0/24 dev eth0 proto kernel scope link src 10.102.66.200 10.102.66.1 dev eth0 proto dhcp scope link src 10.102.66.200 metric 100 如果您的临时网络配置需要 DNS，您可以在文件中添加 DNS 服务器 IP 地址/etc/resolv.conf。一般情况下，/etc/resolv.conf不建议直接编辑，但这是一种临时且非持久的配置。下面的示例显示了如何将两个 DNS 服务器输入到 中/etc/resolv.conf，应将其更改为适合您网络的服务器。以下部分详细介绍了进行 DNS 客户端配置的正确持久方式。 nameserver 8.8.8.8 nameserver 8.8.4.4 如果您不再需要此配置并希望从接口中清除所有 IP 配置，您可以使用带有flush 选项的ip 命令，如下所示。 ip addr flush eth0 笔记 使用 ip 命令刷新 IP 配置不会清除/etc/resolv.conf. 您必须手动删除或修改这些条目，或者重新启动，这也应该导致/etc/resolv.conf，它是到 的符号链接/run/systemd/resolve/stub-resolv.conf，被重写。 动态 IP 地址分配（DHCP 客户端） 要将您的服务器配置为使用 DHCP 进行动态地址分配，请在文件/etc/netplan/99_config.yaml. 下面的示例假设您正在配置标识为enp3s0 的第一个以太网接口。 network: version: 2 renderer: networkd ethernets: enp3s0: dhcp4: true 然后可以使用 netplan 命令应用配置。 sudo netplan apply 静态 IP 地址分配 ","date":"2022-01-02","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/:0:4","tags":["ubuntu"],"title":"ubuntu使用上篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/"},{"categories":["工具"],"content":"五、安全 用户管理 root用户默认禁止访问。 鼓励用户使用名为“sudo”的工具来执行系统管理职责。Sudo 允许授权用户使用他们自己的密码临时提升他们的权限，而不必知道属于 root 帐户的密码。这种简单而有效的方法为所有用户操作提供了问责制，并使管理员可以精细控制用户可以使用所述权限执行哪些操作。 启用root用户并设置新密码： sudo passwd Sudo 将提示您输入密码，然后要求您为 root 提供一个新密码，如下所示： [sudo] password for username: (enter your own password) Enter new UNIX password: (enter a new password for root) Retype new UNIX password: (repeat new password for root) passwd: password updated successfully 禁用 root 帐户密码 sudo passwd -l root 更多sudo man sudo 添加和删除用户 sudo adduser username 删除用户帐户及其主要组，请使用以下语法： sudo deluser username 删除帐户不会删除其各自的主文件夹。您是否希望手动删除文件夹或根据所需的保留策略保留它取决于您。 请记住，如果您没有采取必要的预防措施，任何后来添加的与前一个所有者具有相同 UID/GID 的用户现在都可以访问此文件夹。 您可能希望将这些 UID/GID 值更改为更合适的值，例如 root 帐户，甚至可能重新定位文件夹以避免将来发生冲突： sudo chown -R root:root /home/username/ sudo mkdir /home/archived_users/ sudo mv /home/username /home/archived_users/ 要临时锁定或解锁用户密码，请分别使用以下语法： sudo passwd -l username sudo passwd -u username 要添加或删除个性化组，请分别使用以下语法： sudo addgroup groupname sudo delgroup groupname 要将用户添加到组，请使用以下语法： sudo adduser username groupname 用户配置文件安全 创建新用户时， adduser 实用程序会创建一个名为 的全新主目录/home/username。默认配置文件以 目录中的内容为模型/etc/skel，其中包括所有配置文件基础。 如果您的服务器将有多个用户使用，则应密切注意用户主目录的权限以确保机密性。默认情况下，Ubuntu 中的用户主目录是使用全局读取/执行权限创建的。这意味着所有用户都可以浏览和访问其他用户主目录的内容。这可能不适合您的环境。 要验证您当前的用户主目录权限，请使用以下语法： ls -ld /home/username 以下输出显示该目录/home/username具有全球可读的权限： drwxr-xr-x 2 username username 4096 2007-10-02 20:03 username 您可以使用以下语法删除世界可读权限： sudo chmod 0750 /home/username 笔记 有些人倾向于不加选择地使用递归选项 (-R) 来修改所有子文件夹和文件，但这不是必需的，并且可能会产生其他不良结果。仅父目录就足以防止未经授权访问父目录下的任何内容。 一个更有效的方法是在创建用户主文件夹时修改 adduser 全局默认权限。只需编辑文件/etc/adduser.conf并将DIR_MODE变量修改为适当的内容，以便所有新的主目录都将获得正确的权限。 DIR_MODE=0750 使用前面提到的任何技术更正目录权限后，使用以下语法验证结果： ls -ld /home/username 下面的结果表明，世界可读的权限已被删除： drwxr-x--- 2 username username 4096 2007-10-02 20:03 username 密码策略 最小长度密码 默认情况下，Ubuntu 需要最少 6 个字符的密码长度，以及一些基本的熵检查。这些值在文件 中控制，/etc/pam.d/common-password概述如下。 password [success=1 default=ignore] pam_unix.so obscure sha512 如果要将最小长度调整为 8 个字符，请将适当的变量更改为 min=8。修改概述如下。 password [success=1 default=ignore] pam_unix.so obscure sha512 minlen=8 笔记 基本密码熵检查和最小长度规则不适用于使用 sudo 级别命令设置新用户的管理员。 密码过期 创建用户帐户时，您应该制定一项策略，设置最短和最长密码期限，迫使用户在密码到期时更改密码。 要轻松查看用户帐户的当前状态，请使用以下语法： sudo chage -l username 下面的输出显示了有关用户帐户的有趣事实，即没有应用任何策略： Last password change : Jan 20, 2015 Password expires : never Password inactive : never Account expires : never Minimum number of days between password change : 0 Maximum number of days between password change : 99999 Number of days of warning before password expires : 7 要设置这些值中的任何一个，只需使用以下语法，并按照交互式提示进行操作： sudo chage username 下面也是一个示例，说明如何手动将显式到期日期 (-E) 更改为 01/31/2015、最短密码期限 (-m) 为 5 天、最长密码期限 (-M) 为 90 天、不活动密码到期后 30 天的时间段 (-I)，以及密码到期前 14 天的警告时间段 (-W)： sudo chage -E 01/31/2015 -m 5 -M 90 -I 30 -W 14 username 要验证更改，请使用与前面提到的相同的语法： sudo chage -l username 下面的输出显示了为账户建立的新策略： Last password change : Jan 20, 2015 Password expires : Apr 19, 2015 Password inactive : May 19, 2015 Account expires : Jan 31, 2015 Minimum number of days between password change : 5 Maximum number of days between password change : 90 Number of days of warning before password expires : 14 对于被禁用的用户ssh的访问 如果用户之前已经设置了 SSH 公钥身份验证，则简单地禁用/锁定用户密码不会阻止用户远程登录您的服务器。他们仍然能够获得对服务器的 shell 访问，而无需任何密码。请记住检查用户主目录中是否有允许此类经过身份验证的 SSH 访问的文件，例如/home/username/.ssh/authorized_keys. 删除或重命名.ssh/用户主文件夹中的目录，以防止进一步的 SSH 身份验证功能。 请务必检查禁用用户建立的任何 SSH 连接，因为他们可能已经存在入站或出站连接。杀死任何找到的人。 who | grep username (to get the pts/# terminal) sudo pkill -f pts/# 将 SSH 访问限制为只有应该拥有它的用户帐户。例如，您可以创建一个名为“sshlogin”的组，并将组名添加为与AllowGroups文件中的变量关联的值/etc/ssh/sshd_config。 AllowGroups sshlogin 然后将您允许的 SSH 用户添加到“sshlogin”组中，并重新启动 SSH 服务。 sudo adduser username sshlogin sudo systemctl restart sshd.service 查看登录日志 tail -f /var/log/auth.log Sep 23 07:32:58 lhp-server sshd[5801]: User test from 10.4.7.1 not allowed because none of user's groups are listed in AllowGroups Sep 23 07:33:01 lhp-server sshd[5801]: pam_unix(sshd:auth): authentication failure; logname= uid=0 euid=0 tty=ssh ruser= rhost=10.4.7.1 user=test Sep 23 07:33:03 lhp-server sshd[5801]: Fa","date":"2022-01-02","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/:0:5","tags":["ubuntu"],"title":"ubuntu使用上篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/"},{"categories":["工具"],"content":"六、防火墙 ufw Ubuntu 的默认防火墙配置工具是 ufw。为简化 iptables 防火墙配置而开发，ufw 提供了一种用户友好的方式来创建基于 IPv4 或 IPv6 的基于主机的防火墙。 启用 sudo ufw enable 添加端口（本例中为 SSH） sudo ufw allow 22 使用编号格式添加 sudo ufw insert 1 allow 80 关闭要打开的端口 sudo ufw deny 22 要删除规则，请使用 delete 后跟规则 sudo ufw delete deny 22 还可以允许从特定主机或网络访问某个端口。以下示例允许从主机 192.168.0.2 SSH 访问此主机上的任何 IP 地址： sudo ufw allow proto tcp from 192.168.0.2 to any port 22 将 192.168.0.2 替换为 192.168.0.0/24 以允许从整个子网进行 SSH 访问。 向ufw命令添加*–dry-run*选项将输出结果规则，但不会应用它们。例如，如果打开 HTTP 端口，将应用以下内容： sudo ufw --dry-run allow http *filter :ufw-user-input - [0:0] :ufw-user-output - [0:0] :ufw-user-forward - [0:0] :ufw-user-limit - [0:0] :ufw-user-limit-accept - [0:0] ### RULES ### ### tuple ### allow tcp 80 0.0.0.0/0 any 0.0.0.0/0 -A ufw-user-input -p tcp --dport 80 -j ACCEPT ### END RULES ### -A ufw-user-input -j RETURN -A ufw-user-output -j RETURN -A ufw-user-forward -j RETURN -A ufw-user-limit -m limit --limit 3/minute -j LOG --log-prefix \"[UFW LIMIT]: \" -A ufw-user-limit -j REJECT -A ufw-user-limit-accept -j ACCEPT COMMIT Rules updated 可以通过以下方式禁用 ufw： sudo ufw disable 要查看防火墙状态，请输入： sudo ufw status 对于更详细的状态信息，请使用： sudo ufw status verbose 查看编号格式： sudo ufw status numbered 笔记 如果要打开或关闭/etc/services的端口在 中定义，则可以使用端口名称而不是编号。在上面的示例中，将22替换为ssh。 更多详细参数见：man ufw手册 ufw 应用集成 打开端口的应用程序可以包含一个 ufw 配置文件，其中详细说明了应用程序正常运行所需的端口。配置文件保存在 中/etc/ufw/applications.d，如果默认端口已更改，则可以对其进行编辑。 要查看哪些应用程序安装了配置文件，请在终端中输入以下内容： sudo ufw app list 类似于允许流量到端口，使用应用程序配置文件是通过输入： sudo ufw allow Samba 扩展语法也可用： ufw allow from 192.168.0.0/24 to any app Samba 将Samba和192.168.0.0/24替换为您正在使用的应用程序配置文件以及您网络的 IP 范围。 笔记 无需为应用程序指定协议，因为该信息在配置文件中有详细说明。另请注意，应用程序名称替换了端口号。 要查看有关为应用程序定义的端口、协议等的详细信息，请输入： sudo ufw app info Samba IP伪装 IP 伪装的目的是允许网络上具有私有、不可路由 IP 地址的机器通过执行伪装的机器访问 Internet。必须对来自您的专用网络的发往 Internet 的流量进行处理，以便回复可路由回发出请求的机器。为此，内核必须修改每个数据包的源IP 地址，以便将回复路由回它，而不是发送到发出请求的私有 IP 地址，这在 Internet 上是不可能的。Linux 使用连接跟踪(conntrack) 跟踪哪些连接属于哪些机器并相应地重新路由每个返回数据包。因此，离开您的专用网络的流量被“伪装”为源自您的 Ubuntu 网关机器。此过程在 Microsoft 文档中称为 Internet 连接共享。 ufw 伪装 可以使用自定义 ufw 规则来实现 IP 伪装。这是可能的，因为 ufw 的当前后端是 iptables-restore，规则文件位于/etc/ufw/*.rules. 这些文件是添加不使用 ufw 使用的遗留 iptables 规则的好地方，以及与网关或网桥相关的规则。 规则分为两个不同的文件，应该在ufw命令行规则之前执行的规则，以及在ufw命令行规则之后执行的规则。 首先需要在ufw中开启数据包转发。需要调整两个配置文件，将DEFAULT_FORWARD_POLICY/etc/default/ufw更改为“ACCEPT”： DEFAULT_FORWARD_POLICY=\"ACCEPT\" 然后编辑/etc/ufw/sysctl.conf并取消注释： net/ipv4/ip_forward=1 同样，对于 IPv6 转发取消注释： net/ipv6/conf/default/forwarding=1 现在将规则添加到/etc/ufw/before.rules文件中。默认规则只配置过滤表，并且启用伪装nat表需要配置。将以下内容添加到文件顶部的标题注释之后： # nat Table rules *nat :POSTROUTING ACCEPT [0:0] # Forward traffic from eth1 through eth0. -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE # don't delete the 'COMMIT' line or these nat table rules won't be processed COMMIT 注释不是绝对必要的，但记录您的配置被认为是一种很好的做法。此外，在修改 中的任何规则文件时/etc/ufw，请确保这些行是每个修改表的最后一行： # don't delete the 'COMMIT' line or these rules won't be processed COMMIT 对于每个表，都需要一个相应的COMMIT语句。在这些示例中，只显示了nat和filter表，但您也可以为raw和mangle表添加规则。 笔记 在上面的示例中，将eth0、eth1和192.168.0.0/24替换为适合您网络的接口和 IP 范围。 最后，禁用并重新启用 ufw 以应用更改： sudo ufw disable \u0026\u0026 sudo ufw enable 现在应该启用 IP 伪装。您还可以将任何其他 FORWARD 规则添加到/etc/ufw/before.rules. 建议将这些附加规则添加到ufw-before-forward链中。 iptables 伪装 iptables 也可用于启用伪装。 与 ufw 类似，第一步是通过编辑/etc/sysctl.conf并取消注释以下行来启用 IPv4 数据包转发： net.ipv4.ip_forward=1 如果您希望启用 IPv6 转发也取消注释： net.ipv6.conf.default.forwarding=1 接下来，执行 sysctl 命令以启用配置文件中的新设置： sudo sysctl -p 现在可以使用单个 iptables 规则完成 IP 伪装，根据您的网络配置，该规则可能略有不同： sudo iptables -t nat -A POSTROUTING -s 192.168.0.0/16 -o ppp0 -j MASQUERADE 上述命令假设您的私有地址空间是 192.168.0.0/16，并且您的面向 Internet 的设备是 ppp0。语法分解如下： -t nat – 规则是进入 nat 表 -A POSTROUTING – 规则将被附加 (-A) 到 POSTROUTING 链 -s 192.168.0.0/16 – 该规则适用于源自指定地址空间的流量 -o ppp0 – 该规则适用于计划通过指定网络设备路由的流量 -j MASQUERADE - 与此规则匹配的流量将“跳转”（-j）到要操作的 MASQUERADE 目标，如上所述 此外，过滤器表中的每个链（默认表，以及大多数或所有数据包过滤发生的地方）都有一个默认策略ACCEPT，但如果除了网关设备之外，您还创建了防火墙，您可能已将策略设置为DROP 或 REJECT，在这种情况下，您的伪装流量需要通过 FORWARD 链允许才能使上述规则起作用： sudo iptables -A FORWARD -s 192.168.0.0/16 -o ppp0 -j ACCEPT sudo iptables -A FORWARD -d 192.168.0.0/16 -m state \\ --state ESTABLISHED,R","date":"2022-01-02","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/:0:6","tags":["ubuntu"],"title":"ubuntu使用上篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/"},{"categories":["工具"],"content":"七、日志 防火墙日志对于识别攻击、排除防火墙规则故障以及注意网络上的异常活动至关重要。但是，您必须在防火墙中包含日志规则才能生成它们，并且日志规则必须出现在任何适用的终止规则（具有决定数据包命运的目标的规则，例如 ACCEPT、DROP 或 REJECT）之前。 如果您使用的是 ufw，则可以通过在终端中输入以下内容来打开日志记录： sudo ufw logging on 要在 ufw 中关闭注销，只需在上述命令中将on替换为off。 如果使用 iptables 而不是 ufw，请输入： sudo iptables -A INPUT -m state --state NEW -p tcp --dport 80 \\ -j LOG --log-prefix \"NEW_HTTP_CONN: \" 然后，来自本地计算机的端口 80 上的请求将在 dmesg 中生成如下所示的日志（将单行拆分为 3 行以适合此文档）： [4304885.870000] NEW_HTTP_CONN: IN=lo OUT= MAC=00:00:00:00:00:00:00:00:00:00:00:00:08:00 SRC=127.0.0.1 DST=127.0.0.1 LEN=60 TOS=0x00 PREC=0x00 TTL=64 ID=58288 DF PROTO=TCP SPT=53981 DPT=80 WINDOW=32767 RES=0x00 SYN URGP=0 上面的日志也会出现在/var/log/messages、/var/log/syslog、 和 中/var/log/kern.log。可以通过/etc/syslog.conf适当编辑或安装和配置 ulogd 并使用 ULOG 目标而不是 LOG来修改此行为。ulogd 守护进程是一个用户空间服务器，它专门为防火墙侦听来自内核的日志记录指令，并且可以记录到您喜欢的任何文件，甚至是 PostgreSQL 或 MySQL 数据库。使用日志分析工具（例如 logwatch、fwanalog、fwlogwatch 或 lire）可以简化理解防火墙日志的过程。 ","date":"2022-01-02","objectID":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/:0:7","tags":["ubuntu"],"title":"ubuntu使用上篇","uri":"/ubuntu%E4%BD%BF%E7%94%A8%E4%B8%8A%E7%AF%87/"},{"categories":["工具"],"content":"SSH服务 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:1:0","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"SSH服务协议说明 SSH 是 Secure Shell Protocol 的简写，由 IETF 网络工作小组（Network Working Group )制定；在进行数据传输之前，SSH先对联机数据包通过加密技术进行加密处理，加密后在进行数据传输。确保了传递的数据安全。 SSH是专为远程登录会话和其他网络服务提供的安全性协议。利用 SSH 协议可以有效的防止远程管理过程中的信息泄露问题，在当前的生产环境运维工作中，绝大多数企业普遍采用SSH协议服务来代替传统的不安全的远程联机服务软件，如telnet(23端口，非加密的)等。 在默认状态下，SSH服务主要提供两个服务功能： 一是提供类似telnet远程联机服务器的服务，即上面提到的SSH服务。 另一个是类似FTP服务的sftp-server,借助SSH协议来传输数据的.提供更安全的SFTP服务(vsftp，proftp)。 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:1:1","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"SSH加密技术说明 当前，网络上的数据包加密技术一般是通过所谓的一对公钥与私钥（PublickeyandPivatekey)组合成的密钥对进行加密与解密操作。如下图，A-Server要给B_Client传数据，首先会通过本地的公钥加密后再到发到网络上传输。而加密的数据到达B_Client端后，再经由B_Client本地的私钥将加密的数据解密出来。ssh认证连接的过程如下 ssh实现安全链接建立，利用钥匙和锁头 钥匙=私钥 锁头=公钥，私钥可以解密公钥。 公钥可以再网络中传输，私钥再本地主机保存。 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:1:2","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"ssh加密算法 v1 漏洞密钥不更换。 v2 定期更换密钥。 利用Diffie-Hellman机制定期更新密钥。 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:1:3","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"ssh知识要点 ssh是安全的加密协议，用于远程链接linux服务器 ssh 默认端口是22，安全协议版本sshv2，出来2之外还有1（有漏洞） ssh服务端主要包括两个服务功能 ssh远程链接和sftp服务 linux ssh 客户端包括ssh 远程链接命令，以及远程拷贝scp命令等。 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:1:4","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"SSH服务软件详细说明 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:2:0","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"什么是ssh服务 SSH服务端是一个守护讲程 (daemon).它在后台运行并响应来自客户端的连接请求。 SSH服务端的进程名为sshd，负责实时监听远程SSH客户端的远程连接请求，并进行处理，一般包括公共密钥认证、密钥交换、对称密钥加密和非安全连接等。这个SSH服务就是我们前面基础系统优化中保留开机自启动的服务之。 ssh客户端包含ssh以及像scp(远程拷贝） slogin(远程登陆) sftp(安全FTP文件传输）等应用程序。 ssh的工作机制大致是本地的ssh客户端先发送一个连接请求到远程的ssh服务端，服务端检查连接的客户端发送的数据包和IP地址，如果确认合法，就会发送密钥给 SSH的客户端，此时，客户端本地再将密钥发回给服务端，自此连接建立。 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:2:1","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"ssh软件安装 客户端 rpm -qf 'which ssh' openssh-clients-5.3p1-122.el6.x86_64 服务端软件 rpm -qf 'which sshd' openssh-server-5.3p1-122.el6.x86_64 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:2:2","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"openssh-clinets 软件的主要内容 rpm -ql openssh-clients /etc/ssh/ssh_config ---ssh客户端配置文件 /usr/bin/.ssh.hmac /usr/bin/scp ---远程复制命令 /usr/bin/sftp ---远程文件传输服务 /usr/bin/slogin ---远程登陆命令 /usr/bin/ssh ---ssh远程登陆管理主机 /usr/bin/ssh-add /usr/bin/ssh-agent /usr/bin/ssh-copy-id ---ssh服务分发公钥命令 /usr/bin/ssh-keyscan ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:2:3","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"openssh-server 软件的主要内容 rpm -ql openssh-server /etc/rc.d/init.d/sshd #ssh服务启动脚本 /etc/ssh/sshd_config #ssh服务配置文件 /etc/sysconfig/sshd #ssh创建密钥有关 /usr/sbin/.sshd.hmac #ssh加密算法有关文件 /usr/sbin/sshd #ssh服务进程启动命令 **注意：**要使用sshd采用绝对路径进行启动 sshd sshd re-exec requires execution with an absolute path ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:2:4","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"ssh服务配置文件说明 配置文件中所有注释信息，表示默认参数配置 配置文件中#空格 后面内容表示说明信息 ​ #参数 表示配置参数信息 配置文件参数信息修改后，一旦变为注释，即还原为默认配置 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:3:0","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"ssh服务的配置文件路径 vim /etc/ssh/sshd_config 修改SSH服务的运行参数，是通过修改配置文件**/etc/ssh/sshd_config**实现的。 一般来说SSH服务使用默认的配置已经能够很好的工作了，如果对安全要求不高，仅仅提供SSH服务的情况，可以不需要修改任何配置。 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:3:1","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"配置文件中常用配置说明 vim /etc/ssh/sshd_config # $OpenBSD: sshd_config,v 1.80 2008/07/02 02:24:18 djm Exp $ # This is the sshd server system-wide configuration file. See # sshd_config(5) for more information. # This sshd was compiled with PATH=/usr/local/bin:/bin:/usr/bin # The strategy used for options in the default sshd_config shipped with # OpenSSH is to specify options with their default value where # possible, but leave them commented. Uncommented options change a # default value. # OpenSSH is to specify options with their default value where # possible, but leave them commented. Uncommented options change a # default value. Port 25113 #端口 ListenAddress 10.0.0.41 #监听地址（本地网卡地址），指定本地网卡那个网卡提供服务 PermitRootLogin no #是否允许root用户登陆 #PermitEmptyPasswords no #禁止空密码登陆 #UseDNS no #不使用DNS GSSAPIAuthentication no #API认证 # 连接慢的解决 #AddressFamily any #指定监听ipv4地址，或是ipv6地址，或者所有都监听 配置文件内容说明 井号(#)注释的参数信息为默认配置 井号(#)后面有空格的为描述信息 井号(#)后面没有空格的为参数信息 **另外：**配置文件参数信息修改后，一旦变为注释，即还原为默认配置. 语法格式有错误 ↓ sshd -t /etc/ssh/sshd_config /etc/ssh/sshd_config: line 50: Bad configuration option: uthorizedKeysFile /etc/ssh/sshd_config: terminating, 1 bad configuration options ssh服务监听参数说明 如图所示，sshd_config配置文件中实际监听本地的网卡，并非网络地址 监听地址只能监听本地网卡上配置的地址，监听的网卡可以对请求做出相应，为未监听的网卡不响应请求。 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:3:2","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"ssh连接慢解决方法 vi /etc/ssh/sshd_config 修改几个参数。 UseDNS noGSSAPIAuthentication no ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:4:0","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"ssh 密钥认证方式 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:5:0","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"ubuntu server 20.04 自动登录。 效果1： 效果2： 效果1实现： ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:6:0","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"首先指定自动登录用户 sudo vim /etc/systemd/system/getty.target.wants/getty@tty1.service ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:6:1","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"再设置免密码登录 sudo vim /etc/passwd 将 root❌0:0:root:/root:/bin/bash 中的x去掉，即：root::0:0:root:/root:/bin/bash，如果要指定别的用户可以找到相对应的行，用户名位于第一行。 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:6:2","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["工具"],"content":"允许ssh远程登录 sudo vim /etc/ssh/sshd_config，找到PermitRootLogin without-password 修改为PermitRootLogin yes systemctl restart sshd systemctl restart ssh 效果2： 每台机器设置hosts vi /etc/hosts 10.4.7.70 master 10.4.7.71 worker1 10.4.7.72 worker2 控制端master 上生成公钥和私钥。三次回车。 cd ~/.ssh ssh-keygen -t rsa ls authorized_keys id_rsa id_rsa.pub known_hosts 将公钥传给被控端/root/.ssh内 公钥：id_rsa.pub 私钥：id_rsa 将生成的公钥内容写入到authorized_keys（控制端和被控端端都操作） cat id_rsa.pub \u003e\u003e authorized_keys 都重启ssh systemctl restart sshdsystemctl restart ssh 测试： 在控制端连被控端看需不需要密码 ssh worker1 ","date":"2022-01-02","objectID":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/:6:3","tags":["ssh"],"title":"ssh相关说明","uri":"/ssh%E7%9B%B8%E5%85%B3%E8%AF%B4%E6%98%8E/"},{"categories":["网站"],"content":"技术选型 使用Hexo+keep+Github Actions+jsdelivr这一套技术实现blog搭建及自动化部署 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:1:0","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"开始搭建 安装node 下载地址：node下载 .安装LTS版本。 安装 Hexo npm install hexo-cli -g 我们强烈建议永远安装最新版本的 Hexo，以及 推荐的 Node.js 版本 。 Hexo 版本 最低兼容 Node.js 版本 5.0+ 10.13.0 4.1 - 4.2 8.10 4.0 8.6 3.3 - 3.9 6.9 3.2 - 3.3 0.12 3.0 - 3.1 0.10 or iojs 0.0.1 - 2.8 0.10 初始化博客目录 hexo init Smithkenny.github.io # 这里的Smithkenny换成你自己的英文名 初始化完成后，我们就进入我们的目录 cd Smithkenny.github.io 安装 npm install clean一下，然后生成静态页面 hexo clean hexo g 把你的网站运行起来 hexo s 打开你的浏览器，输入 localhost:4000 。 自此，你的个人网站就这么速度的搭建起来了！ ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:1:1","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"主题选择 初始化博客后，指定文件夹的目录如下： . ├── _config.yml ├── package.json ├── scaffolds ├── source | ├── _drafts | └── _posts └── themes _config.yml 网站的 配置 信息，您可以在此配置大部分的参数。 我的配置如下： # Site title: Peng's Blog subtitle: Peng 的个人博客 description: '' keywords: author: Haipeng language: zh-CN timezone: Asia/Shanghai # URL ## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project' url: https://www.haipengv.com package.json 应用程序的信息。EJS , Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 scaffolds 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes 主题 文件夹。Hexo 会根据主题来生成静态页面。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:2:0","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"选择一个主题 这里可以选择你要的主题 ，我选择的是、keep主题，因为它很简洁。 下载主题 keep主题github地址：https://github.com/XPoet/hexo-theme-keep keep 主题官方文档：https://keep-docs.xpoet.cn/ # 这里使用npm方式安装方便后期进行代码托管维护 npm install hexo-theme-keep 配置主题 主题下载完之后，在你根目录下的 _config.yml 文件中，修改 theme 为你的主题名字 theme: keep 我这里选择自定义hexo-theme-keep主题，可以参考keep主题平滑升级 在博客根目录下的 source目录中新建文件夹_data 将node_modules下的hexo-theme-keep目录中复制出_config.yml文件到source/_data/中，并重命名为keep.yml。 在keep.yml可根据文档配置对应的属性。 重新生成和运行 hexo clean hexo g hexo s keep主题 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:2:1","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"博客文章创建 有两种方式来新建你的博文 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:3:0","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"命令形式 在你的blog目录下使用如下命令： hexo new hello # 这里的article写上你的文章的名称 你的source/_posts下就会生成一个 hello.md文件，在这个文件下就可以写上你的博客内容了。用 Markdown 的语法去写。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:3:1","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"直接新建方式 直接点的方式就是直接在source/_posts新建一个 Markdown 文件。 打上标签 打标签能让你的文章方便检索。 打开标签功能： hexo new page tags 这时候你的source/下生成 tags/index.md 文件，我们将其打开，然后把它改成： type: \"tags\" comments: false 这时候你要为你的文章打上标签就可以在文章的头部写上 --- title: Java 安装与使用 date: 2021-12-28 15:36:27 tags: Java tags: \u003c\u003c其他你想打的标签\u003e\u003e --- 添加分类 分类，归档，是你博客的特性之一。 打开分类功能： hexo new page categories 这说你的source目录下生成 categories/index.md 文件，我们将其打开，把它改成： type: \"categories\" comments: false 这时候你就可以给你的文章归类存档了，使用方式就是在你的文章的头部加上 --- title: Java 安装与使用 date: 2021-12-28 15:36:27 tags: Java categories: Java categories: \u003c\u003c其他你想分的类\u003e\u003e --- 注意：标签和分类要确定你的配置文件 _config.yml 是否有打开了 tag_dir: tags 和 category_dir: categories。另外，Markdown 的语法是写作最优雅最简洁最简单的，如果之前没用过的建议去学一下Markdown 语法说明 ，一般一个钟左右就能掌握。因为它和HTML那样简单。 添加评论系统 keep主题提供评论系统，详情见keep comment 这里先暂时不开启评论了。因为发现创建完之后还是无法评论。 部署到线上 可以通过GitHub Pages来创建免费的线上访问地址。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:3:2","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"安装 Git Windows：下载并安装 git . Mac：使用 Homebrew , MacPorts 或者下载 安装程序 。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Mac 用户 如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -\u003e Download -\u003e Command Line Tools -\u003e Install 安装命令行工具。 Windows 用户 对于中国大陆地区用户，可以前往 淘宝 Git for Windows 镜像 下载 git 安装包。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:4:0","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"创建Github pages 仓库 创建一个xxx.github.io的 public 仓库，这里的xxx写你的名字，比如我写的是 Smithkenny.github.io ,那么到时我就可以通过 Smithkenny.github.io 来访问我的网站了。 创建完成之后，那么你就有自己的 Git 地址了。 安装hexo-deployer-git cd Smithkenny.github.io npm install hexo-deployer-git --save ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:0","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"配置你的Git 打开你的配置文件_config.yml： deploy: type: git repo: https://github.com/xxx/xxx.github.io.git // 输入你的git地址 github地址查看： ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:1","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"推送你的网站到Github上 hexo d # d 就是 deploy，部署上去的意思。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:2","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"访问你的网站 直接在浏览器输入你的 xxx.github.io 就可以访问了。 绑定自己的域名 添加 CNAME 文件 # 进入sources cd sources # 创建CNAME文件，写入自己的域名，如：www.haipengv.com touch CNAME 在你的域名商后台进行 DNS 解析添加两条记录 主机记录： @ 记录类型：A 记录值：ip1 或者 ip2 主机记录： www 记录类型： CNAME 记录值： Smithkenny.github.io (这里就是你的github仓库名称) ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:3","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"GitHub 设置域名 在你的 GitHub 设置域名，在你的 GitHub 博客项目中点击 Settings，在 GitHub Pages 下的 Custom domain 写上你的域名，然后 save。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:4","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"自动部署 根据之前的步骤我们使用 Hexo + Keep 主题搭建了一个在线博客，下面教你如何使用 GitHub Actions 将博客自动部署到 GitHub Pages。以下内容参考了keep主题作者的博文 . GitHub Actions 创建 GitHub 仓库 创建一个私有仓库用来存储 Hexo 项目源代码。（保证你的重要信息不泄露） myblog-source仓库的master分支用来存放源代码 注意私有仓库默认分支已经变为main。需要更改名称为master 创建私有仓库 公共仓库用来存储编译之后的静态页面。（这里就不用在创建仓库了，之前我们部署过github pages到xxx.github.io） xxx.github.io这个仓库的master分支用来存储静态文件 当私有仓库的 master 有内容 push 进来时（例如：主题文件，文章 md 文件、图片等）， 会触发 GitHub Actions 自动编译并部署到公共仓库的 master分支。 创建 GitHub Token 创建一个有 repo 和 workflow 权限的 GitHub Token 。 新生成的 Token 只会显示一次，如有遗失，重新生成即可。 创建 repository secret 将上面生成的 Token 添加到私有仓库的 Secrets 里，并将这个新增的 secret 命名为 HEXO_DEPLOY （名字无所谓，看你喜欢）。 步骤：私有仓库 -\u003e settings -\u003e Secrets -\u003e New repository secret。 新创建的 secret HEXO_DEPLOY 在 Actions 配置文件要用到，需跟配置文件保持一致！ 添加 Actions 配置文件 在你的 Hexo 项目根目录下创建 .github 文件夹。 在 .github 文件夹下创建 workflows 文件夹。 在 workflows 文件夹下创建 hexo-deploy.yml 文件。 hexo-deploy.yml 文件配置如下：(这里是关键) name: deploying Hexo project to GitHub pages on: push: branches: - master # master 分支有 push 行为时就触发这个 action jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@master - name: Build and Deploy uses: theme-keep/hexo-deploy-github-pages-action@master # 使用专门部署 Hexo 到 GitHub pages 的 action env: PERSONAL_TOKEN: ${{ secrets.HEXO_DEPLOY }} # secret 名 PUBLISH_REPOSITORY: Smithkenny/Smithkenny.github.io # 公共仓库，格式：GitHub 用户名/仓库名 BRANCH: master # 分支，我这里是推送到Smithkenny/Smithkenny.github.io仓库里的master分支(根据自己的仓库进行填写) PUBLISH_DIR: ./public # 部署 public 目录下的文件 自动部署触发流程 修改你的 Hexo 博客源代码（例如：增加文章、修改文章、更改主题、修改主题配置文件等等）。 把你修改过的 Hexo 项目内容（只提交修改过的那部分内容） push 到 GitHub 公共仓库（本例：Smithkenny.github.io）的 master 分支。 GitHub Actions 检测到 master 分支有内容 push 进来，会自动执行 action 配置文件的命令，将 Hexo 项目编译成静态页面，然后部署到私有仓库的 master 分支。 在私有仓库的 Actions 可以查看到你配置的 action。 这样的好处是源码保存在线上私有仓库中，具有可移植性。更改源码后不用再手动重新部署、上传。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:5","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"源码上传 上传前的准备 配置ssh key win10 ssh key 默认在当前用户的.ssh文件夹内。 ssh-keygen -t rsa -C \"xxx@qq.com\" 密钥路径： .ssh\\id_rsa.pub 公钥 .ssh\\id_rsa 私钥 打开你的github主页，进入个人设置 -\u003e SSH and GPG keys -\u003e New SSH key： 名字：git-push 密钥输入公钥内容。 测试时是否成功： ssh -T git@github.com 在网站根路径下右键Git Bash Here,通过git 命令来上传源码到私有仓库。 还需要配置： git config --global user.name \"Smithkenny\"// 你的github用户名，非昵称 git config --global user.email \"xxx@qq.com\"// 填写你的github注册邮箱 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:6","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"上传源码 初始化git git init 将改动添加到暂存区 git add . 添加说明 git commit -m \"代码上传\" 将本地更改推送到远程master分支 git push origin master 注意 如果报错，说明本地仓库代码和私有仓库代码不一致，可以用以下方式解决。 先从私有库（myblog-source）把代码拉下来，会自动合并的（不用操心） git pull origin master 可以通过如下命令进行代码合并 git pull --rebase origin master 再将本地更改推送到远程master分支 git push origin master 每次新增、修改文章都需要执行以下代码一次： git add . （将改动添加到暂存区） git commit -m \"提交说明\" git push origin master 将本地更改推送到远程master分支。 然后私有仓库中的action检测到有代码改动会自动重新部署。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:7","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"总结： 笔记本生成id_rsa是私钥，id_rsa.pub是公钥。公钥可以用记事本打开 配置路径：github网站–\u003eSettings–\u003eSSH and GPG keys 配置公钥。用于笔记本和github连接。 github action 执行流程，公共仓展示静态页面，私有仓保存文章，源代码等等。action检测到私有仓库内变动，会自动打包部署到公共仓。不用在笔记本本地再部署，上传。 上传代码需要用笔记本创建的私钥和私有仓库中secrects 中的公钥进行匹配。 hexo g 会在网站的根路径下创建public目录和db.json hexo clean 会删除hexo g 执行后所创建的内容。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:8","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"遇到的问题： 源代码上传后，页面使用的主题配置没生效，修改过的配置都没生效，logo也不显示，绑定的自定义域名也失效了。 解决方法： 在网站根路径下的source文件夹内创建_data文件夹，把keep主题配置 _config.yml复制一份命名为keep.yml。 如果以后配置有所更改，需要_data文件夹内的keep.yml和keep主题内的 _config.yml文件保持一致。 source文件夹内新建images 文件夹，用来存放图片。再创建CNAME 文件，文件内填写个人域名。如：haiewebpv.com 再次上传源码。等待部署完成后查看网站。 D:\\newblog\\source\\keep.yml 文件为D:\\newblog\\node_modules\\hexo-theme-keep_config.yml的备份文件。平滑升级hexo后 _config.yml会重置，所以要备份。 站点根路径： D:\\newblog\\ D:\\newblog\\source 内文件夹： _data _posts about categories images links CNAME # 文件 keep 主题配置文件路径 D:\\newblog\\node_modules\\hexo-theme-keep\\_config.yml 如何访问网站？ https://smithkenny.github.io/ https://haipengcv.com ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:9","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"新上传文章流程 在网站根目录内，右键git bash here 并创建文章标题 hexo new title \"new-article\" 上述命令的结果是在 ./hexo/source/_posts 路径下新建了一个 new-article.md` 文件。 进入到/source/_posts内编辑文章内容。 cd source/_posts vim new-article.md --- title: new-article date: 2022-01-01 18:11:25 tags: categories： --- 也可以用typora打开，直接编辑。也可以创建分类categories 便于搜索。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:10","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"博客中的图片处理 有以下两种方式保存图片： 将图片上传到网站根路径source/images中，在文章中引用相对路径。 使用网路路径，然后在文章中引用该路径。 下面来说明如何使用网路路径： 搭建个人图床，使用github公有仓库充当云存储。新建公有仓库，起名为Myimage。 并在仓库内创建一个img文件夹并加以说明。 创建个人访问令牌 获取路径 Settings –\u003e Developer settings–\u003e Personal access tokens –\u003e New personal access token –\u003e copy token jsdelivr充当cdn，使图片访问更快 https://www.jsdelivr.com/?docs=gh 获取cdn地址 举例： 我的这个图床仓库名是Smithkenny/Myimage https://github.com/Smithkenny/Myimage cdn地址为： https://fastly.jsdelivr.net/gh/Smithkenny/Myimage/img 图片名称.webp 使用picGo充当图片git push 工具 https://github.com/Molunerfinn/PicGo 安装地址：https://github.com/Molunerfinn/PicGo/releases 配置picGo 将github图床设置为默认图床。 上传图片处理 PicGo支持批量和单个的图片上传 批量上传，把图片批量拖拽到大红框 单个上传，复制后，点击小红框 文章中使用图床中的图片格式 中括号小括号 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:11","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"后记 keep主题相关设置 设置标题、作者、url自定义logo、背景图片。开启百分比滚动条。添加个人联系方式。增加categories、links、about。开启文章预览。字数统计、作者标签。文章中代码可复制、启用左侧目录。开启文章最下方版权所有，开启全局搜索功能、开启rss订阅、cdn、慢加载功能。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:12","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"更换电脑如何上传文章到GitHub 前期准备 新电脑需要安装git、hexo。并把旧电脑用户目录下.ssh文件夹内公钥和私钥复制出来到新电脑的用户目录的.ssh文件夹内。 具体步骤 创建myblog文件夹 /e/myblog 右键git bush here。初始化git，会自动在/e/myblog目录内创建.git文件夹 git init 测试笔记本到GitHub私有仓库的连通性。 ssh -T git@github.com Hi Smithkenny! You've successfully authenticated, but GitHub does not provide shell access. 添加信息 git config --global user.name \"Smithkenny\"// 你的github用户名，非昵称 git config --global user.email \"xxx@qq.com\"// 填写你的github注册邮箱 配置远端仓库并远程拉取源代码到本地 git remote add origin git@github.com:Smithkenny/myblog-source.git git pull origin master remote: Enumerating objects: 345, done. remote: Counting objects: 100% (345/345), done. remote: Compressing objects: 100% (248/248), done. remote: Total 345 (delta 167), reused 231 (delta 71), pack-reused 0 Receiving objects: 100% (345/345), 1.87 MiB | 105.00 KiB/s, done. Resolving deltas: 100% (167/167), done. From github.com:Smithkenny/myblog-source * branch master -\u003e FETCH_HEAD * [new branch] master -\u003e origin/master 然后就可以修改文章，最后上传文章了。步骤见新文章上传流程。 报错信息 使用拉取源码到本地时，当本地的环境和远端环境中某些文件名字相同内容不同时，会出现远端部分文件拉取失败。此时只要删除提示中本地的文件，再次执行拉取命令即可。 git pull origin master remote: Enumerating objects: 360, done. remote: Counting objects: 100% (360/360), done. remote: Compressing objects: 100% (256/256), done. remote: Total 360 (delta 178), reused 242 (delta 78), pack-reused 0 Receiving objects: 100% (360/360), 1.87 MiB | 1.33 MiB/s, done. Resolving deltas: 100% (178/178), done. From github.com:Smithkenny/myblog-source * branch master -\u003e FETCH_HEAD * [new branch] master -\u003e origin/master error: The following untracked working tree files would be overwritten by merge: .github/dependabot.yml .gitignore _config.landscape.yml _config.yml package-lock.json package.json scaffolds/draft.md scaffolds/page.md scaffolds/post.md themes/.gitkeep Please move or remove them before you merge. Aborting 清空github上私有仓库源代码，将本地重新创建好的博客源码上传到远端私有仓库。 github actions报错 需要重新创建博客源码文件夹，重复以下操作。 1.初始化博客文件夹,如果初始化缓慢需要设置代理。 #$ export http_proxy=http://\u003cWindows 主机的 IP 地址\u003e:\u003c代理端口\u003e #$ export https_proxy=http://\u003cWindows 主机的 IP 地址\u003e:\u003c代理端口\u003e #使用下面的命令取消代理： #$ unset http_proxy https_proxy hexo init myblog-source 2.进入到目录 cd myblog-source npm install 3.将旧文件夹内_config.yaml复制到myblog-source内 4.下载主题，使用keep主题 npm install hexo-theme-keep 5.重新生成和运行 hexo clean hexo g hexo s 6.创建标题、分类、归档、友联、关于，在Myblog-source\\source内新建images文件夹，并分别在旧文件夹下对应位置将内容复制到新博客内 hexo new page \"categories\" hexo new page \"about\" hexo new page \"links\" 7.将旧文件夹source\\_data复制到\\Myblog-source\\source\\_data内 8.将旧文件夹\\node_modules\\hexo-theme-keep中_config.yml复制到新博客路径\\Myblog-source\\node_modules\\hexo-theme-keep内 9.将旧文件夹根路径下CNAME文件复制到新博客根路径下 10.在新博客文件夹内初始化git，会生成.git文件夹。 git init git add . git commit -m \"代码上传\" git push origin master 如果报以下错误：Github \"Updates were rejected because the remote contains work that you do not have locally.\" 则： 查看git远程仓库 git remote -v 没有则使用以下命令添加： git remote add origin [//your github url] 拉取远程仓库镜像 git pull origin master --allow-unrelated-histories 10.然后再执行以下命令推送到仓库 git add . git commit -m \"代码上传\" git push origin master 报错解决参考 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/:5:13","tags":["建站"],"title":"个人博客建站全过程","uri":"/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%99%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"categories":["网站"],"content":"简介 namesilo是国外的域名服务商，首次购买和续费价格都很实惠，不用翻墙也可以打开，此外还赠送隐私保护，支付方式支持支付宝、Paypal、Visa 等多种付款方式。 下面是namesilo购买域名的步骤流程 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%B4%AD%E4%B9%B0%E6%95%99%E7%A8%8B/:0:1","tags":["域名"],"title":"个人域名注册购买教程","uri":"/%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%B4%AD%E4%B9%B0%E6%95%99%E7%A8%8B/"},{"categories":["网站"],"content":"登陆https://www.namesilo.com/，注册账号 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%B4%AD%E4%B9%B0%E6%95%99%E7%A8%8B/:0:2","tags":["域名"],"title":"个人域名注册购买教程","uri":"/%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%B4%AD%E4%B9%B0%E6%95%99%E7%A8%8B/"},{"categories":["网站"],"content":"输入要注册的域名查找、选择、结账 Auto-Renew：设置域名是否自动续费，自行确定，影响不大。 Privacy Setting：代表域名隐私保护设置，建议设置成 WHOIS Privacy ，反正是免费的。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%B4%AD%E4%B9%B0%E6%95%99%E7%A8%8B/:0:3","tags":["域名"],"title":"个人域名注册购买教程","uri":"/%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%B4%AD%E4%B9%B0%E6%95%99%E7%A8%8B/"},{"categories":["网站"],"content":"解析域名 登录刚刚注册的账号选择my account 选择accounts domains 管理域名 删掉多余的记录 添加一条CNAME记录，添加一条A记录。A记录可以添加多条。 CNAME 指向github 的域名 github域名格式：[用户名].github.io A记录指向GIThub域名所解析出来的IP 注意：添加后不会立刻生效，此处有说明. You can use the form below to manage the DNS settings for the domain(s) listed above. Changes may take up to 15 minutes to completely process. Please keep in mind that correctly modifying the DNS records for this domain is extremely important. Any errors on your part could make your web site, email and other services inoperable. Please only utilize this form if you are comfortable and experienced managing DNS. 差不多半小时，域名就能解析成功。具体测试是否成功，可以在本地cmd的dos界面 ping 域名，查看IP，或者在一些域名查找对应IP的网站查询。 ","date":"2022-01-02","objectID":"/%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%B4%AD%E4%B9%B0%E6%95%99%E7%A8%8B/:0:4","tags":["域名"],"title":"个人域名注册购买教程","uri":"/%E4%B8%AA%E4%BA%BA%E5%9F%9F%E5%90%8D%E6%B3%A8%E5%86%8C%E8%B4%AD%E4%B9%B0%E6%95%99%E7%A8%8B/"},{"categories":["新年"],"content":"你好，2022！新年快乐🐣 ","date":"2022-01-01","objectID":"/happynewyear/:0:0","tags":[2022],"title":"happynewyear","uri":"/happynewyear/"},{"categories":["编程"],"content":"快速开始 系统环境:centos7 ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:0:0","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"安装之前先查看一下有无系统自带jdk rpm -qa |grep java rpm -qa |grep jdk rpm -qa |grep gcj ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:0","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"如果有就使用批量卸载命令 rpm -qa | grep java | xargs rpm -e --nodeps ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:1:1","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"使用yum安装1.8.0版本openjdk yum install java-1.8.0-openjdk* -y ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:2:0","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"查看版本 java -version openjdk version \"1.8.0_312\" OpenJDK Runtime Environment (build 1.8.0_312-b07) OpenJDK 64-Bit Server VM (build 25.312-b07, mixed mode) ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:0","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"默认jre jdk 安装路径是/usr/lib/jvm 下面 ll total 0 lrwxrwxrwx 1 root root 26 Dec 25 00:06 java -\u003e /etc/alternatives/java_sdk lrwxrwxrwx 1 root root 32 Dec 25 00:06 java-1.8.0 -\u003e /etc/alternatives/java_sdk_1.8.0 lrwxrwxrwx 1 root root 40 Dec 25 00:06 java-1.8.0-openjdk -\u003e /etc/alternatives/java_sdk_1.8.0_openjdk drwxr-xr-x 9 root root 176 Dec 25 00:06 java-1.8.0-openjdk-1.8.0.312.b07-1.el7_9.x86_64 lrwxrwxrwx 1 root root 34 Dec 25 00:06 java-openjdk -\u003e /etc/alternatives/java_sdk_openjdk lrwxrwxrwx 1 root root 21 Dec 25 00:06 jre -\u003e /etc/alternatives/jre lrwxrwxrwx 1 root root 27 Dec 25 00:06 jre-1.8.0 -\u003e /etc/alternatives/jre_1.8.0 lrwxrwxrwx 1 root root 35 Dec 25 00:06 jre-1.8.0-openjdk -\u003e /etc/alternatives/jre_1.8.0_openjdk lrwxrwxrwx 1 root root 51 Dec 25 00:06 jre-1.8.0-openjdk-1.8.0.312.b07-1.el7_9.x86_64 -\u003e java-1.8.0-openjdk-1.8.0.312.b07-1.el7_9.x86_64/jre lrwxrwxrwx 1 root root 29 Dec 25 00:06 jre-openjdk -\u003e /etc/alternatives/jre_openjdk ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:3:1","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"配置全局生效 vim /etc/profile #set java environment export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.el7_9.x86_64 export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:4:0","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"应用配置并查看是否生效 source /etc/profile echo $JAVA_HOME /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.el7_9.x86_64 echo $CLASSPATH .:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.el7_9.x86_64/jre/lib/rt.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.el7_9.x86_64/lib/dt.jar:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.el7_9.x86_64/lib/tools.jar echo $PATH /data/kafka_2.11-2.1.0/bin:/data/kafka_2.11-2.1.0/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-1.el7_9.x86_64/bin ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:5:0","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"创建一个java小程序测试下，名字叫 HelloWorld.java.输入以下命令: public class HelloWorld { public static void main(String[] args){ System.out.println(\"Hello World!\"); } } ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:6:0","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"编译并执行 javac HelloWorld.java java HelloWorld Hello World! ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:7:0","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"思考：如何运行.jar这类java应用？ ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:8:0","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"语法如下 java -jar file.jar java -jar /path/to/my/java/app.jar #/path/to/my/java/app.jar表示应用的路径 java -jar /path/to/my/java/app.jar arg1 arg2 # arg1表示参数1 ，arg2表示参数2 ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:8:1","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"},{"categories":["编程"],"content":"结束了 ","date":"2021-12-28","objectID":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/:8:2","tags":["java"],"title":"Java安装与使用","uri":"/java%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"}]