<!doctype html><html lang=en-us><head><meta name=generator content="Hugo 0.115.3"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>My New Hugo Site</title><meta name=Description content="This is my cool site"><meta property="og:title" content="My New Hugo Site"><meta property="og:description" content="This is my cool site"><meta property="og:type" content="website"><meta property="og:url" content="https://blog.haipengv.com/"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary"><meta name=twitter:title content="My New Hugo Site"><meta name=twitter:description content="This is my cool site"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://blog.haipengv.com/><link rel=alternate href=/index.xml type=application/rss+xml title="My New Hugo Site"><link rel=feed href=/index.xml type=application/rss+xml title="My New Hugo Site"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"WebSite","url":"https:\/\/blog.haipengv.com\/","inLanguage":"en-us","description":"This is my cool site","name":"My New Hugo Site"}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="My New Hugo Site">My cool site</a></div><div class=menu><div class=menu-inner><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="My New Hugo Site">My cool site</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class="page home" data-home=posts><div class=home-profile><div class=home-subtitle><div id=id-1 class=typeit></div></div><div class=links></div></div><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E5%B0%81%E8%A3%85/>封装</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Author</a>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-04-09>2022-04-09</time></span></div><div class=content>封装与反射 片面理解：封装相当于隐藏。
如何将属性隐藏（设置成私有）？ 用双下划线开头方式将属性隐藏起来。
1.__开头的属性只是一种语法意义上的变形，并不会真的限制外部的访问。_类名__属性名可以访问但毫无意义。
2.这种变形只在类的定义阶段发送一次，类定义之后再新增的__开头的属性不会变形。
3.这种隐藏只对外不对内，因为类内部定义的属性在类定义阶段统一发生变形。
class Foo: __N=0 def __init__(self): self.__X=10 def __foo(self): #相当于_Foo__foo() print('from A') def bar(self): self.__foo() f = Foo() #类实例化，f是对象。 f.bar() #结果 'from A'。内部调用了__foo()验证第3条。 f.__foo() #报错。AttributeError: 'Foo' object has no attribute '__foo'，属性被隐藏，外部不可调用。验证第一条外部不能访问隐藏属性。 # 可以用f._Foo__foo()调用，但毫无意义。验证第1条。 f.__N=10 print(f.__N) #验证第二条。类定义时已经定义了__N=0,而__N=10是在类定义之后。此时可以调用__N.结果为10 封装应用
class People: def __init__(self,name,age): # self.__name=name # self.__age=age self.set_info(name,age) def tell_info(self): print("姓名：&lt;%s> 年龄：&lt;%s>"%(self.__name,self.__age)) def set_info(self,name,age): if type(name) is not str: #判断name是否是str类型 raise TypeError('name must be str') if type(age) is not int: #判断age是否是int类型 raise TypeError('age must be int') self.</div><div class=post-footer><a href=/posts/%E5%B0%81%E8%A3%85/>Read More</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/>vsftpd相关配置</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Author</a>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-04-02>2022-04-02</time></span></div><div class=content>ftp基本配置 系统：centos7
安装vsftpd 、ftp客户端
yum install vsftpd -y yum install ftp -y [root@localhost vsftpd]# rpm -qa | grep ftp vsftpd-sysvinit-3.0.2-29.el7_9.x86_64 vsftpd-3.0.2-29.el7_9.x86_64 ftp-0.17-67.el7.x86_64 防火墙设置
firewall-cmd --list-services //查看防火墙允许的服务。 firewall-cmd --add-service=ftp --permanent //永久开放ftp服务 firewall-cmd --add-port=20/tcp --permanent firewall-cmd --add-port=21/tcp --permanent //允许外网访问 firewall-cmd --reload //重新载入配置 setsebool ftpd_full_access 1 //selinux设置 setsebool tftp_home_dir 1 创建用户，登录
useradd test passwd test ftp localhost #ftp本地测试 [root@localhost vsftpd]# ftp localhost Trying ::1... ftp: connect to address ::1Connection refused Trying 127.0.0.1... Connected to localhost (127.</div><div class=post-footer><a href=/posts/vsftpd%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/>Read More</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/>python文件处理</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Author</a>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-03-31>2022-03-31</time></span></div><div class=content>文件处理流程 1.打开文件，得到文件句柄并赋值给一个变量
2.通过句柄对文件进行操作
3.关闭文件
两种文件操作方式 直接操作（需要手动关闭文件） #1. 打开文件，得到文件句柄并赋值给一个变量 f=open('a.txt','r',encoding='utf-8') #默认打开模式就为r #2. 通过句柄对文件进行操作 data=f.read() #3. 关闭文件 f.close() 使用with关键字（推荐！自动关闭文件无需手动操作） #可用用with同时打开多个文件，用逗号分隔开即可 with open('a.txt','r',encoding='utf-8') as read_f,open('b.txt','w',encoding='utf-8') as write_f: data=read_f.read() write_f.write(data) 注意：若要保证不乱码，文件以什么方式存的，就要以什么方式打开。
f=open('a.txt','r',encoding='utf-8') linux默认编码'utf-8' windows默认编码 'gbk' python2中文件打开 #首先在python3中操作文件只有一种选择，那就是open() #而在python2中则有两种方式：file()与open() 两者都能够打开文件，对文件进行操作，也具有相似的用法和参数，但是，这两种文件打开方式有本质的区别，file为文件类，用file()来打开文件，相当于这是在构造文件类，而用open()打开文件，是用python的内建函数来操作，我们一般使用open()打开文件进行操作，而用file当做一个类型，比如type(f) is file。 打开文件的模式 基础 打开文件的模式有(默认为文本模式)
r，只读模式【默认模式，文件必须存在，文件存在文件内指针直接跳到文件开头,不存在则抛出异常】 w，只写模式【不可读；不存在则创建；存在则清空内容,文件指针跑到文件开头.】 a，之追加写模式【不可读；不存在则创建；存在则只追加内容，文件存在会将文件指针直接移动到文件末尾】 强调 在文件不关闭的情况下,连续的写入，后写的内容一定跟在前写内容的后面。
如果重新以w模式打开文件，则会清空文件内容。
a与w相同与异同 相同点：在打开的文件不关闭的情况下，连续的写入，新写的内容总会跟在前写的内容之后
不同点：以 a 模式重新打开文件，不会清空原文件内容，会将文件指针直接移动到文件末尾，新写的内容永远写在最后。
对于非文本文件，我们只能使用b模式，&ldquo;b"表示以字节的方式操作（而所有文件也都是以字节的形式存储的，使用这种模式无需考虑文本文件的字符编码、图片文件的jgp格式、视频文件的avi格式）
rb wb ab 注：以b方式打开时，读取到的内容是字节类型，写入时也需要提供字节类型，不能指定编码 在平时工作中，我们只单纯使用r/w/a，要么只读，要么只写，一般不用可读可写的模式。 大前提: tb模式均不能单独使用,必须与r/w/a之一结合使用。
t（默认的）：文本模式 1. 读写文件都是以字符串为单位的 2. 只能针对文本文件 3. 必须指定encoding参数 b：二进制模式: 1.读写文件都是以bytes/二进制为单位的 2. 可以针对所有文件 3.</div><div class=post-footer><a href=/posts/python%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/>Read More</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/>常见问题总结</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Author</a>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-03-28>2022-03-28</time></span></div><div class=content>描述Linux下软链接和硬链接的区别 实践：当前所在路径/root
准备工作
echo 123 > /tmpdisk/a.txt echo 123 > /tmpdisk/b.txt mkdir -p /tmpdisk/ylink mkdir -p /tmpdisk/rlink 分别创建软链接和硬链接
ln -s /tmpdisk/a.txt ra.txt ln /tmpdisk/b.txt yb.txt ln /tmpdisk/ylink ylink #创建失败，硬链接不允许文件夹创建。ln: '/tmpdisk/ylink': hard link not allowed for directory ln -s /tmpdisk/rlink rlink 查看inode节点
[root@43f873a76b81 ~]# ls -li total 8 84271555 -rw------- 1 root root 3302 May 31 2018 anaconda-ks.cfg 87108116 lrwxrwxrwx 1 root root 14 Mar 28 06:18 ra.txt -> /tmpdisk/a.txt 87108117 lrwxrwxrwx 1 root root 14 Mar 28 06:18 rlink -> /tmpdisk/rlink 1588983 -rw-r--r-- 2 root root 4 Mar 28 05:27 yb.</div><div class=post-footer><a href=/posts/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/>Read More</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/>类和对象</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Author</a>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-03-27>2022-03-27</time></span></div><div class=content>面向过程与面向对象 面向过程 核心就是过程二字，过程即解决问题的步骤，就是先干什么再干什么 基于该思想写程序就好比在设计一条流水线，是一种机械式的思维方式 优点：复杂的过程流程化，进而简单化 缺点：扩展性差
面向对象 核心是对象二字，对象是特征与技能的结合体 基于该思想编写程序就好比在创造一个世界，世界是由一个个对象组成的，是一种“上帝式” 的思维方式 优点：可拓展性强 缺点：编程复杂高，容易出现过度设计
类 对象是特征与技能的结合体，类就是一系列对象相似的特征与技能的结合体。
在现实世界中：一定是现有的一个个具体存在的对象，后总结出的类。
在程序中：一定保证先定义类，后产生对象。
类体代码在类的定义阶段就会立刻执行。
在程序中特征用变量标识，技能用函数标识。
因而类中最常见的无非是：变量和函数的定义
Student是类名，school是特征，def定义的函数都是技能。
class Student: school = 'taiyang' def learn(self): print('is learning') def sleep(self): print('is sleeping') def choose_course(self): print('choose course') print(Student.__dict__) 查看 print(Student.school) #数据属性是所有对象共享的 print(Student.learn) #函数属性是绑定给对象用的 新增 Student.country = 'china' print(Student.country) 删除 del Student.country print(Student.country) 注意 类中可以有任意python代码，这些代码在类定义阶段便会执行
因而会产生新的名称空间，用来存放类的变量名与函数名，可以通过Student.__dict__查看
对于经典类来说我们可以通过该字典操作类名称空间的名字（新式类有限制），但python为我们提供专门的.语法。
点是访问属性的语法，类中定义的名字，都是类的属性。
程序中类的用法 .专门用来访问属性，本质操作的就是__dict__
Student.school 等于经典类的操作Student.__dict__['school']
Student.school='taiyang'等于经典类的操作Student.__dict__['school']=‘taiyang’
Student.x=1等于经典的类的操作Student.__dict__['x']=1
del Student.x等于经典的类的操作Student.__dict__.pop('x')
python中类内置的特殊属性 类名.__name__# 类的名字(字符串) 类名.__doc__# 类的文档字符串 类名.</div><div class=post-footer><a href=/posts/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/>Read More</a></div></article><article class="single summary" itemscope itemtype=http://schema.org/Article><h1 class=single-title itemprop="name headline"><a href=/posts/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/>序列化与反序列化</a></h1><div class=post-meta><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Author</a>
</span>&nbsp;<span class=post-publish>published on <time datetime=2022-03-26>2022-03-26</time></span></div><div class=content>什么是序列化？ 我们把对象（变量）从内存中变成可存储或传输的过程称之为序列化。在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。
为什么要序列化？ 持久保存状态
内存是无法永久保存数据的，当程序运行了一段时间，我们断电或者重启程序，内存中关于这个程序的之前一段时间的数据（有结构）都被清空了。在断电或重启程序之前将程序当前内存中所有的数据都保存下来（保存到文件中），以便于下次程序执行能够从文件中载入之前的数据，然后继续执行，这就是序列化。
跨平台数据交互
序列化之后，不仅可以把序列化后的内容写入磁盘，还可以通过网络传输到别的机器上，如果收发的双方约定好实用一种序列化的格式，那么便打破了平台/语言差异化带来的限制，实现了跨平台数据交互。 反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。
如何序列化之json和pickle json反序列化
如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：
json类型 python类型 {} dic [] list &ldquo;string&rdquo; str 1234.56 int或float true/false True/False null None 内存中结构化的数据->格式json->字符串->保存到文件中或基于网络传输
序列化
python->json
json.dumps() json.dump() 反序列化
json->python
json.loads() json.load() 练习 需求1
把user = {'name': 'jack', 'age': 20, 'sex': 'male'}序列化。保存为user_new.json
序列化
#1.使用dumps import json user = {'name': 'jack', 'age': 20, 'sex': 'male'} with open('user_new.json', 'w', encoding='utf-8') as f: f.write(json.dumps(user)) #结果 {"name": "jack", "age": 20, "sex": "male"} #2.</div><div class=post-footer><a href=/posts/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/>Read More</a></div></article><ul class=pagination><li class=page-item><span class=page-link><a href=/>1</a></span></li><li class=page-item><span class=page-link aria-hidden=true>&mldr;</span></li><li class=page-item><span class=page-link><a href=/page/10/>10</a></span></li><li class=page-item><span class=page-link><a href=/page/11/>11</a></span></li><li class="page-item active"><span class=page-link><a href=/page/12/>12</a></span></li><li class=page-item><span class=page-link><a href=/page/13/>13</a></span></li><li class=page-item><span class=page-link><a href=/page/14/>14</a></span></li><li class=page-item><span class=page-link aria-hidden=true>&mldr;</span></li><li class=page-item><span class=page-link><a href=/page/19/>19</a></span></li></ul></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.115.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2022 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank></a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.1/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/typeit@8.5.4/dist/index.umd.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},data:{"id-1":"This is my cool site"},typeit:{cursorChar:"|",cursorSpeed:1e3,data:{"id-1":["id-1"]},duration:-1,speed:100}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>